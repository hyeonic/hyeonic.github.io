## 2021.07.25 삽질의 연속, javawesome

## 삽질의 연속

Spring security, Spring Oauth2 client, 각 social Oauth 인증 등 다양한 궁금증과 지식이 섞여 머리속을 헤집었다. 구현하고 싶은 것은 많았지만 차근차근 쌓아놓지 못하였기 때문에 다시한번 재정비를 하고 알고자하는 것을 정리하기로 하였다.

보통의 웹서버는 쿠키와 세션을 기반으로 로그인/회원가입 기능을 구현한다. 하지만 세션은 한계를 가지고 있다. 관련 내용은 추후 정리할 예정이다.

### 세션

세션은 클라이언트가 로그인을 시도하여 성공하면 서버가 해당 유저의 세션을 만들고 쿠키에 담아 전달한다. 서버에서는 메모리나 데이터베이스에 해당 세션 정보를 저장한다. 이러한 세션 데이터는 서버의 메모리를 사용하기 때문에 서버를 확장할 때 모든 서버가 이러한 세션 정보를 가지고 있어야 한다. 각 서버별로 세션을 복제할 수도 있지만 중앙에서 세션을 관리하는 시스템이 추가적으로 필요하게 된다.

또한 이러한 중앙 세션 관리 시스템에 문제가 생기면 시스템 전체에 큰 영향을 끼치게 된다. 또한 보조 메모리 장치에 해당 정보를 관리하기 때문에 io에서 오는 속도차이가 존재한다. 빠르게 변하는 웹 사이트는 매번 세션 정보를 요구하는데 이러한 속도 차이는 무시할 수 없다.

정리하면, 규모 확장이 필요없는 소규모 프로그램에서는 세션 기반 인증 방식을 사용해도 크게 지장이 없을 것이다.

### JWT

JWT(Json Web Token)은 토큰 기반 인증 방식이다. 서버는 클라이언트의 세션 정보를 저장하는 것이 아니라 필요한 정보를 토큰에 저장해 클라이언트가 직접 가지고 사용하도록 한다. JWT에는 크게 3가지로 나눠져 있다.

```
aaaaaaaaaa.bbbbbbbbbb.cccccccccc
```

* Header `aaaaaaaaaaa`: JWT인 토큰의 유형이나 사용되는 해시 알고리즘이 무엇으로 사용했는지에 대한 정보가 담겨져 있다. Base64Url로 인코딩 되어 있다.
* Payload `bbbbbbbbbb`: 클라이언트에 대한 정보가 담겨져 있다. Base64Url로 인코딩 되어 있다.
* Signature `cccccccccc`: header에서 지정한 알고리즘과 secret키, 서명으로 payload와 header를 담는다.

JWT는 기본적으로 token 자체 내에 정보를 가지고 있다. 클라이언트는 이러한 payload 정보를 해독할 수 있기 때문에 중요 데이터를 넣으면 안된다. 또한 수정하여 사용하기 위해서는 secret key를 알고 있어야 한다.

1. A가 B에게 JWT를 보내려 한다.
2. A, B 둘다 암호화한 secret key를 알고 있다.
3. C는 secret key를 알지 못하지만 A, B 사이의 JWT를 몰래 변경하려 한다.
4. A는 이를 방지하기 위해 Signature 부분에 (payload + secret key)를 특정 알고리즘으로 해시화하여 추가했다.
5. C가 이 JWT를 변경하려 해도 secret key를 모르기 때문에 멋대로 변경이 불가능하다.
6. B는 C가 변경한 JWT를 받으면 해당 서명이 다르기 때문에 받지 않는다.

#### JWT의 인증 과정

1. 클라이언트가 로그인을 시도하고 성공하면 서버로부터 access 토큰을 부여받는다.
2. 이후 클라이언트가 모든 api를 요청할 때 이러한 토큰 정보를 http header에 함께 담아 전달한다.
3. 서버는 access token을 해독하여 확인하고 검증되면 해당 api 기능을 수행한다.
4. 기한이 만료되면 access token을 지워주고 재로그인하게 한다.

하지만 이런 방식에는 문제점이 존재한다. access token이 만료되면 사용 중에 갑자기 로그인을 시도하라고 할 것이다. 적절하게 수명을 잡지 않으면 만료될 때 마다 로그인을 해야할 것이다. 그렇다고 수명을 길게 가져가면 해독되어 사용될 가능성이 있다.

#### Refresh Token

이러한 문제점 해결을 위한 Refresh Token 이다. access token이 만료되면 이 Refresh token을 사용하여 새로운 AccessToken을 발급받을 수 있다. 서버는 이러한 Refresh Token이 저장되어 있으면 Access token이 만료되면 알아서 갱신해줄 수 있다. 또한 추가적으로 블랙 리스트에게 토큰 발급을 막을 수 있다.

---

## javawesome!

1. 1,2 장을 학습한 내용을 바탕으로 느낀점과 / 토론을 하고싶은 부분에 대해 자유롭게 의견을 나눈다.

2. 자 정리했던 내용에 대한 피드백이 있으면 한다.

3. 팀 블로그 개설 했음 - 이메일 취합 필요

4. 다음 북 리더 사다리

### 추가 의견
요약 + 자기 생각 및 공유하고 싶은 내용 같이 기재
래퍼런스한 자료 명시

### 책을 보고 느낀점

동열 - 한번이라도 본 사람이 수월한 것 같다. 처음 보고 지금 다시 봤지만 더 느끼는게 많았다.

수진 - 본질적인 객체지향에 다시 한번 이론으로 잘 정리해줬다.

기현 - 언어로 접한 객체

세연 - 책을 읽으면서 구현해야 하는 코드들이 생각났다.

### 객체지향이 뭘까?

동열 - 객체단위로 프로그래밍 하는 것

세연 - 객체가 주체가 되서 주체에서 필요한 행동을 생각하고 모듈화를 해서 만드는 것

기현 - 새로운 세계를 재창조한다.

수진 - 객체들이 적절한 역할을 맡아서 책임을 다하는 것 

### 유연한 개발

세연 - 객체지향에 대한 코드를 짤 때 기본적인 엔티티부터 일련의 과정을 거침. 막힘없이 유연하게 할 수 있다. 테스트 케이스에서 필요한 기능을 깔끔하게 정리

동열 - 객체지향에 가장 큰 특징인 다형성을 활용
    - 상태보다 행동에 맞춰 

기현 - 책임을 중점적으로 생각하는 사고 방식

수진 - 책임을 먼저 생각하면 유연한 개발 가능! 더 나아가 다형성을 추가적으로 활용이 가능하다.

### 추상화 단순화 vs 구체화

기현 - 추상화하는 과정은 단순화하는 과정이라고 생각

수진 - 추상화를 하기 위해서는 구체적인 내용을 먼저 생각해야 한다. 공통적인 로직을 상속 받는 형태이기 때문에 구체화가 먼저 일어나야 한다.

동열 - 수진과 의견 동일

세연 - 책에서는 단순화라고 생각. 싸피에서는 책에서는 구체화라고 한다. 개인적인 생각은 구체화라고 생각. 

결과로보면 단순화에 가깝지만 과정은 구체화에 가깝다.

### 상태를 먼저 결정할 경우 캡슐화가 저해된다.

세연 - 먼저 상태를 생각하고 프로그래밍을 진행. 향후 테스트 코드 구현이 막막해지고 자연스럽지 못함을 느낀다. 필요한 행동을 먼저 생각.

### 캡슐화란?

동열 - 상태와 행동을 분리

### 값과 객체의 차이

기현 - 동등성, 동일성의 차이

수진 - 허수진이라는 사람을 비교. 나랑 똑같은 나이를 가진 허수진은 상태로 따지면 같다. 하지만 식별자가 다르기 때문에 다르다. **불변** 을 나타내는건 특정 시점의 객체 상태가 변하지 않는다.

값, 객체, 값 객체?

### 프로퍼티와 프로퍼티 값

동열 - 필드의 이름 프로퍼티, 필드의 값은 프로퍼티 값

---

## 내일 할일
 - 코테 준비