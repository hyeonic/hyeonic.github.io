## 2021.03.23 면접 준비, 정통 캡스톤 회의, 소프 캡스톤 회의

## 면접 준비

다양한 기술 면접에 대비하여 자료 조사를 진행하였다.

그래프와 트리의 차이점
그래프: 그래프는 개체간의 “관계”를 다룬다. 현실에서 수많은 개체가 상호작용하는데 이 둘이 (정의하기 나름인) 관계로 연결되어 있을 때 이 개체의 노드를 엣지로 이을 수 있고 이것이 곧 그래프다.

트리: 트리는 현실의 “계층”을 표현한다. 위 사진의 조직도가 대표적인데 정점인 대표이사부터 시작해서 자잘한 부서로 갈라져 나오는 것을 볼 수 있다. 트리는 그것을 추상화해 정점인 루트노드부터 시작해서 말단인 잎 노드까지 분기한다.

트리는 그래프의 한 종류이다. 트리는 가중치가 없고, 사이클이 없고, 두 정점 간의 최단 경로가 단 하나뿐이다. 간선의 개수는 정점의 개수에서 1을 뺀 값이다.

프로세스와 스레드
프로세스: 실행 중인 프로그램으로 디스크로부터 메모리에 적재되어 CPU의 할당을 받은 작업의 단위. 기본적으로 프로세스마다 최소 1개의 메인 스레드를 갖는다.

스레드: 프로세스의 실행 단위라고 할 수 있으며, 한 프로세스 내에서 동작되는 여러 실행 흐름으로 프로세스 내의 자원을 공유한다. Code, Data, Heap 영역은 공유하고, 각각의 스레드는 Stack 영역을 따로 할당 받는다.

Context Switching
CPU는 한 번에 하나의 프로세스만 처리할 수 있다. 여러 프로세스를 처리해야 하는 상황에서 현재 진행중인 Task(프로세스, 스레드)의 상태를 PCB에 저장하고 다음에 진행할 Task의 상태 값을 읽어 적용하는 과정을 말한다. 
정리하면, (다른 프로세스에게 CPU를 할당해 작업을 수행하는 과정을 말한다.)

CPU의 메모리 병목현상 해결 방법
 - 자주 접근하는 영역은 캐쉬에 저장하여 접근 속도를 향상시킨다.

프로세스와 쓰레드의 차이
 - 프로세스: 실행중인 프로그램
 - 쓰레드: 프로세스 내에서 실행되는 흐름의 단위. 쓰레드 사이에서 stack 영역을 제외하고는 프로세스의 자원이 공유된다.

DB ACID
 - Atomicity 원자성: 트랜잭션 연산은 DB에 모두 반영되거나 전혀 반영되지 않아야 한다.
 - Consistency 일관성: 트랜잭션이 그 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환한다.
 - Isolation 고립성: 트랜잭션 실행 중 생성하는 연산의 중간 결과를 다른 트랜잭션이 접근 불가능하다 - Durability 지속성: 성공적으로 완료된 트랜잭션의 결과는 시스템이 고장 나더라도 영구적으로 반영되어야 한다.

트랜잭션
 - 데이터베이스의 상태를 변환시키기 위해 수행하는 작업의 단위이다. 중간에 오류가 있으면 전부 롤백한다.

OS 선점 스케줄링, 비선점 스케줄링
스케줄링: 자원을 어떤 프로세스에게 얼마나 할당할 것인지 정책을 만드는 것이다.
비선점(Non-Preemptive) 스케줄링
 - 이미 할당된 CPU를 다른 프로세스가 강제로 빼앗아 사용할 수 없는 스케줄링
 - 프로세스가 CPU를 할당 받으면 해당 프로세스가 완료될 때까지 CPU 사용
 - 모든 프로세스에 대한 요구를 공정하게 처리 가능

비선점 스케줄링 종류
FCFS (First-Come First-Service)
- 준비상태 큐에 도착한 순서에 따라 차례로 CPU를 할당한다.
 - 먼저 도착한 것이 먼저 처리되어 공평성을 유지한다. 짧은 작업이 긴 작업을 기다리는 경우가 발생한다.

SJF (Shortest Job First)
 - 실행시간이 가장 짧은 프로세스에 먼저 CPU를 할당하는 기법
 - 가장 적은 평균 대기 시간을 제공하는 최적 알고리즘

HRN (Highest Response ratio Next)
 - 실행시간이 긴 프로세스에 불리한 SJF 기법을 보완하기 위한 것으로, 대기 시간과 서비스 시간을 이용한 기법 
 - 우선순위 계산 공식 = (대기시간 + 서비스 시간) / 서비스 시간
 - 우선 순위 계산 결과값이 높은 것부터 우선 순위가 부여, 대기 시간이 긴 프로세스일 경우 계산 결과값이 높게 나옴.

선점(Preemptive) 스케줄링
 - 하나의 프로세스가 CPU를 할당 받아 실행하고 있을 때 우선순위가 높은 다른 프로세스가 CPU를 강제로 빼앗아 사용할 수 있는 스케줄링 기법
 - 우선순위가 높은 프로세스를 빠르게 처리할 수 있다.
 - 주로 빠른 응답시간을 요구하는 대화식 시분할 시스템에 사용
 - 선점으로 인한 많은 오버헤드를 초래한다.
 - 선점을 위해 시간 배당을 위한 인터럽트용 타이머 클럭이 필요하다.

선점 스케줄링 종류
RR (Round Robin)
 - 시분할 시스템을 위해 고안된 방식이다. FCFS 알고리즘을 선점 형태로 변경한 기법이다. 
 - FCFS 기법과 같이 준비상태 큐에 먼저 들어온 프로세스가 먼저 CPU를 할당 받지만 각 프로세스는 할당된 시간 동안만 실행한 후 실행이 완료되지 않으면 다름 프로세스에게 CPU를 넘겨주고 준비상태 큐의 가장 뒤로 배치한다. 할당되는 시간이 크면 FCFS와 같아지고, 할당되는 시간이 작으면 문맥 교환 및 오버헤드가 자주 발생한다.

SRT (Shortest Remaining Time)
 - 비선점 기법 SJF 알고리즘을 선점 형태로 변경한 기법이다.
 - 현재 실행 중 프로세스의 남은 시간과 준비상태 큐에 새로 추가한 프로세스의 실행시간을 비교해 가장 짧은 실행 시간을 요구하는 프로세스에게 CPU를 할당하는 기법이다.

선점 우선순위
 - 준비 상태 큐의 프로세스 중에서 우선순위가 가장 높은 프로세스에게 먼저 CPU를 할당한다.

HashMap의 원리
 - key와 value를 갖는 자료구조이다. 임의의 키 값을 해시 함수를 사용하여 해당 자료가 위치한 버킷의 주소 값을 바로 알아내어 찾아갈 수 있다.

HASH 함수
 - 임의의 길이의 데이터를 고정길이의 데이터로 매핑하는 함수
 - 해시함수의 결과 값이 중복될 수 있다. 이는 해시 충돌이라는 문제를 야기한다.

HASH
 - 해시 함수의 결과값으로 얻어지는 것으로 해시 값, 해시 코드, 체크섬, 해시라고 한다.
 - 해시테이블, 해시맵에 특정 자료가 저장되어 있는 버킷의 키 값으로 사용한다.

Hash Table
 - 레코드를 한 개 이상 보관할 수 있는 버킷들로 구성된 기억공간이다.
 - 각 버킷은 몇 개의 슬롯으로 구성되어 있다.

URL/URI의 차이
URI: 네트워크 상에서 자원 위치를 알려주기 위한 규약. 그리고 이 URI에는 두 가지 형태가 있는데 이것이, URL, URN이라는 것이다.

URL: 통합 자원 식별자로 인터넷에 있는 자원을 나타내는 유일한 주소. 

REST
 - HTTP URI(Uniform Resource Identifier)를 통해 자원(Resource)을 명시하고, HTTP Method(POST, GET, PUT, DELETE)를 통해 해당 자원에 대한 CRUD Operation을 적용하는 것을 의미한다.

REST API
 - REST를 통하여 API 서비스를 구현한 것이다.

RESTful 
 - REST API를 제공하는 웹 서비스를 RESTful 하다고 표현한다.

REST의 장단점
장점
- HTTP 프로토콜의 인프라를 그대로 사용하므로 REST API 사용을 위한 별도의 인프라를 구출할 필요가 없다.
- HTTP 프로토콜의 표준을 최대한 활용하여 여러 추가적인 장점을 함께 가져갈 수 있게 해준다.
- HTTP 표준 프로토콜에 따르는 모든 플랫폼에서 사용이 가능하다.
- Hypermedia API의 기본을 충실히 지키면서 범용성을 보장한다.
- REST API 메시지가 의도하는 바를 명확하게 나타내므로 의도하는 바를 쉽게 파악할 수 있다.
- 여러가지 서비스 디자인에서 생길 수 있는 문제를 최소화한다.
- 서버와 클라이언트의 역할을 명확하게 분리한다.

단점
표준이 존재하지 않는다.
사용할 수 있는 메소드가 4가지 밖에 없다.
HTTP Method 형태가 제한적이다.
브라우저를 통해 테스트할 일이 많은 서비스라면 쉽게 고칠 수 있는 URL보다 Header 값이 왠지 더 어렵게 느껴진다.
구형 브라우저가 아직 제대로 지원해주지 못하는 부분이 존재한다.
PUT, DELETE를 사용하지 못하는 점
pushState를 지원하지 않는 점

알고리즘 
- 수학과 컴퓨터 과학, 언어학 또는 관련 분야에서 어떠한 문제를 해결하기 위해 정해진 일련의 절차나 방법을 공식화한 형태로 표현한 것

객체지향, 절차지향
 - 절차지향: 순차적 실행에 초점을 둔다.
 - 객체지향: 객체간 관계에 초점을 둔다.
 - 객체지향은 코드 재활용성이 높지만 절차지향 보다 느리다.

쿠기와 세션
 - 쿠키: 클라이언트(브라우저) 로컬에 저장되는 키와 값이 들어 있는 작은 데이터 파일이다. 서버에서 생성하여 클라이언트로 전달한다.
ex) 
- 방문 사이트에서 로그인 시, "아이디와 비밀번호를 저장하시겠습니까?"
- 쇼핑몰의 장바구니 기능
- 자동로그인, 팝업에서 "오늘 더 이상 이 창을 보지 않음" 체크, 쇼핑몰의 장바구니

 - 세션: 사용자 정보 파일을 브라우저에 저장하는 쿠키와 다르게 서버 측에서 관리한다. 서버에서 클라이언트를 구분하기 위해 세션 ID를 부여하여 웹 브라우저가 서버에 접속해서 브라우저를 종료할 때까지 인증상태를 유지한다.
ex)
  - 각 클라이언트에게 고유 ID를 부여
  - 세션 ID로 클라이언트를 구분해서 클라이언트의 요구에 맞는 서비스를 제공
- 보안 면에서 쿠키보다 우수
- 사용자가 많아질수록 서버 메모리를 많이 차지하게 됨

JWT
 - JWT는 정보를 JSON 객체 형태로 주고받기 위해 표준규약에 따라 생성한 암호화된 문자열(토큰)이다.
 - token 방식을 사용하면 Session 저장소처럼 사용자의 인증 상태 데이터를 별도 저장소로 유지할 필요 없다.

OAtuth2 
 - OAuth는 인터넷 사용자들이 비밀번호를 제공하지 않고 다른 웹사이트 상의 자신들의 정보에 대해 웹사이트나 애플리케이션의 접근 권한을 부여할 수 있는 공통적인 수단으로서 사용되는, 접근 위임을 위한 개방형 표준이다.
 - kakao, facebook, google 등 다양한 기업에서 인증 서버를 운영하고 있다.

Authentication, Authorization
authentication (인증) 이란
 - 사용자의 신원을 식별하는 기능이다. 쉽게 말해서, 로그인 기능. 로그인 아이디와 비밀번호를 사용하여 사용자 신원을 확인하는 방법이 가장 널리 사용된다. 홍채 인식이나 얼굴 인식 방법이 앞으로는 많이 사용될 것이다.

authorization (인가) 이란
 - 쉽게 말해서, 권한 관리 기능. 현재 사용자가 어떤 권한을 가지고 있는지, 그 권한으로 어떤 기능을 실행할 수 있는지. 권한 관리 및 통제를 수행한다.

TCP, UDP
TCP
 - 연결지향, TCP 3 Way handshake를 통하여 가상의 연결을 만든다.
 - 데이터가 전달되는 것과 전달된 데이터의 순서를 보장한다.

UDP
 - 비연결형 서비스이다.
 - 데이터 전달을 보장하지 않고 순서를 보장하지 않는다. 
 - IP와 거의 같지만 추가적인 포트와 체크섬 정도가 추가된다.
 - TCP보다 속도가 빠르지만 신뢰성이 낮다.

MVC: 모델 뷰 클라이언트 디자인패턴 
모델은 클라에 노출되지않고 연산처리와 데이터베이스가 주된 목적
vew는 클라이언트에 나타나는 부분
Controller는 뷰에서 요청 모델에서 연산 가공된 데이터를 다시 뷰에 응답해주는 역할

MVVM: View를 나타내 주기 위한 Model이자 View를 나타내기 위한 데이터 처리를 하는 부분입니다

CORS
 - 외부 도메인에서 내 서버자원을 요청할 때 허용해주는 구조

싱글스레드와 멀티스레드
싱글스레드: 하나의 프로세스가 하나의 스레드를 갖는 프로세스
멀티스레드: 두 개의 스레드가 번갈아 가면서 일을 처리한다.

http와 https
- http: 웹브라우저와 서버간 자원을 주고받을 때 쓰는 통신규약
- https: 인터넷상에서 정보를 암호화하는 ssl프로토콜을 이용하여 데이터를 주고받는 통신규약, http 메시지를 암호화한 프로토콜이다, 공개키 암호화방식(비대칭키)

컨테이너
- 독립적으로 어플리케이션이나 필요한 라이브러리를 하나로 모아서 별도의 서버처럼 사용할 수 있게 한 것

VM보다 docker가 좋은 이유
 - docker는 host의 커널에 직접 접근한다.
 - VM은 host 위에 레이어가 올라간다.

가비지 컬렉터의 역할은?
- 메모리관리기법으로 동적으로 할당했던 메모리 영역 중에서 사용하지 않는 영역을 해제해준다.


## 정통 캡스톤 회의

앞으로 프로젝트에 적용할 방식에 대해 토론하였다. github organization에서 repository를 생성하여 진행하기로 하였다. 또한 jenkins의 간단한 원리까지 확인할 수 있었다. 

## 소프 캡스톤 회의

간단한 실습을 통하여 pull request와 merge하는 방식을 진행하였다. 다양한 시나리오를 정하고 그 상황에 맞게 진행하였고, 이제 어느정도 과정이 이해가 갔다. 실제 프로젝트를 진행할 때는 최대한 폐쇄적으로 Upstream repository를 운영해야 겠다는 생각이 들었다. 최소한의 권한으로 유지해야 겠다.

## 내일 할일
 - 알고리즘 공부하기
 - sw 마에스트로 면접 준비하기
 - 정통 캡스톤 엔티티 클래스 작성 관련 이슈 등록 및 PR