---
title: "2주차 과제: 자바 데이터 타입, 변수 그리고 배열"
# excerpt: "GitHub Blog 서비스인 github.io 블로그 시작하기로 했다."

categories:
  - Java
  - Live-study
tags:
  - java
  - livestudy
  - JDK
  - JRE
  - JVM
  - JIT
last_modified_at: 2020-11-17 20:00:00 +0900
---

## 목표
자바의 프르미티브 타입, 변수 그리고 배열을 사용하는 방법을 익힌다.

## 학습할 것
- 프리미티브 타입 종류와 값의 범위 그리고 기본 값
- 프리미티브 타입과 레퍼런스 타입
- 리터럴
- 변수 선언 및 초기화하는 방법
- 변수의 스코프와 라이프타임
- 타입 변환, 캐스팅 그리고 타입 프로모션
- 1차 및 2차 배열 선언하기
- 타입 추론, var

### 1. 프리미티브 타입 종류와 값의 범위 그리고 기본 값

||타입|할당되는 메모리 크기|기본값|데이터의 표현 범위|
|---|---|---|---|---|
|논리형|boolean|1 byte|false|true, false|
|정수형|byte|1 byte|0|-128 ~ 127|
|정수형|short|2 byte|0|-32,768 ~ 32,767|
|정수형|int|4 byte|0|-2,147,483,648 ~ 2,147,483,647|
|정수형|long|8 byte|0L|-9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807|
|실수형|float|4 byte|0.0F|-3.4E38 ~ 3.4E38|
|실수형|double|8 byte|0.0|-1.7E308 ~ 1.7E308|
|문자형|char|2 byte 유니코드|‘\n0000’|0 ~ 65,535|
참고 : https://gbsb.tistory.com/6

### 2. 프리미티브 타입과 레퍼런스 타입

#### 2.1 프리미티브 타입
 - 총 8가지의 기본형 타입이 있다. 기본형은 기본값을 가지고 있기 때문에 Null이 존재하지 않는다. 만약 Null을 넣고 싶으면 Wrapper class를 활용해야 한다.
 - 실제 값을 저장하는 공간이기 때문에 Stack 메모리에 저장된다.
 - 컴파일 시점에 담을 수 있는 크기를 벗어나면 컴파일 에러가 발생한다.
 - 기본형은 객체가 아니다.

#### 2.2 레퍼런스 타입
 - 프리미티브 타입을 제외한 타입들은 모두 레퍼런스 타입이다.
 - 빈 객체를 의미하는 Null이 존재한다.
 - 값이 저장되어 있는 곳의 주소값을 저장하는 공간으로 Heap 메모리에 저장된다.
 - 문법상으로 에러가 없지만 실행시에 에러가 나는 런타임 에러가 발생할 수 있다. 객체나 배열이 Null을 값으로 받고 사용하면 NullPointException이 발생하므로 값을 넣어야 한다.

|타입|기본값|할당되는 메모리 크기|
|---|---|---|
|배열 Array|Null|4 byte 객체의 주소값이 들어 간다.|
|열거 Enumeration|Null|4 byte 객체의 주소값이 들어 간다.|
|클래스 Class|Null|4 byte 객체의 주소값이 들어 간다.|
|인터페이스 Interface|Null|4 byte 객체의 주소값이 들어 간다.|
참고 : https://gbsb.tistory.com/6


### 3. 리터럴
 - 프로그램에서 직접 표현한 값.
 - 종류에는 정수, 실수, 문자, 특수 문자, 논리, 문자열 리터럴이 있다.

#### 3.1 정수 리터럴
 - 모든 임의의 정수 값은 정수 리터럴이다. 1, 2, 3, 10, 25 등등
 - 8진수는 01, 023, 012 등 표현한다. 그렇기 때문에 12와 012는 서로 다르게 인식될 수 있다.
 - 16진수는 0x23, 0X12, 0xAE 등 표현한다. 10 ~ 15는 A B C D E가 대신한다.
 - 모든 정수형 데이터는 기본적으로 int 형이기 때문에 long 데이터 자료형에 long 리터럴을 지정하기 위해 숫자 뒤에 l이나 L을 붙인다. 1L, 2L 등등 이렇게!

#### 3.2 실수 리터럴
 - 소수점 이하를 가지는 10진 값들이다. 10.13, 3.141592 등등
 - 기본형은 double 타입이다. 숫자 뒤에 d나 D를 추가할 수도 있다. 10.13d, 10.13D
 - float는 숫자 뒤에 f나 F를 추가해야 한다. 10.13f, 10.13F
 - 지수도 표현 가능하다. e나 E를 붙인다. 10E-1, 10e2

#### 3.3 문자 리터럴
 - 문자 한 개를 표현하는 것이다. ‘a’, ‘ㅋ’ 
 - 유니코드를 표현할 수도 있다. \u 다음에 네 자리 16진수로 2바이트의 유니코드를 표현한다. 문자 A를 표현하면? ‘\u0041’

#### 3.4 특수 문자 리터럴
|특수 문자|설명|
|---|---|
|`\b’|백스페이스|
|‘\t’|탭|
|‘\n’|다음 줄로 넘어감|
|‘\f’|폼 피드|
|‘\r’|캐리지 리턴|
|‘\’’|단일 인용 부호|
|‘\”’|이중 인용 부호|
|‘\\’|백 슬래시|

#### 3.5 논리 리터럴
 - 참을 의미하는 true
 - 거짓을 의미하는 false

#### 3.6 문자열 리터럴
- 문자열 리터럴은 “abcd”같이 이중 인용 부호를 사용하여 표현한다.
 - 기본 타입의 리터럴이 아니다. Java에서 문자열은 String class의 객체이기 때문이다. 

#### 3.7 [더 알아보기] 상수와 리터럴

__상수 constant__
 - 정수를 포함하여 다양한 데이터가 올 수 있고, 객체가 올 수도 있다. 말 그대로 데이터가 변하면 안된다.
 - 참조 변수를 상수로 지정하면 참조변수가 가리키는 인스턴스 안의 데이터 까지도 변하지 않을 것을 기대하지만 참조변수가 변하지 않는다는 의미이고 그 주소가 가리키는 데이터는 상수가 아니다. Java에서는 final로 표현한다.
 - final String s = “abcd”’;

__리터럴 literal__
 - 데이터 그 자체를 뜻한다.
 - 변수에 넣는 변하지 않는 데이터 자체를 의미한다.
 - int a = 1을 예시로 들면 1이 리터럴이 된다.
 - 그렇다면 인스턴스(클래스 데이터)는 리터럴이 될 수 있을까? 답은 아니오 이다. 왜냐하면 객체 안에 값이 언제든지 바뀔 수 있기 때문이다. 하지만 데이터가 변하지 않도록 설계한 immutable class를 들어보았을 것이다. 해당 클래스는 한번 생성하면 객체 안의 데이터가 변하지 않는다. 변하는 상황이 생기면 새로운 객체를 만들어서 리턴한다. Java의 String이 그 예이다. 이를 객체 리터럴이라고 표현하기도 한다. 그렇기 때문에 VO class도 immutable 하기 때문에 리터럴이 될 수 있다.

### 4. 변수 선언 및 초기화하는 방법

#### 4.1 변수 선언
- [타입] [변수이름];
- 변수의 이름은 자바 식별자의 규칙을 지켜야 한다. 식별자는 변수나 상수 메소드 클래스 등을 구분할 수 있는 이름이다.

#### 4.2 Java 식별자 규칙
 - 첫 문자가 문자나 ‘_’, ‘$’의 특수문자로 시작되어야 한다. 숫자로 시작할 수 없다.
 - 첫 문자가 아니라면, 문자나 ‘_’, ‘$’의 특수문자 그리고 숫자로 구성될 수 있다.
 - Java의 예약어는 식별자로 사용할 수 없다.
 - Java의 식별자는 대소문자를 구분한다.
 - 식별자 길이는 제한이 없고 공백은 포함할 수 없다.

#### 4.3 Java 일반적인 관례
 - 클래스 이름은 첫 글자를 대문자로 정의. 명사를 사용
 - 메소드 이름은 소문자의 동사로. 
 - 변수는 소문자의 명사
 - 상수는 모든 단어가 대문자인 파스칼 표기법을 사용 대문자의 명사
 - 여러 단어가 있으면 낙타 등처럼 내려갔다 올라가는 모양을 표현하는 카멜 표기법을 사용
 - 이외로 언더바를 사용하여 단어를 구분 짓는 스네이크 표기법이 있다.

#### 4.4 Java의 예약어
bstract, assert, boolean, break, byte, case, catch, char, class, ~~const~~, continue, default, do, double, else, extends, false, final, finally, float, for, ~~goto~~, if, implements, import, instanceof, int, interface, long, native, new, null, package, private, protected, public, return, short, static, super, switch, synchronized, this, throw, throws, transient, true	try, void, volatile, while					

__자바의 예약어 사용시 주의점__
•	const, goto 예약어는 현재는 자바에서 사용되지 않으며, 식별자로 사용 할 수 없음
•	자바의 예약어는 소문자로 이루어져 있고 대소문자를 구분하므로, TRUE, FALSE, NULL은 자바 예약어가 아님
•	C, C++언어에서 변수의 길이를 표현했던 sizeof 예약어는 자바에서 더 이상 사용되지 않음
•	assert는 j2sdk .14버전부터 추가된 예약어
•	const와 goto는 키워드 리스트에는 포함되어 있으나 실제로는 사용 불가능
•	True와 False는 boolean 형 상수
•	Null은 참조형 상수로서 「참조하는 곳이 없음」을 의미 
참고 : https://www.opentutorials.org/module/1226/8103

#### 4.5 초기화 하는 방법
 - 변수를 선언하고 처음으로 값을 저장하는 것!
 - 아직 scope에 대해 언급하지 않았지만, 멤버변수(인스턴스 변수, 클래스 변수)는 초기화를 하지 않아도 변수의 자료형에 맞게 기본값으로 초기화가 된다. 하지만 지역변수는 사용하기 전에 반드시 초기화를 해야 한다.
 - 멤버 변수의 초기화 방법에는 3가지가 있다. 
 - 명시적 초기화 (explicit initialization)
 - 생성자 (constructor)
 - 초기화 블록 (initialization block)
 - 인스턴스 초기화 블록 : 인스턴스변수 초기화
 - 클래스 초기화 블록 : 클래스 변수 (static 변수) 초기화

##### 4.5.1 명시적 초기화, 생성자
 - 변수 선언과 동시에 초기화 하는 것
 - 기본형은 int door = 4;
 - 참조형은 생성자를 활용하여 String s = new String();

##### 4.5.2 초기화 블럭
 - 복잡한 초기화 작업이 필요할 때 사용한다.
```java
class InitClass {
    static { } // 클래스 초기화 블럭
    {   } // 인스턴스 초기화 블럭
}
```

 - 클래스 초기화 불럭은 클래스 변수 초기화에 사용된다. 클래스가 메모리에 처음 로딩될 때 한번만 수행된다. 클래스가 처음 로딩될 때 클래스 변수들이 자동적으로 메모리에 만들어지고 나서 바로 클래스 초기화 블럭이 클래스 변수들을 초기화 한다.
 - 인스턴스 초기화 블럭은 인스턴스 변수 초기화에 사용된다. 생성자와 같이 인스턴스를 생성할 때 마다 수행한다. 생성자가 실행되기 전에 인스턴스 초기화 블럭이 먼저 실행된다. 하지만 주로 생성자를 사용하기 때문에 잘 사용하지 않는다.

참고 : https://whatisthenext.tistory.com/30

#### 4.6 [더 알아보기] 생성자의 특징
 - 값을 반환하지 않는다. 생성자는 인스턴스를 생성해주는 역할을 하는 특수한 메소드이다. 하지만 반환값이 있다면 엉뚱한 객체가 생성될 수 있다. 그렇기 때문에 반환 타입과 return을 메소드 정의에 포함하지 않는다.
 - 생성자의 이름은 클래스의 이름과 동일하다. 

참고 : https://edu.goorm.io/learn/lecture/41/%EB%B0%94%EB%A1%9C%EC%8B%A4%EC%8A%B5-%EC%83%9D%ED%99%9C%EC%BD%94%EB%94%A9-%EC%9E%90%EB%B0%94-java/lesson/39236/%EC%B4%88%EA%B8%B0%ED%99%94%EC%99%80-%EC%83%9D%EC%84%B1%EC%9E%90

### 5. 변수의 스코프와 라이프타임

#### 5.1 변수의 스코프
 - 사용되는 모든 변수들은 사용가능한 범위를 가지고 있다. 그것이 변수의 스코프이다. 다양한 스코프를 가진 변수들이 있는데 하나씩 알아보자.

 - 스코프에 대해 알아보기 전에, 우선 static이 붙은 변수 및 메소드와 아닌 것의 차이를 확실히 알아야 한다.

__클래스 vs 객체 vs 인스턴스__

static을 좀 더 쉽게 이해하기 위해 3개의 차이를 간단히 보고 넘어가자.

 - 클래스는 간단히 얘기하면 객체를 만들 수 있는 설계도 이다.
 - 객체는 설계도로 구현된 대상을 의미한다.
 - 그 객체가 메모리에 할당되어 실제로 사용되면 그때부턴 인스턴스라고 부른다.

```java
public class Circle { // 클래스
    ...
}

public class Main {
    public static void main(String[] args) {
        Circle circle; // 객체

        circle = new Circle(); // 메모리에 할당되었기 때문에 인스턴스
    }
}
```

참조 : https://gmlwjd9405.github.io/2018/09/17/class-object-instance.html

이제 코드를 살펴보자.
```java
public class VariableScope {
    int globalvariable = 10; // 인스턴스 변수 
    static int staticVariable = 10; // (static)클래스 변수

    public void methodScope(int parameterValue) {
        int localvariable = 10;
    } 

    public static void main(String[] args) {
        int localVariable = 10;
    }
}
```

&nbsp; static 붙은 변수와 메소드는 클래스가 처음 메모리에 로딩될 때 저장된다. 그렇기 때문에 인스턴스를 생성하지 않아도 접근이 가능하다. 

&nbsp; static이 붙은 메소드 또한 마찬가지이다. 하지만 static 메소드안에서는 객체가 생성되어 추가된 인스턴스 변수를 사용할 수 없다. 생각해보면 당연한 부분이다. 데이터가 생성도 되기 전에 사용하는 행위이기 때문이다. 

&nbsp; 반면 일반적인 인스턴스 변수들과 메소드는 static 변수와 메소드 접근이 가능하다. static은 말그대로 그 클래스가 사용하는 공유 자원이기 때문이다. 그렇기 때문에 저장공간 또한 하나이다. 

&nbsp; 이제 추가로 인스턴스 변수와 메소드 변수의 스코프이다. 인스턴스 변수는 클래스 전체에서 사용이 가능하다. parameter를 포함한 메소드 내에 지역 변수들의 스코프는 메소드 블럭내이다.

```java
for () {
    ...
}
while () {
    ...
}
```
&nbsp; loop 내에 선언된 지역 변수들의 스코프는 loop 블럭 내이다.

```java
{
    int a;
}
{
    int a;
}
```
&nbsp; 해당 블럭내에서만 유효하기 때문에 다른 블럭에서는 같은 이름의 지역 변수를 선언해도 컴파일 에러가 나지 않는다! 

#### 5.2 라이프타임

&nbsp; 라이프타임은 말 그대로 메모리에서 살아있는 시간을 말한다.

&nbsp; static 변수인 클래스 변수를 제외한 인스턴스 변수들은 객체가 생성되고 메모리에 살아 있는 동안은 여전히 살아 있다.

&nbsp; 클래스 변수는 클래스가 처음 로딩된 후 프로그램이 끝날 때 까지 살아 있다.

&nbsp; loop나 블럭 내에 있는 지역변수들은 변수 선언 이후 부터 블럭을 벗어날 때 까지 살아 있다.

### 6. 타입 변환, 캐스팅 그리고 타입 프로모션 <정리 후 추가적으로 보충할 예정>

#### 6.1 타입 변환 

&nbsp; 타입을 다른 타입으로 바꾸는 것을 타입 변환이라고 한다. Java의 기본형에서는 boolean 타입을 제외하고는 자유롭게 타입 변환을 할 수 있다.

&nbsp; Java 연산은 피연산자들을 같은 타입으로 만든 후 수행되는 것을 권장한다. 이유는 큰 타입을 작은 타입으로 변호나하면 데이터의 손실을 유발할 수 있기 때문이다.

&nbsp; 타입 변환에는 두 가지 방식이 있다. 

 1. 묵시적 타입 변환
 2. 명시적 타입 변환

&nbsp; 묵시적 타입 변환은 컴파일러가 자동으로 수행해주는 타입 변환이다. Java에서 데이터 손실을 최소화하는 방향으로 묵시적 타입 변환을 진행한다.

&nbsp; 명시적 타입 변환은 더 작은 타입으로 변환할 때 강제적으로 명시하여 타입을 변환해 준다. 데이터 손실을 막을 순 없다.

&nbsp; 레퍼런스 타입을 타입 변환을 하려면 상속 관계여야 한다. 
 1. up casting - 자식 class를 부모 class로 변환하는 것은 자연스럽다.
 2. down casting - 부모 class를 자식 class로 변환하는 것은 부자연 스럽다. 오류 발생 가능성이 늘어난다. 

#### 6.2 타입 프로모션

&nbsp; 크기가 더 작은 자료형을 더 큰 자료형에 대입할 때, 자동으로 작은 자료형이 큰 자료형으로 변환되는 현상. 자동적으로 일어난다.

```java
int a = 20;
double b = a; // 별다른 컴파일 오류를 보이지 않는다.
```

### 7. 1차 및 2차 배열 선언하기

#### 7.1 1차원 배열
```java
int[] arr1 = {1, 1, 1, 1, 1};
```

&nbsp; arr1은 실제 값이 저장되어 있는 메모리의 주소값을 가진다.

#### 7.2 2차원 배열

```java
int[][] arr2 = {{1, 1}, {2, 2}, {3, 3}};
```

&nbsp; arr2는 실제 값이 저장되어 있는 메모리의 주소를 가리키는 배열의 주소를 가지고 있다. 

### 8. 타입 추론, var

#### 8.1 타입 추론

&nbsp; 코드를 작성 당시 타입이 정해지지않고 컴파일러가 그 타입을 유추한다. Java 9 이하에서는 Generic을 사용하였다.

#### 8.2 var

&nbsp; Java 10에서 var라는 Local Variable Type-Inference가 추가되었다. 이 키워드는 local variable 이고, 선언과 동시에 초기화가 이루어져야 한다. 컴파일러가 초기화 값을 보고 타입을 유추하기 때문이다.

```java
String s = "Hello Java9";
var s = "Hello Java10";
```
참고 : https://velog.io/@bk_log/Java-%ED%83%80%EC%9E%85-%EC%B6%94%EB%A1%A0