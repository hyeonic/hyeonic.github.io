{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"작성에 사용된 예제 코드는 testcontainers에서 확인해볼 수 있다. 대부분의 애플리케이션 서비스는 다른 서비스의 의존성을 가지고 운영된다. 간단한 예시로 데이터 저장을 위한 DB, 소셜 로그인을 위한 서버 호출 등을 통해 유기적으로 이루워져 있다.\n즉 하나의 독립적인 서버 환경에서는 원할한 서비스를 운영하는 것은 어려운 일이다.\n이러한 외부 의존…","fields":{"slug":"/testcontainers/"},"frontmatter":{"date":"March 18, 2024","title":"testcontainers","tags":["통합 테스트","testcontainers"]},"rawMarkdownBody":"\n> 작성에 사용된 예제 코드는 [testcontainers](https://github.com/hyeonic/blog-code/tree/main/testcontainers)에서 확인해볼 수 있다.\n\n대부분의 애플리케이션 서비스는 다른 서비스의 의존성을 가지고 운영된다. 간단한 예시로 데이터 저장을 위한 DB, 소셜 로그인을 위한 서버 호출 등을 통해 유기적으로 이루워져 있다.\n즉 하나의 독립적인 서버 환경에서는 원할한 서비스를 운영하는 것은 어려운 일이다.\n이러한 외부 의존성들은 애플리케이션 개발에 많은 편의성을 제공해주지만 우리가 제어할 수 없는 영역이 늘어날수록 통합 테스트에 대한 편의성은 줄어든다.\n\n> 통합 테스트란?\n>\n> 애플리케이션의 모든 구성 요소가 예상대로 작동하는지 확인하는 유형의 테스트이다.\n\n만약 우리가 `RDBMS` 중 하나인 `MySQL`을 활용하여 서비스의 데이터를 관리한다고 가정한다. 통합 테스트를 진행하려면 우리 서비스에 연동된 MySQL에 데이터를 CRUD 할 수 있어야 한다.\n이러한 DB 연동 방법에는 여러가지가 있는데 몇 가지 방법을 추려보았다.\n\n### 실제 운영 중인 DB에 직접 접근하여 통합 테스트\n\n실제 운영 중인 서비스에서 달성할 수 있는 가장 간단한 방법이다. 안정적으로 운영 중인 서버로 DB 드라이버를 연동하고 그대로 테스트 코드를 작성하면 된다.\n다만 이 방식의 가장 큰 단점은 실제 운영 데이터에 통합 테스트 중 발생한 데이터가 섞이게 되는 것이다.\n또한 테스트는 여러 번 수행 되더라도 동일한 결과를 보여줘야 하기 때문에 `멱등성`을 잘 지키는 것이 중요하다.\n\n> 멱등성\n>\n> 수학이나 전산학에서 연산의 한 성질을 나타내는 것으로, 연산을 여러 번 적용하더라도 결과가 달라지지 않는 성질\n\n이 멱등성을 지키기 위해서는 테스트 중 변경된 사항을 찾아 테스트 이전 상태로 바꿔줘야 한다. 이 작업은 DB 모델링에 따라 매우 복잡한 작업이 될 수 있다.\n또한 운영 중인 서비스 데이터에 직접적인 영향이 생길 수 있기 때문에 추천하지 않는 방법이다.\n\n### 임베디드 형태의 DB 활용\n\n일부 DB는 임베디드 형태의 테스트를 제공하기도 한다.\n\n* [h2database](https://github.com/h2database/h2database)\n* [wix-embedded-mysql](https://github.com/wix-incubator/wix-embedded-mysql)\n\n이러한 임베디드 형태의 DB는 스프링 서버와 라이프 사이클을 공유하기 때문에 `멱등성`을 지키기가 쉽다. 단순히 테스트를 진행할 때마다 DB 안에 모든 데이터를 초기화하면 되기 때문이다.\n또한 여러 명이서 한 프로젝트를 진행할 경우 추가적인 설정 없이 바로 서버 실행 및 테스트가 가능 하다는 장점이 있다.\n\n하지만 임베디드 형태의 DB의 경우 DB의 버전 변경에 적절히 대응해야 하지만 실제 DB 서버와는 차이가 있기 때문에 한계가 존재한다.\n실제 서비스에서 운영 중인 DB와 버전, 동작 방식이 다를 수 있기 때문에 실제와 유사한 환경에서 테스트하는데 한계가 있다.\n같은 결과가 나오길 기대 했지만 내부 동작 방식에 대한 차이로 인해 서로 다른 결과가 나올 가능성이 있기 때문이다.\n[wix-embedded-mysql](https://github.com/wix-incubator/wix-embedded-mysql) 문서를 살펴보면 지원이 중단된 것을 확인할 수 있다.\n\n![](./1.png)\n\n### 로컬에서 동일 버전 DB 설치\n\n다음은 로컬 환경에 운영 중인 DB 서버와 동일한 버전을 설치해서 연동하는 것이다. 서버를 직접 설치도 가능하고 도커와 같은 컨테이너 기술을 통해 실행하는 것도 가능하다.\n이 방식의 가장 큰 장점은 실제 운영 DB 서버와 동일한 환경에서 테스트할 수 있다는 것이다. 또한 로컬에서 수행되기 때문에 DB 테이블에 대한 조작을 자유롭게 할 수 있다.\n\n하지만 이에 대한 단점은 해당 프로젝트를 개발하는 모든 팀원이 개별적으로 설치하고 관리해야 한다는 것이다. 그나마 도커 컨테이너를 사용하면 도커 이미지를 통해 이러한 단점을 어느정도 상쇄시킬 수 있다.\n\n![](./2.png)\n\n### testcontainers 활용한 통합 테스트 환경 구성\n\n[testcontainers](https://testcontainers.com/)는 테스트 환경을 도커 컨테이너로 제공하는 라이브러리이다. 데이터베이스, 웹 서버, 카프카 등\n다양한 종류의 컨테이너를 코드 레벨에서 제공해준다. 이러한 컨테이너는 테스트를 실행하는 동안 초기화되고, 완료되면 자동으로 제거된다.\n즉 테스트 진행과 동일한 라이프사이클을 가지고 동작한다. 이를 통해 테스트 환경의 일관성을 유지하여 멱등성을 잘 지킬 수 있도록 도와준다.\n\n![](./3.png)\n\n간단한 예시 작성을 위해 아래와 같은 환경에서 진행하였다.\n\n* Spring Boot 3.2.2\n* Java 17\n* Testcontainers\n* Spring Data JPA\n* MySQL Driver\n* Spring Web\n\n![](./4.png)\n\n아래는 프로젝트 생성 이후 `build.gradle.kts` 파일을 가져온 것이다.\n\n```kotlin\nimport org.jetbrains.kotlin.gradle.tasks.KotlinCompile\n\nplugins {\n    id(\"org.springframework.boot\") version \"3.2.2\"\n    id(\"io.spring.dependency-management\") version \"1.1.4\"\n    kotlin(\"jvm\") version \"1.9.22\"\n    kotlin(\"plugin.spring\") version \"1.9.22\"\n    kotlin(\"plugin.jpa\") version \"1.9.22\"\n}\n\ngroup = \"c.hyeoni\"\nversion = \"0.0.1-SNAPSHOT\"\n\njava {\n    sourceCompatibility = JavaVersion.VERSION_17\n}\n\nrepositories {\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"org.springframework.boot:spring-boot-starter-data-jpa\")\n    implementation(\"org.springframework.boot:spring-boot-starter-web\")\n    implementation(\"com.fasterxml.jackson.module:jackson-module-kotlin\")\n    implementation(\"org.jetbrains.kotlin:kotlin-reflect\")\n\n    runtimeOnly(\"com.mysql:mysql-connector-j\")\n\n    testImplementation(\"org.springframework.boot:spring-boot-starter-test\")\n    testImplementation(\"org.springframework.boot:spring-boot-testcontainers\")\n    testImplementation(\"org.testcontainers:mysql\")\n    testImplementation(\"org.testcontainers:junit-jupiter\")\n}\n\ntasks.withType<KotlinCompile> {\n    kotlinOptions {\n        freeCompilerArgs += \"-Xjsr305=strict\"\n        jvmTarget = \"17\"\n    }\n}\n\nallOpen {\n    annotation(\"jakarta.persistence.Entity\")\n    annotation(\"jakarta.persistence.Embeddable\")\n    annotation(\"jakarta.persistence.MappedSuperclass\")\n}\n\ntasks.withType<Test> {\n    useJUnitPlatform()\n}\n```\n\n`Spring Boot`에서 `testcontainers`의 대한 지속적인 지원으로 편리하게 의존성을 추가하여 진행할 수 있다.\n특히 `Spring Boot 3.1` 이후 버전 부터는 `testcontainers`에 대한 지원이 더욱 향상되어 간단한 애노테이션 추가만으로 서버 구성이 가능해졌다.\n\n이제 통합 테스트를 진행하기 위해 MySQL 서버에 대한 세팅을 진행한다.\n\n```kotlin\n@ActiveProfiles(\"testcontainers\")\n@TestConfiguration(proxyBeanMethods = false)\nclass ContainersConfig {\n\n    @Bean\n    @ServiceConnection\n    fun mysqlContainer(): MySQLContainer<*> {\n        return MySQLContainer(DockerImageName.parse(\"mysql:latest\"))\n            .withDatabaseName(\"test-example\")\n            .withUsername(\"test\")\n            .withPassword(\"test\")\n            .withReuse(true)\n    }\n}\n\nfun main(args: Array<String>) {\n    fromApplication<TestcontainersApplication>()\n        .with(ContainersConfig::class)\n        .run(*args)\n}\n```\n\n이제 익숙하지 않은 몇 가지 설정을 살펴본다.\n\n* `@ActiveProfiles(\"testcontainers\")`: `testcontainers`와 관련된 설정을 모아두기 위해 `profile`을 분리하여 지정하였다.\n* `@ServiceConnection`: 해당 설정을 통해 `@Bean` 메서드에 컨테이너에서 실행 중인 서비스에 대한 연결을 자동으로 설정하도록 도와준다. 해당 애노테이션 덕분에 더욱 편리하게 설정이 가능해졌다.\n* `MySQLContainer`: 도커 이미지를 활용하여 `MySQL`을 손쉽게 조작하기 위한 용도이다. DB 접근을 위한 다양한 설정 정보를 기입할 수 있다.\n\n참고로 `testcontainers profile` 설정 정보는 아래와 같다.\n\n```yaml\nspring:\n  config:\n    activate:\n      on-profile: testcontainers\n\n  jpa:\n    open-in-view: false\n    hibernate:\n      ddl-auto: create-drop\n    properties:\n      hibernate:\n        format_sql: true\n    show-sql: true\n```\n\n이제 테스트를 위한 준비는 모두 마무리 되었다. 간단하게 해당 컨테이너를 활용하여 통합 테스트를 작성해본다.\n\n아래는 특정 멤버를 관리하기 위한 `Member Entity`이다. 간단한 검증을 위해 `id`, `name` 프로퍼티만을 가지고 있다.\n\n```kotlin\n@Entity\nclass Member(\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    var id: Long = 0L,\n    var name: String\n)\n```\n\n```kotlin\ninterface MemberRepository : JpaRepository<Member, Long>\n```\n\n`@DataJpaTest`를 활용하여 `Repository`에 대한 슬라이스 테스트를 진행한다. 간단히 `member`를 생성해본다.\n\n```kotlin\n@DataJpaTest\n@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)\n@Import(ContainersConfig::class)\n@ActiveProfiles(\"testcontainers\")\nclass MemberRepositoryIntegrationTest {\n\n    @Autowired\n    private lateinit var memberRepository: MemberRepository\n\n    @Test\n    fun saveTest() {\n        val member = Member(name = \"hyeonic\")\n\n        assertThatCode { memberRepository.save(member) }.doesNotThrowAnyException()\n    }\n}\n```\n\n* `@DataJpaTest`: JPA와 관련된 요소만 빈으로 등록한다.\n* `@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)`: `@DataJpaTest`를 사용하면 별도 설정 없이 자체적으로\n  생성된 임베디드 DB를 활용한다. 하지만 우리는 실제 도커 컨테이너에서 동작하는 MySQL에 접근하여 테스트해야 하므로 해당 설정을 변경한다.\n* `@Import(ContainersConfig::class)`: 별도 설정한 `Config`를 import한다. 앞서 언급한 것 처럼 `@DataJpaTest`는 JPA와 관련된 EntityManager,\n  Repository 등만 빈 등록 대상으로 활용한다.\n* `@ActiveProfiles(\"testcontainers\")`: 앞서 작성한 `application-testcontainers.yml`에 명시한 설정을 사용하기 위한 목적이다.\n\n`testcontainers`는 도커 컨테이너를 활용하여 테스트 환경을 구성한다. `도커 데스크탑`을 활용하여 `testcontainers`가 어떻게 MySQL 컨테이너를 활용하는지 확인해본다.\n\n![](./5.png)\n\n요상한 이름을 가진 두 개의 컨테이너가 자동으로 실행된 것을 확인할 수 있다. `mysql:latest`는 MySQL 컨테이너인 것을 알겠는데 `testcontainers/ryuk`은 무엇일까?\n\n`ryuk`의 주요 역할은 테스트가 완료된 후에 사용된 모든 리소스를 자동으로 정리한다. `ryuk`는 `testcontainers`가 시작될 때 함께 실행되며(예시에서는 테스트가 수행될\n때), `testcontainers`와 함께 생성된 모든 것들을 관리한다. 테스트 종료되면, `ryuk`는 해당 정보를 바탕으로 생성된 모든 리소스를 안전하게 정리하고 삭제한다.\n\n테스트가 완료된 후 도커 데스크탑을 확인해보면 깔끔하게 정리된 것을 확인할 수 있을 것이다. 물론 테스트도 성공한다!\n\n![](./6.png)\n\n## 마무리\n\n지금까지 `testcontainers`를 활용하여 통합 테스트 환경을 구축하는 방법에 대해 알아보았다. 해당 기술을 활용하면 실제 운영 중인 데이터베이스에 접근하지 않고도, 업데이트가 원할하게 되지 않는 임베디드\n데이터베이스를 활용하기 않고도 운영 환경과 동일하게 세팅하여 멱등성을 지키며 원할하게 테스트를 진행할 수 있다. 데이터베이스 뿐만 아니라 실제 연동하고 있는 웹 서버, 카프카 등에 대한 테스트도 도커 컨테이너를\n활용하여 별다른 서버 세팅 없이 편리하게 진행할 수 있다.\n\n다만 도커 컨테이너를 활용할 수 없거나 도커 레지스트리에 접근이 제한되는 환경인 경우 이미지를 원할하게 사용하지 못할 수 있다. 결국 사용하고자 하는 이미지가 접근 가능한 형태로 제공 되어야 한다는\n것이다. 결국 `testcontainers`는 도커라는 의존성을 활용한 테스트임을 인지하여야 한다.\n\n## References.\n\n* [멱등법칙](https://ko.wikipedia.org/wiki/%EB%A9%B1%EB%93%B1%EB%B2%95%EC%B9%99)\n* [improved-testcontainers-support-in-spring-boot-3-1](https://spring.io/blog/2023/06/23/improved-testcontainers-support-in-spring-boot-3-1)\n"},{"excerpt":"Spring Data JPA Auditing 작성에 사용된 예제 코드는 jpa-auditing에서 확인해볼 수 있다. 언어는 kotlin으로 작성하였다. Spring Data는 엔티티를 하거나 과 를 투명하게 추적할 수 있는 정교한 지원을 제공한다.\n해당 기능을 사용하기 위해서는 애노테이션을 사용하거나 인터페이스를 구현하여 정의할 수 있는 auditing…","fields":{"slug":"/jpa-auditing/"},"frontmatter":{"date":"March 08, 2023","title":"Spring Data JPA Auditing","tags":["kotlin","jpa","auditing"]},"rawMarkdownBody":"\n## Spring Data JPA Auditing\n\n> 작성에 사용된 예제 코드는 [jpa-auditing](https://github.com/hyeonic/blog-code/tree/main/jpa-auditing)에서 확인해볼 수 있다. 언어는 kotlin으로 작성하였다.\n\nSpring Data는 엔티티를 `생성`하거나 `변경한 사람`과 `변경이 발생한 시기`를 투명하게 추적할 수 있는 정교한 지원을 제공한다.\n해당 기능을 사용하기 위해서는 애노테이션을 사용하거나 인터페이스를 구현하여 정의할 수 있는 auditing metadata를 제공해야 한다.\n\n아래는 간단한 예시를 위한 Member 엔티티이다.\n\n```kotlin\n@Entity\nclass Member(\n    name: String\n) : BaseEntity() {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    var id: Long? = null\n        protected set\n\n    @Column\n    var name: String = name\n        protected set\n}\n```\n\n사용 방법은 정말 간단하다. 애노테이션만 몇 개 추가해주면 자동으로 생성과 수정 시점에 따라 값이 수정된다.\n\n```kotlin\n@EntityListeners(AuditingEntityListener::class)\n@Entity\nclass Member(\n    name: String\n) : BaseEntity() {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    var id: Long? = null\n        protected set\n\n    @Column\n    var name: String = name\n        protected set\n\n    @CreatedDate\n    @Column(nullable = false, updatable = false)\n    var createdDate: LocalDateTime = LocalDateTime.MIN\n        protected set\n\n    @LastModifiedDate\n    @Column(nullable = false)\n    var lastModifiedDate: LocalDateTime = LocalDateTime.MIN\n        protected set\n\n    @CreatedBy\n    @Column(nullable = false, updatable = false)\n    var createdBy: String = DEFAULT_MEMBER_NAME\n        protected set\n\n    @LastModifiedBy\n    @Column(nullable = false)\n    var lastModifiedBy: String = DEFAULT_MEMBER_NAME\n        protected set\n\n    companion object {\n        const val DEFAULT_MEMBER_NAME = \"default\"\n    }\n}\n```\n\n> 이번 글에서는 Auditing 기능에만 집중할 예정이므로 Kotlin과 JPA와 관련한 내용은 생략한다.\n\n* `@EntityListeners(AuditingEntityListener::class)`: Spring Data JPA는 auditing 정보 캡처를 트리거할 때 사용할 수 있는 `EntityListener`와\n  함께 제공된다. 사용할 엔티티에 `AuditingEntityListener`를 등록한다. 자세한 동작과정은 이후 살펴본다. 우선 auditing 기능을 위해서는 리스너를 등록해야 한다는 것만 알아두자.\n* `@CreatedDate`: 엔티티가 생성되어 저장될 때 시간이 자동으로 저장된다.\n* `@LastModifiedDate`: 엔티티가 변경되면 시간이 자동으로 수정된다.\n* `@CreatedBy`: 엔티티를 생성한 사람을 자동으로 넣을 수 있다. 해당 기능이 정상 작동하기 위해서는 `AuditorAware`를 빈으로 등록해야 한다. 자세한 사용 방법은 이후 살펴본다.\n* `@LastModifiedDate`: 엔티티가 변경되면 변경한 사람이 자동으로 수정된다. 정상 작동 방법은 `@CreatedBy`와 동일하게 이후 작성한다.\n\n엔티티마다 Auditing 기능을 위해 `createdDate`, `lastModifiedDate` 등을 매번 작성하는 것은 중복된 코드를 야기한다. 이것은 상속을 통해 개선이 가능하다.\n\n```kotlin\n@MappedSuperclass\n@EntityListeners(AuditingEntityListener::class)\nclass BaseEntity {\n\n    @CreatedDate\n    @Column(nullable = false, updatable = false)\n    var createdDate: LocalDateTime = LocalDateTime.MIN\n        protected set\n\n    @LastModifiedDate\n    @Column(nullable = false)\n    var lastModifiedDate: LocalDateTime = LocalDateTime.MIN\n        protected set\n\n    @CreatedBy\n    @Column(nullable = false, updatable = false)\n    var createdBy: String = DEFAULT_MEMBER_NAME\n        protected set\n\n    @LastModifiedBy\n    @Column(nullable = false)\n    var lastModifiedBy: String = DEFAULT_MEMBER_NAME\n        protected set\n\n    companion object {\n        const val DEFAULT_MEMBER_NAME = \"default\"\n    }\n}\n```\n\n```kotlin\n@Entity\nclass Member(\n    name: String\n) : BaseEntity() {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    var id: Long? = null\n        protected set\n\n    @Column\n    var name: String = name\n        protected set\n}\n```\n\n`BaseEntity()`를 상속하여 Member 엔티티가 더욱 간단해진 것을 확인할 수 있다. 이제 마지막으로 Auditing 기능을 활성화해준다.\n\n```kotlin\n@Configuration\n@EnableJpaAuditing\nclass JpaConfig\n```\n\n보통 Configuration 파일은 각 역할에 맞게 분리하여 관리한다. 이러한 방식의 장점은 슬라이스 테스트를 진행할 때 필요한 설정 빈만 활용하여 테스트를 진행할 수 있다. 자세한\n이유는 [8.3.33. User Configuration and Slicing](https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.testing.spring-boot-applications.user-configuration-and-slicing)\n에서 확인할 수 있다.\n\n아래는 간단한 repository와 service이다.\n\n**MemberRepository.kt**\n\n```kotlin\ninterface MemberRepository : JpaRepository<Member, Long>\n```\n\n**MemberService.kt**\n\n```kotlin\n@Service\nclass MemberService(\n    private val memberRepository: MemberRepository\n) {\n\n    @Transactional\n    fun save(member: Member): Member {\n        return memberRepository.save(member)\n    }\n}\n```\n\n간단한 테스트 코드를 작성한다.\n\n```kotlin\n@SpringBootTest\nclass MemberServiceTest @Autowired constructor(\n    private val memberService: MemberService\n) {\n\n    @Test\n    fun `member를 저장한다`() {\n        val name = \"hyeoni\"\n        val savedMember = memberService.save(Member(name))\n\n        val result = memberService.getOne(savedMember.id!!)\n\n        println(result)\n    }\n}\n```\n\n```console\nMember(id=1, name=hyeoni, createdDate=2023-03-06T22:21:16.911, lastModifiedDate=2023-03-06T22:21:16.911, createdBy='default', lastModifiedBy='default')\n```\n\n`createdDate`와 `updatedDate`를 살펴보면 테스트 시작 시간이 잘 등록된 것을 확인할 수 있다. 추가로 `createdBy`와 `lastModifiedBy`에는 생성 및 수정이 일어날 때\nmember의 name이 기록해야 하는 요구사항이 있다고 가정한다. 현재는 무슨 이유인지 모르겠지만 `Member Entity`에 기본적으로 설정된 값이 출력되는 것을 확인할 수 있다.\n\n```kotlin\n@SpringBootTest\nclass MemberServiceTest @Autowired constructor(\n    private val memberService: MemberService\n) {\n\n    @Test\n    fun `member를 저장한다 createdBy와 lastModifiedBy는 member의 name과 같다`() {\n        val name = \"hyeoni\"\n        val savedMember = memberService.save(Member(name))\n\n        val result = memberService.getOne(savedMember.id!!)\n\n        assertAll(\n            { assertThat(result.createdBy).isEqualTo(name) },\n            { assertThat(result.lastModifiedBy).isEqualTo(name) }\n        )\n    }\n}\n```\n\n![](./0.png)\n\n위 테스트는 실패한다. 가정한 요구사항을 수행하기 위해서는 추가적인 설정이 필요하다.\n\n## AuditorAware\n\n이것은 `AuditorAware`의 구현체를 `Bean`으로 등록하여 해결할 수 있다. 요구사항에 맞춰 해당 채워 넣을 값을 세팅한다. 보통은 `Spring Security`의 `Authentication`\n이나 `Session` 등 을 활용하여 구현하곤 한다. 아래는 실제 공식 문서에 있는 간단한 활용 예시이다.\n\n```java\nclass SpringSecurityAuditorAware implements AuditorAware<User> {\n\n    @Override\n    public Optional<User> getCurrentAuditor() {\n        return Optional.ofNullable(SecurityContextHolder.getContext())\n                .map(SecurityContext::getAuthentication)\n                .filter(Authentication::isAuthenticated)\n                .map(Authentication::getPrincipal)\n                .map(User.class::cast);\n    }\n}\n```\n\n간단한 예제를 위해 스레드별로 요청한 Member의 name을 저장하기 위해 `ThreadLocal`를 가진 `RequestContext`을 활용한다.\n\n```kotlin\nclass RequestContext {\n\n    companion object {\n        private val currentAuditorStore = ThreadLocal<String?>()\n\n        var currentAuditor: String\n            get() = currentAuditorStore.get() ?: \"default\"\n            set(currentAuditor) {\n                currentAuditorStore.remove()\n                return currentAuditorStore.set(currentAuditor)\n            }\n    }\n}\n```\n\n정말 간단한 예시이다. 자 이제 service 쪽도 저장하기 직전에 `RequestContext`에 값을 채워둔다.\n\n```kotlin\n@Service\n@Transactional(readOnly = true)\nclass MemberService(\n    private val memberRepository: MemberRepository\n) {\n\n    @Transactional\n    fun save(member: Member): Member {\n        RequestContext.currentAuditor = member.name\n        return memberRepository.save(member)\n    }\n}\n```\n\n이제 `RequestContext`에 저장된 `name`을 활용하여 `AuditorAware`를 구현하고 빈으로 등록한다.\n\n```kotlin\n@Configuration\nclass JpaConfig {\n\n    @Bean\n    fun auditorProvider(): AuditorAware<String> {\n        return AuditorAware {\n            Optional.of(RequestContext.currentAuditor)\n        }\n    }\n}\n```\n\n자 이제 아래 테스트를 다시 수행한다.\n\n```kotlin\n@SpringBootTest\nclass MemberServiceTest @Autowired constructor(\n    private val memberService: MemberService\n) {\n\n    @Test\n    fun `member를 저장한다 createdBy와 lastModifiedBy는 member의 name과 같다`() {\n        val name = \"hyeoni\"\n        val savedMember = memberService.save(Member(name))\n\n        val result = memberService.getOne(savedMember.id!!)\n\n        assertAll(\n            { assertThat(result.createdBy).isEqualTo(name) },\n            { assertThat(result.lastModifiedBy).isEqualTo(name) }\n        )\n    }\n}\n```\n\n![](./1.png)\n\n정상적으로 통과하는 것을 확인할 수 있다.\n\n## [번외] AuditingEntityListener\n\nAuditing 기능이 정상적으로 동작하기 위해서는 `@EntityListeners(AuditingEntityListener::class)`를 통해 리스너를 등록해야 한다. 엔티티의 메서드는 특정 엔티티 라이프\n사이클 이벤트의 알림을 수신하기 위한 콜백 메서드(e.g. `@PrePersist` 등)로 지정될 수 있다. 다만 클래스 단위로 범용적인 사이클 적용을 위해서는 리스너를 활용할 수 있다.\n\n실제 `AuditingEntitiyListener`를 살펴보자.\n\n```java\n\n@Configurable\npublic class AuditingEntityListener {\n    // ...\n    @PrePersist\n    public void touchForCreate(Object target) {\n        Assert.notNull(target, \"Entity must not be null!\");\n        if (handler != null) {\n            AuditingHandler object = handler.getObject();\n            if (object != null) {\n                object.markCreated(target);\n            }\n        }\n    }\n\n    @PreUpdate\n    public void touchForUpdate(Object target) {\n        Assert.notNull(target, \"Entity must not be null!\");\n        if (handler != null) {\n            AuditingHandler object = handler.getObject();\n            if (object != null) {\n                object.markModified(target);\n            }\n        }\n    }\n}\n```\n\n특정 시점에 `@PrePersist`와 `@PreUpdate`애노테이션이 명시된 메서드를 수행하는 것을 확인할 수 있다.\n\n## 정리\n\n지금까지 JPA Auditing 필요성과 사용 방법에 대해 알아보았다. 날짜와 관련한 필드는 `@CreatedDate`와 `@LastModifiedDate` 애노테이션을 통해 정말 빠르게 적용이 가능하다.\n다만 `@CreatedBy`와 `@LastModifiedBy`는 추가적으로 `AditorAware`를 빈으로 등록해야 한다.\n\n엔티티의 라이프 사이클 이벤트 알림을 수신하기 위한 애노테이션을 사용할 수 있다. 여러 엔티티에서 사용하는 것은 리스너를 생성하여 `@EntityListeners`에 등록한 뒤 사용할 수 있다.\n\n## References.\n\n* [5.1.9. Auditing](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#auditing)<br>\n* [Chapter 6. Entity listeners and Callback methods](https://docs.jboss.org/hibernate/stable/entitymanager/reference/en/html/listeners.html)<br>\n"},{"excerpt":"2022년은 내게 조금은 특별한 해이다. 단순히 기술적인 성장을 넘어 한 사람으로서의 가치관을 형성할 수 있었던 시기였다. 회고를 통해 지난 1년을 뒤돌아보며 점검할 수 있는 회고를 적어보려 한다. 우아한테크코스 2022년의 시작은 대부분의 시간을 할애한 우테코를 빼놓고 이야기할 수 없을 것 같다. 정말 하고 싶었던 교육이었기 때문에 2021년은 대부분의…","fields":{"slug":"/2022-retrospect/"},"frontmatter":{"date":"January 12, 2023","title":"조금 늦은 2022년 회고","tags":["회고"]},"rawMarkdownBody":"\n2022년은 내게 조금은 특별한 해이다. 단순히 기술적인 성장을 넘어 한 사람으로서의 가치관을 형성할 수 있었던 시기였다. 회고를 통해 지난 1년을 뒤돌아보며 점검할 수 있는 회고를 적어보려 한다.\n\n## 우아한테크코스\n\n2022년의 시작은 대부분의 시간을 할애한 우테코를 빼놓고 이야기할 수 없을 것 같다. 정말 하고 싶었던 교육이었기 때문에 2021년은 대부분의 시간을 개발자로의 성장보다 우테코에 지원하기 위한 기반을 다지는 시간이 대부분이었던 것 같다. 당장 내가 몰입하고 있다는 것을 증명해야 했기 때문에 깃허브와 블로그 관리에 큰 노력을 쏟았던 것 같다.\n\n![](./1.png)\n\n정말 운이 좋게 내가 했던 노력과 방향성이 우테코와 잘 맞아떨어져서 합격하게 되었다. 2022년은 시작이 좋다고 생각했다. 시작하는 2월까지는 정말 기쁜 마음으로 열심히 놀았다. 10개월을 지속해서 몰입해야 했기 때문에 마지막으로 놀 수 있는 순간이라고 생각했던 것 같다. 부끄럽게도 합격 이후부터 시작하기 전까지 내 커밋 그래프는 텅 비어있다.\n\n![](./2.png)\n\n## 지식을 재정립하는 시간들\n\n나는 전역 이후 비교적 이른 시기에 웹 백엔드 개발자의 진로를 결정했다. 정말 우연히 많고 많은 언어와 프레임워크 중에 java와 spring을 선택했다. 이러한 선택들로 우아한테크코스 시작 이전 부터 java와 spring에 대한 지식들을 꾸준히 쌓고 있었다. 물론 강의를 따라 했던 수준이지만 언어에 대한 사용법 정도는 알고 있었다.\n\n우테코 기간은 대부분의 시간을 기존에 알고 있던 지식을 다시 재정립하는 시간이었다. 단순히 알고 사용하는 것을 넘어 왜 등장했고, 어떠한 원리로 동작하는 지 등 원론적인 고민을 주로 했던 것 같다. 단순히 이야기하면 내가 작성한 코드에 근거를 만들기 위해 끊임없이 고민했다.\n\n가장 좋았던 것은 미션 위주의 코드 리뷰를 통한 방식을 꼽을 수 있을 것 같다. 누군가에게 내 코드를 리뷰 받는 다는 것은 굉장히 부끄러웠다. 하지만 실제 현업에 계신 분들이 직접 해주신다는 것을 듣고 굉장히 기대가 되었다. 더 좋았던 것은 단순히 정답을 알려주기보다 나의 의견을 먼저 물어 자연스럽게 내가 작성한 코드의 근거를 이끌어주셨다. \n\n![](./2022-restrospect/3.png)\n\n우테코는 가고자 하는 길을 잃어 방황하던 시절 적절한 타이밍에 길을 안내 해줄 나침반 같았다. 근거 없이 닥치는 대로 공부하던 과거와는 달리 항상 배움에는 근거가 있었고, 그 근거를 나눌 수 있는 환경을 만난 것이다. 그렇기에 2022년은 더욱 특별하게 기억되고 있다.\n\n## 몰아치는 새로운 인연들\n\n코로나 이후 대학도 대부분 비대면으로 진행했기 때문에 사람들과 대화하고 소통하는 기회가 많지 않았다. 특히 전역 이후 대부분의 아는 사람들과 지냈기 때문에 새로운 인연을 만들 기회가 많지 않았다. 그렇기 때문에 교육 초반 레벨 1 브리조, 연극, 페어 등 계속해서 새로운 사람들과 대화하는 자리가 끊임없이 이어져서 조금은 힘들었다. 아마 이때가 우테코 기간 중 가장 힘들었던 시기가 아니었나 싶다. 물론 사람 때문에 힘든 것이 아니라 그냥 오랜만에 이런 환경에 던져진 것이 익숙하지 않았다. 나는 이것을 극복하는 것이 올해의 가장 큰 목표로 자리 잡게 되었다.\n\n특히 불특정 다수 앞에서 이야기하는 것이 굉장히 두려웠기 때문에 이것을 가장 먼저 극복하고 싶었다. 우테코를 수료하기 위해서는 교육 기간 중 무조건 테코톡을 진행해야 했기 때문에 나에겐 많은 연습이 필요했다.\n\n가장 먼저 시도한 것은 토론회를 주최한 것이다. 또 누군가에게 찰떡같은 이름 까지 추천 받아 약 두 달간 [아고라](https://hyeonic.github.io/about/#%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8C%E1%85%A1%E1%84%83%E1%85%B3%E1%86%AF%E1%84%8B%E1%85%B4-%E1%84%8B%E1%85%B2%E1%84%8F%E1%85%AB%E1%84%87%E1%85%A1%E1%86%AF%E1%84%85%E1%85%A1%E1%86%AF-%E1%84%90%E1%85%A9%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%AC-%E1%84%8B%E1%85%A1%E1%84%80%E1%85%A9%E1%84%85%E1%85%A1)를 진행할 수 있었다. 다양한 주제에 대해 많은 이야기를 나눌 수 있었고, 이를 통해 내가 가진 지식이 결코 정답이 아님을 다시 한번 깨닫게 되었다. \n\n무엇보다 가장 크게 도움 된 것은 **내가 가진 생각을 잘 정돈해서 전달할 수 있는 역량**이다. 지금도 완벽한 것은 아니지만 어느 정도 두려움을 극복한 것 같다.\n\n![](./4.png)\n\n항상 찾아와서 함께 의견을 나눠준 크루들에게 고마웠다. 사실 남에게 자신의 시간을 할애하여 의견을 나누는 것은 쉽지 않은 일이라 생각된다. 그런데도 항상 찾아와 참여한 크루들과 먼저 나서서 발표를 준비해준 많은 크루들에게 감사한 마음을 가지고 있다.\n\n![](./5.png)\n\n우테코가 끝날쯤에는 한 크루가 토론 형식에서 세미나 형식으로 변경하여 운영해보는 것은 어떤지 제안했다. 급하게 진행되었지만 많은 크루들의 도움으로 잘 마무리할 수 있었다. 매주 진행할 때마다 생각보다 많은 크루들이 참여해줘서 굉장히 기쁘고 고마웠던 기억이 남는다. 어쩌면 쉽게 하지 못할 경험을 정말 많이 하고 떠난 것 같아서 굉장히 뿌듯한 시간이었다. 이번 회고를 통해 다시 한번 **감사한 마음을 전달**하고 싶다.\n\n## 협업에 임하는 자세\n\n2021년, 처음 진행했던 팀 프로젝트와 협업은 정말 미숙했다. 누군가와 의견을 나누며 함께 코드를 작성하는 것도 어려웠고, 별다른 근거도 없지만 그냥 내 의견을 강하게 주입하기도 했다. 또한 높은 목표 때문에 팀원들을 강하게 몰아치기도 했다. 물론 팀원과의 사이가 나쁜 것은 아니었지만(지금도 가끔 연락하면서 잘 지내고 있다) 지금 생각해보면 썩 좋은 팀원은 아닌 것 같아 미안한 감정이 크게 다가온다. 그렇기 때문에 2022년에 내가 만나는 페어와 팀원들을 위해 협업에 임하는 자세를 개선하고 싶었다.\n\n최대한 상대방의 의견을 잘 이끌어내기 위해 노력했다. 페어 혹은 팀원과 함께 액션 플랜을 세우고 그것을 달성하기 위해 노력했다. 혹여나 이전처럼 행동하지 않을지 우려되어 매일 회고도 진행했다. 형식적인 회고도 의식적으로 연습하다 보면 자연스럽게 솔직함을 표현하는 나를 발견할 수 있었다. 1년 전의 나를 생각하면 항상 포장하기 급급했는데, 정말 많은 부분이 바뀐 것을 실감할 수 있었다.\n\n운이 좋게도 페어로 매칭된 크루들과 달록 팀원들은 내가 하고자 한 것들을 대부분 실현할 수 있도록 도와주었다. 기술적으로는 특정 문제에 대해 다양한 이야기를 나눌 수 있어서 좋았다. 내가 가진 의견을 전달하기 위해 근거를 고민하는 시간도 좋았다. 특히 협업에 대한 가치관이 정말 많이 바뀌었다. 형식적인 대화를 나누며 코드를 선택하는 것이 아니라 함께 하는 사람과 지식을 치열하게 나누며 적절한 조화를 이룰 방법을 고민했다. 또한 내가 가진 지식이 잘못된 것일까 두려워 질문을 꺼리던 행동들과 대충 알고 있지만 어물쩍 넘어가는 등 안 좋던 습관들을 마주할 수 있었고, 의식적으로 고치기 위해 노력했다. 내게 페어와 팀 프로젝트는 **단순히 무언가를 함께 하는 것을 넘어 내가 가진 단점들을 마주하고 개선할 수 있는 기회**를 마련해주었다.\n\n![](./6.png)\n\n특히 달록 팀원들에게 항상 고마운 마음이 크다. 서로에 대한 장점과 개선점을 편하게 나눌 수 있는 환경도 좋았고, 그것을 빠르게 극복하기 위해 노력하는 부분들도 느껴졌기 때문에 프로젝트 기간 개발자로서의 성장과 나에 대한 성장을 함께 이룰 수 있었다. 당연히 안 맞는 부분도 있었다. 우연한 기회로 서로 다른 가치관을 가진 6명의 사람이 만났는데, 성향이 맞지 않는 것은 어찌 보면 당연한 일이다. 그럼에도 **서로가 안 맞는 부분은 우리가 함께 감당할 수 있는 부분**이기 때문에 더욱 특별하게 다가왔다.\n\n## 나를 있는 그대로 바라보기\n\n지금까지 항상 타인에게 비춰진 나를 고민하며 살아왔다. 특정 행동을 했을 때 나의 기분보다 타인의 기분을 먼저 신경 쓰곤 했다. 이런 성격 때문에 정작 내가 무엇을 할 때 행복하고, 무엇을 할 때 몰입하는지 알지 못했다. 정확히는 내 감정을 숨긴 채 외면하곤 했다.\n\n취업을 위해 인성 면접을 준비하는데 질문에 대한 답변을 포장하기 급급했다. 당연히 내가 가진 약점을 숨기는 것은 중요하지만 나라는 사람의 본질마저 숨긴 채 그저 그런 특색 없는 사람으로 만들어버린다. 내가 무엇을 할 때 가장 몰입하는지, 어떤 성향인 사람과 일을 할 때 더욱 좋은 시너지가 나오는 지 등은 중요하지 않고 그냥 좋은 사람처럼 비춰지도록 나를 설명했다. 결국 나는 어디에나 한 명쯤 존재하는 무색무취의 사람처럼 느껴졌다.\n\n한 크루의 조언으로 단순히 질문에 대한 답변을 작성하기보다 진짜 했던 경험과 느꼈던 감정들을 잘 나열해보라는 조언을 들을 수 있었다. 적다 보니 생각 보다 많은 경험을 했던 것을 그제야 알 수 있었고, 내가 무엇을 할 때 행복한지 고민해보는 시간도 가질 수 있었다. 나름 개성도 가지고 있더라. 내가 가진 지식을 공유할 때 행복한 나를 발견할 수 있었다. 단순히 공유를 넘어 다양한 이야기를 통해 내가 가진 근거를 구체화하는 과정이 너무 재밌게 느껴졌다. 그렇게 나는 **무언가를 나누며 함께 자라는 것을 좋아하는, 항상 배움에 목말라 있는 개발자**가 되었다.\n\n## 아쉬운 점\n\n가장 아쉬운 점은 우테코 후반에 끊임없이 이어지는 면접 일정으로 깊이 있는 공부를 많이 하지 못한 것이 가장 아쉽다. 단순히 문제와 정답을 외우기 위해 노력했기 때문에 금방 휘발되는 지식으로 남았다. 매주 꾸준하게 작성하던 블로그 글도 점차 주기가 길어졌다. 주기만 길어지면 다행이지, 퀄리티까지 떨어지는 것이 느껴졌다. 올해에는 좀 더 진득하게 잘 정돈된 글을 작성하고 싶다는 생각이 들었다.\n\n그 다음은 술을 너무 많이 마신 것이다. 오랜만에 오프라인 환경에서 다양한 사람들을 만나니 자연스럽게 술자리가 늘었다. 워낙에 술을 좋아하기도 하고, 사람들과 어울리는 것을 좋아하는 성격 탓에 정말 많은 술을 마셨다. 때문에 건강과 돈을 잃었지만 좋은 인연들을 만들어서 큰 후회는 없다. 다만 올 한해는 술을 취하려고 먹기보다 즐기면서 먹는 방법을 찾아보고 싶다. \n\n마지막은 운동이다. 원래도 운동을 썩 좋아하는 편은 아니었지만 그래도 전역 이후 꾸준히 즐겨왔다. 취준을 시작한 이후로 바쁘다는, 관리 포인트를 줄인다는 이유로 운동을 등한시했다. 결국 늘어가는 건 내 뱃살뿐이었다. 올해에는 내가 좋아하는 운동을 찾고 꾸준히 지속해보고 싶다. 미뤄둔 다이어트도 다시 시작해봐야겠다. \n\n## 올해의 계획\n\n2022년은 기술적인 성장과 함께 앞으로 어떤 개발자가 되고 싶은지 많이 고민할 수 있는 한해였다. 올해부터는 이제 내가 세운 장기적인 목표를 위해 시작하는 첫걸음과 같다.\n\n**회사에 잘 적응하고 기여하기**\n\n먼저 올해부터 몸담게 되는 회사에서 여러가지 기여를 하고 싶다. 10개월간 배웠던 다양한 지식과 소통 능력을 바탕으로 빠르게 적응하여 기여하는 것이 가장 큰 목표이다.\n\n**2022년 동안 했던 우테코 활동 리마인드**\n\n지난 10개월 동안 너무나 다양한 지식을 빠르게 훓고 지나갔다. 놓친 것은 없는지 차근차근 정리하며 내 것으로 만드는 시간이 필요하다.\n\n**매달 회고 적기**\n\n솔직함을 잘 나타내자. 꾸미지 않고 한 달간 느꼈던 감정을 잘 털어놓는 습관을 만들자. 나를 있는 그대로 바라보는 습관을 들여 내가 좋아하는 것과 싫어하는 것을 잘 정리하고 구체화 시켜 나만의 색깔을 꾸준히 만들어가자.\n\n**자체 블로그 만들기**\n\n어딘가 종속된 것이 아닌 내가 직접 만들고 꾸밀 수 있는 블로그를 만들고 싶다. 다만 프론트에 대한 지식이 부족하기도 하고, 디자인적 감각이 떨어져 쉽지 않을 것 같긴 하다. 그럼에도 꼭 상반기 안에는 만들고 싶다.\n\n...\n\n이 외에도 다양한 목표가 있지만 전부 달성하는 것은 힘들 것 같다. 최대한 우선순위를 잘 정돈해서 1년 뒤에 부끄럽지 않은 계획이 되었으면 좋겠다.\n\n## 마무리\n\n정말 오랜만에 회고다운 회고를 작성했다. 항상 바쁘다는 핑계로 나를 돌아볼 시간을 미뤄왔다. 이 회고 또한 써야지 써야지 하며 결국 1월 중순이 되어서야 마무리되었다.\n\n2022년은 개발자가 되기 위해 치열하게 고민했다. 2023년은 이제 진짜 개발자가 되어 치열하게 생존해야 한다. 무엇보다 **나를 가장 잘 아는 내가 되어 긍정적인 영향력을 펼치며 함께 일하고픈 개발자**가 되는 것이 올해의 가장 큰 목표이다.\n"},{"excerpt":"Java는 객체지향 언어이기 때문에 기본적으로 제공하는 이 아닌 경우 모두 로 구성되어 있다. 이것은 문자열도 마찬가지다. 다만 은 여타 다른 객체와 차이점을 가지고\n있다. 그것은 바로 을 지원한다는 것이다. 문자열 생성 방법 Java에서 문자열을 생성하는 방법에는 두 가지가 있다. 생성자를 활용한 방식 문자열 리터럴을 활용한 방식 생성자를 활용한 방식 …","fields":{"slug":"/java-string/"},"frontmatter":{"date":"December 11, 2022","title":"문자열 생성 방식 비교하기","tags":["Java","문자열"]},"rawMarkdownBody":"\nJava는 객체지향 언어이기 때문에 기본적으로 제공하는 `Primitive Type`이 아닌 경우 모두 `객체`로 구성되어 있다. 이것은 문자열도 마찬가지다. 다만 `문자열`은 여타 다른 객체와 차이점을 가지고\n있다. 그것은 바로 `문자열 리터럴`을 지원한다는 것이다.\n\n## 문자열 생성 방법\n\nJava에서 문자열을 생성하는 방법에는 두 가지가 있다.\n\n* 생성자를 활용한 방식\n* 문자열 리터럴을 활용한 방식\n\n### 생성자를 활용한 방식\n\n```java\nString name1 = new String(\"hyeonic\");\n```\n\n다른 객체 생성 방식과 동일하게 new 키워드를 통해 String 객체를 생성한다. 메모리 또한 Heap 영역에 할당된다.\n\n![](./1.png)\n\n생성자를 활용한 방식은 동일한 문자열로 생성하여도 heap 영역에 새롭게 할당된다.\n\n```java\nString name1 = new String(\"hyeonic\");\nString name2 = new String(\"hyeonic\");\n```\n\n![](./2.png)\n\n### 문자열 리터럴을 활용한 방식\n\n리터럴을 활용할 경우 heap 영역에 특수하게 존재하는 `String Constant Pool` 영역에 할당되게 된다.\n\n```java\nString name3 = \"hyeonic\";\nString name4 = \"hyeonic\";\n```\n\n![](./3.png)\n\n리터럴로 생성할 경우 동일한 문자열이면 `String Constant Pool`에 동일한 객체를 바라본다.\n\n## 문자열 비교\n\n생성자를 통해 생성한 문자열과 리터럴로 생성한 문자열을 비교해보자.\n\n```java\npublic class StringTest {\n    @Test\n    void 문자열을_비교한다() {\n        String name1 = new String(\"hyeonic\");\n        String name2 = \"hyeonic\";\n\n        assertThat(name1.equals(name2)).isTrue();\n        assertThat(name1 == name2).isFalse();\n    }\n}\n```\n\n`equals()` 메서드는 주로 동등성 비교를 위해 사용된다. 생성자로 생성했던 리터럴로 생성했던 문자열의 내용만 같다면 `true`를 반환한다. 실제 String이 재정의한 `equals()`를 살펴보면 그에\n대한 해답을 쉽게 찾을 수 있다.\n\n```java\npublic final class String\n        implements java.io.Serializable, Comparable<String>, CharSequence {\n    // ...\n    public boolean equals(Object anObject) {\n        if (this == anObject) {\n            return true;\n        }\n        if (anObject instanceof String) {\n            String aString = (String) anObject;\n            if (coder() == aString.coder()) {\n                return isLatin1() ? StringLatin1.equals(value, aString.value)\n                        : StringUTF16.equals(value, aString.value);\n            }\n        }\n        return false;\n    }\n    // ...\n}\n```\n\n우선 참조 주소를 비교하여 같다면 `true`를 반환한다. 아니라면 동일한 문자 시퀀스인지 확인한다.\n\n생성자를 통한 방식과 리터럴을 활용한 방식이 heap 영역에 서로 다른 객체를 바라보기 때문에 참조 주소를 비교하여 동일성을 확인하는 `==`는 `false`가 반환된다.\n\n## 문자열 리터럴은 어떻게 생성될까?\n\n문자열 리터럴을 사용할 경우 내부적으로 `String`의 `intern()` 메서드를 활용하게 된다.\n\n```java\npublic final class String\n        implements java.io.Serializable, Comparable<String>, CharSequence {\n    // ...\n    public native String intern();\n    // ...\n}\n```\n\n`intern()` 메서드가 호출될 때 풀에 `equals()` 메서드에 의해 결정된 대로 이 String 객체와 동일한 문자열이 포함되어 있으면 풀의 문자열이 반환된다. 그렇지 않으면 이 String 객체가 풀에\n추가되고 String 객체에 대한 참조가 반환된다.\n\n## 그렇다면 hashCode()는?\n\n같은 값을 가지는 생성자 방식의 문자열과 리터럴 방식의 문자열의 `hashCode()`를 비교하면 어떤 결과가 나올까? 바로 확인해보자.\n\n```java\npublic class StringTest {\n    @Test\n    void hashCode를_비교한다() {\n        String name1 = new String(\"hyeonic\");\n        String name2 = \"hyeonic\";\n\n        assertThat(name1.hashCode() == name2.hashCode()).isTrue();\n    }\n}\n```\n\n같은 문자열 값을 가진 두 문자열의 `hashCode()`를 비교할 경우 같다는 결과가 나온다. 추측컨데 두 문자열 모두 값을 기반으로 `hashCode()`를 생성하기 때문에 이러한 결과가 나온 것으로 판단한다.\n\n실제 String에 `hashCode()` 구현부를 살펴보면 재정의한 것을 확인할 수 있다. 핵심은 같은 문자열인 경우 같은 `hashCode()`를 반환할 수 있다는 것을 의미한다.\n\n```java\npublic final class String\n        implements java.io.Serializable, Comparable<String>, CharSequence {\n    // ...\n    public int hashCode() {\n        int h = hash;\n        if (h == 0 && value.length > 0) {\n            hash = h = isLatin1() ? StringLatin1.hashCode(value)\n                    : StringUTF16.hashCode(value);\n        }\n        return h;\n    }\n    // ...\n}\n```\n\n```java\nfinal class StringLatin1 {\n    // ...\n    public static int hashCode(byte[] value) {\n        int h = 0;\n        for (byte v : value) {\n            h = 31 * h + (v & 0xff);\n        }\n        return h;\n    }\n    // ...\n}\n```\n\n```java\nfinal class StringUTF16 {\n    // ...\n    public static int hashCode(byte[] value) {\n        int h = 0;\n        int length = value.length >> 1;\n        for (int i = 0; i < length; i++) {\n            h = 31 * h + getChar(value, i);\n        }\n        return h;\n    }\n    // ...\n}\n```\n\n> 두 가지 타입으로 구분된 이유는 Jdk 9부터 새롭게 도입된 Compact String으로 인해 바이트 배열 기반으로 구현되어 있기 때문이다. 문자열에 따라 Latin-1 혹은 UTF-16으로 인코딩된 문자를\n> 저장한다. 자세한 내용은 따로 다룰 예정이다.\n\n그렇다면 문자열이 실제로 저장되는 주소 값을 어떻게 확인할 수 있을까? String이 저장된 실제 주소값을 확인하는 방법은 `System.identityHashCode()`를 사용하는 것이다.\n\n```java\npublic class StringTest {\n    @Test\n    void 실제_주소를_비교한다() {\n        String name1 = new String(\"hyeonic\");\n        String name2 = \"hyeonic\";\n\n        assertThat(System.identityHashCode(name1) != System.identityHashCode(name2)).isTrue();\n    }\n}\n```\n\n실제로 두 주소는 같지 않다. 즉 두 String 객체가 별도로 저장되는 것을 확인할 수 있는 부분이다.\n\n## 정리\n\n지금까지 문자열 생성 방식에 따른 차이를 확인하였다. 생성자를 활용할 경우 매번 새롭게 heap 영역을 할당한다. 리터럴를 활용할 경우 heap 영역에 String Constant Pool에서 관리되기 때문에 같은\n값을 가진 문자열인 경우 기존의 주소를 공유해서 사용한다. 리터럴로 생성한 문자열은 기본적으로 공유된다. 그렇기 때문에 String은 Java의 대표적인 불변 객체이다.\n\n정리하면 문자열 리터럴 사용 시 메모리 측면에 많은 이점을 가져올 수 있다. 만약 같은 문자열 값을 가진 String을 100만 개 생성한다고 가정해본다. 생성자를 사용할 경우 100만 개의 문자열 객체가 생성되는\n것이지만 리터럴은 단 1개의 문자열만 생성하고 공유한다. 문자열 생성은 리터럴를 적극 활용하자!\n\n## References.\n\n[Class String](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html)<br>\n[자바의 String 객체와 String 리터럴](https://madplay.github.io/post/java-string-literal-vs-string-object)<br>\n[소소한 백엔드 개발 이야기 97](https://brunch.co.kr/@springboot/704)<br>\n[[번역] Compact Strings in Java 9](https://xlffm3.github.io/java/compact-string/)\n"},{"excerpt":"작성에 사용된 예제 코드는 spring-transaction에서 확인해볼 수 있다. 이전 시간에 트랜잭션 추상화를 통해 여러 데이터 접근 기술 변경에 유연한 구조를 만들었다. 또한 트랜잭션 동기화를 통해 멀티 스레드 환경에서도 별도의 커넥션 객체를 사용하여 독립적으로 트랜잭션이 적용될 수 있도록 구현하였다.  이번 시간에는 템플릿 콜백 패턴을 활용한 과 …","fields":{"slug":"/spring-transaction-2/"},"frontmatter":{"date":"December 10, 2022","title":"스프링이 개선한 트랜잭션 (2)","tags":["스프링","트랜잭션"]},"rawMarkdownBody":"\n> 작성에 사용된 예제 코드는 [spring-transaction](https://github.com/hyeonic/blog-code/tree/main/spring-transaction)에서 확인해볼 수 있다.\n\n이전 시간에 트랜잭션 추상화를 통해 여러 데이터 접근 기술 변경에 유연한 구조를 만들었다. 또한 트랜잭션 동기화를 통해 멀티 스레드 환경에서도 별도의 커넥션 객체를 사용하여 독립적으로 트랜잭션이 적용될 수 있도록 구현하였다. \n\n이번 시간에는 템플릿 콜백 패턴을 활용한 `TransactionTemplate`과 스프링 AOP를 활용한 선언적 트랜잭션인 `@Transactional`을 활용한 트랜잭션 로직 분리에 대해 알아보려 한다.\n\n## TransactionTemplate\n\n프로그래밍 방식의 트랜잭션 구분 및 트랜잭션 예외 처리를 단순화하는 템플릿 클래스이다. `execute()` 메서드에 `TransactionCallback` 인터페이스를 구현한 구현체를 전달하여 트랜잭션을 수행할 수\n있다.\n\n```java\npublic class AccountService {\n    // ...\n    public void withdraw(final Account account, final Long amount) {\n        transactionTemplate.executeWithoutResult(\n                transactionStatus -> jdbcAccountRepositoryV3.update(generateAccount(account, amount))\n        );\n    }\n    // ...\n}\n```\n\n> `executeWithoutResult()`는 return이 존재하지 않는 `execute()`이다. `TransactionOperations` 인터페이스에 `default` 메서드로 명시되어 있다.\n\n`TransactionTemplate` 덕분에 트랜잭션 시작과 커밋, 롤백에 대한 로직이 전부 제거되었다. `execute()` 메서드를 간단히 요약하면 아래와 같다.\n\n```java\npublic class TransactionTemplate extends DefaultTransactionDefinition\n        implements TransactionOperations, InitializingBean {\n    // ...\n    public <T> T execute(TransactionCallback<T> action) throws TransactionException {\n        // ...\n        T result;\n        try {\n            result = action.doInTransaction(status);\n        } catch (RuntimeException | Error ex) {\n            // Transactional code threw application exception -> rollback\n            rollbackOnException(status, ex);\n            throw ex;\n            // ...\n            this.transactionManager.commit(status);\n            return result;\n        }\n        // ...\n    }\n    // ...\n}\n```\n\n실제 코드는 더 복잡하게 되어있지만 핵심은 매개변수로 전달된 구현체의 메서드 `action.doInTransaction(status)`를 수행한다. 구현체 내부에는 우리가 작성한 비즈니스 로직이 담겨 있다. 만약\n로직 수행 중 예외가 터질 경우 롤백한다. 정상적으로 수행되면 커밋한다.\n\n하지만 아직도 비즈니스 로직과 트랜잭션 기능이 하나의 클래스에 존재하고 있다. 어떻게하면 트랜잭션에 대한 의존성을 최소화할 수 있을까? 어떻게하면 service 계층에 비즈니스 로직만 순수하게 남길 수 있을까?\n\n## 트랜잭션 AOP\n\nservice 계층에 비즈니스 로직만 순수하게 남길 수 있는 방법은 트랜잭션이라는 부가기능을 프록시로 분리하는 것이다.\n\n```java\npublic interface AccountService {\n\n    void withdraw(final Account account, final Long amount);\n}\n```\n\n먼저 행위를 명시해둔 AccountService 인터페이스이다. 실제 비즈니스 로직 명시를 위한 구현체를 추가한다.\n\n```java\n\n@Service\npublic class AppAccountService implements AccountService {\n\n    private final JdbcAccountRepository jdbcAccountRepositoryV4;\n\n    public AppAccountService(final JdbcAccountRepository jdbcAccountRepositoryV4) {\n        this.jdbcAccountRepositoryV4 = jdbcAccountRepositoryV4;\n    }\n\n    public void withdraw(final Account account, final Long amount) {\n        jdbcAccountRepositoryV4.update(generateAccount(account, amount));\n    }\n\n    private Account generateAccount(final Account account, final Long amount) {\n        return new Account(account.getId(), account.getHolder(), account.getAmount() - amount);\n    }\n}\n```\n\n트랜잭션에 대한 부가기능을 추가하기 위해 프록시 객체를 추가한다.\n\n```java\n\n@Service\npublic class AccountServiceProxy implements AccountService {\n\n    private final TransactionTemplate transactionTemplate;\n    private final AccountService accountService;\n\n    public AccountServiceProxy(final PlatformTransactionManager platformTransactionManager,\n                               final AccountService accountService) {\n        this.transactionTemplate = new TransactionTemplate(platformTransactionManager);\n        this.accountService = accountService;\n    }\n\n    @Override\n    public void withdraw(final Account account, final Long amount) {\n        transactionTemplate.executeWithoutResult(transactionStatus -> accountService.withdraw(account, amount));\n    }\n}\n```\n\n이제 실제 사용 측은 프록시 객체를 활용하면 되기 때문에 두 관심사를 비즈니스 로직을 담은 객체와 프록시 객체로 나눌 수 있게 되었다. 하지만 매번 트랜잭션 적용을 위해 프록시 객체를 매번 생성하는 것은 매우 고된\n일이다.\n\n스프링은 AOP를 활용하여 매우 편리하게 프록시를 적용할 수 있다. 또한 스프링이 트랜잭션과 관련된 AOP를 이미 만들어두었기 때문에 우리는 편리하게 가져다 사용하기만 하면 된다.\n\n### @Transactional\n\n개별 메서드 또는 클래스에 대한 트랜잭션 특성을 설명한다. 이 애노테이션이 클래스 수준에 선언되면 선언 클래스 및 해당 하위 클래스의 모든 메서드에 기본값으로 적용된다. 개별적인 트랜잭션 처리가 필요한\n곳에 `@Transactional`만 활용하면 트랜잭션 AOP가 이 애노테이션을 인식하여 자동으로 트랜잭션 프록시를 적용해준다.\n\n```java\n\n@Service\npublic class AccountService {\n    // ...\n    @Transactional\n    public void withdraw(final Account account, final Long amount) {\n        jdbcAccountRepositoryV5.update(new Account(account.getId(), account.getHolder(), account.getAmount() - amount));\n    }\n}\n```\n\n`@Transactional` 애노테이션을 통해 선언적 트랜잭션을 적용하기 위해서는 AOP와 Spring에서 제공하는 AOP에 대한 전반적인 지식이 필요하다. 이 부분은 추가적인 학습 이후 별도의 포스팅을 남길\n예정이다.\n\n## 정리\n\n지금까지 service 계층에 있는 비즈니스 로직과 트랜잭션과 관련된 두 가지 관심사를 분리하기 위해 스프링이 어떤 방법을 활용했는지 알아보았다. 인터페이스를 활용한 추상화와 스레드 별도의 저장소인 스레드 로컬,\nAOP 등 다양한 기술 덕분에 우리는 `@Transactional` 애노테이션을 통해 복잡한 트랜잭션을 편리하게 활용할 수 있었다.\n\n편리한 만큼 내부 구조를 이해하는 것은 매우 까다로운 과정이다. 추후 AOP에 대한 개념, 적용 방법, 이것을 편리하게 적용하기 위한 스프링의 노력들을 추가적으로 학습한 뒤 트랜잭션이 적용된 클래스 및 메서드를\n감지하고 부가기능을 도입하는 과정을 알아보려 한다.\n\n## References.\n\n[Interface PlatformTransactionManager](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/PlatformTransactionManager.html)<br>\n이일민 지음, 『토비의 스프링 3.1 Vol. 1 스프링의 이해와 원리』, 에이콘(2012), p349-399.<br>\n[스프링 DB 1편 - 데이터 접근 핵심 원리](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-db-1/dashboard)<br>\n[[Spring] 트랜잭션에 대한 이해와 Spring이 제공하는 Transaction(트랜잭션) 핵심 기술 - (1/3)](https://mangkyu.tistory.com/154)\n"},{"excerpt":"작성에 사용된 예제 코드는 spring-transaction에서 확인해볼 수 있다. 트랜잭션은 논리적인 작업 셋을 모두 완벽하게 처리하거나, 처리하지 못할 경우 원래 상태로 복구하여 작업의 일부만 적용되는 현상(Partial update)을 막아준다. 또한 트랜잭션은 하나의 논리적인 작업 셋의 쿼리 개수와 관계없이 논리적인 작업 셋 자체가 전부 적용(CO…","fields":{"slug":"/spring-transaction-1/"},"frontmatter":{"date":"December 09, 2022","title":"스프링이 개선한 트랜잭션 (1)","tags":["스프링","트랜잭션"]},"rawMarkdownBody":"\n> 작성에 사용된 예제 코드는 [spring-transaction](https://github.com/hyeonic/blog-code/tree/main/spring-transaction)에서 확인해볼 수 있다.\n\n트랜잭션은 논리적인 작업 셋을 모두 완벽하게 처리하거나, 처리하지 못할 경우 원래 상태로 복구하여 작업의 일부만 적용되는 현상(Partial update)을 막아준다.\n\n또한 트랜잭션은 하나의 논리적인 작업 셋의 쿼리 개수와 관계없이 논리적인 작업 셋 자체가 전부 적용(COMMIT)되거나 아무것도 적용되지 않는 것(ROLLBACK)을 보장해주는 것이다. 결국 트랜잭션은 여러 개의\n변경 작업을 수행하는 쿼리가 조합 됐을 때만 의미 있는 개념은 아니다.\n\n트랜잭션은 시작과 끝이 존재하는 절차(script)이다. 트랜잭션은 이러한 절차의 시작과 끝을 단위화하는 것이다. 단위화된 트랜잭션은 반드시 원자성이 보장되어야 한다.\n\n여러 작업 셋을 하나의 트랜잭션으로 처리하기 위해서는 같은 커넥션 내에서 동작해야 한다. 이것을 구현하는 방법은 아래와 같이 매개변수를 통해 커넥션 객체를 전달하는 것이다.\n\n```java\npublic class JdbcAccountRepository {\n    // ...\n    public Account save(final Connection connection, final Account account) throws SQLException {\n        var sql = \"INSERT INTO account(holder, amount) VALUES (?, ?)\";\n        try (var preparedStatement = connection.prepareStatement(sql)) {\n\n            preparedStatement.setString(1, account.getHolder());\n            preparedStatement.setLong(2, account.getAmount());\n            preparedStatement.executeUpdate();\n\n            return findByHolder(connection, account.getHolder())\n                    .orElseThrow(NoSuchElementException::new);\n        }\n    }\n    // ...\n}\n```\n\n또한 트랜잭션과 관련된 처리가 마무리된 후 커넥션을 닫아야 한다. 위 repository보다 상위 계층에서 커넥션을 생성하고 닫는 생명 주기에 대한 책임까지 가지게 된다. 보통 service 계층은 애플리케이션의\n핵심 비즈니스 로직을 처리하기 위한 계층이다. 하지만 데이터베이스 접근을 위한 커넥션에 대한 책임까지 가지게 되는 문제가 발생한다.\n\n```java\n\n@Service\npublic class AccountService {\n    // ...\n    public void withdraw(final Account account, final Long amount) throws SQLException {\n        var connection = dataSource.getConnection();\n        try {\n            connection.setAutoCommit(false);\n            accountRepository.update(connection,\n                    new Account(account.getId(), account.getHolder(), account.getAmount() - amount));\n            connection.commit();\n        } catch (final SQLException e) {\n            connection.rollback();\n            throw new RuntimeException(e);\n        }\n    }\n    // ...\n}\n```\n\n개발자가 매번 일련의 트랜잭션을 보장하기 위해 커넥션 객체를 생성하고 반납하는 등의 로직을 관리하는 것은 매우 귀찮은 일이다. 또한 service 계층에서 처리해야 할 비즈니스 로직에 JDBC와 관련된 의존성(\nSQLException 등)을 가지게 되기 때문에 변경에 유연하지 못한 구조를 가져온다. 스프링에서는 이러한 불편함을 해결하기 위해 `트랜잭션 추상화`와 `트랜잭션 동기화` 기능을 제공한다.\n\n## 트랜잭션 추상화\n\n현재 service 계층은 dataSource를 통해 커넥션 객체를 획득하고 있다. 또한 커넥션 객체의 `setAutoCommit()` 메서드를 통해 트랜잭션을 시작하고 있다. 만약 다른 데이터 접근 기술로\n변경된다면 어떻게 될까? 실제로 순수한 JPA를 사용할 경우 아래와 같은 과정을 거쳐 트랜잭션을 시작할 수 있다.\n\n```java\nEntityTransaction entityTransaction = entityManager.getTranaction();\nentityTransaction.begin();\n```\n\n데이터 접근 기술의 변경은 비즈니스 로직인 service 계층의 수정까지 야기하게 된다. 스프링은 이것을 트랜잭션의 행위들을 명시한 인터페이스를 통해 극복했다.\n\n```java\npublic interface PlatformTransactionManager extends TransactionManager {\n\n    TransactionStatus getTransaction(@Nullable TransactionDefinition definition) throws TransactionException;\n\n    void commit(TransactionStatus status) throws TransactionException;\n\n    void rollback(TransactionStatus status) throws TransactionException;\n}\n```\n\n`PlatformTransactionManager`은 스프링의 명령형 트랜잭션 인프라의 중앙 인터페이스이다.\n\n* `getTransaction(TransactionDefinition definition)`: 지정된 전파 동작에 따라 현재 활성 트랜잭션을 반환하거나 새 트랜잭션을 만든다.\n* `commit(TransactionStatus status)`: 상태와 관련하여 주어진 트랜잭션을 커밋한다.\n* `rollback(TransactionStatus status)`: 주어진 트랜잭션의 롤백을 수행한다.\n\n이러한 트랜잭션 매니저 덕분에 특정 데이터 접근 기술에 의존하지 않고 추상화된 인터페이스를 의존하여 변경에 유연하게 대처할 수 있게 된다. 아래는 추상화된 트랜잭션 매니저 인터페이스를 활용하여 개선한 service\n계층이다.\n\n```java\n\n@Service\npublic class AccountService {\n    // ...\n    public void withdraw(final Account account, final Long amount) {\n        var transactionStatus = platformTransactionManager.getTransaction(new DefaultTransactionDefinition());\n        try {\n            accountRepository.update(new Account(account.getId(), account.getHolder(), account.getAmount() - amount));\n            platformTransactionManager.commit(transactionStatus);\n        } catch (final Exception e) {\n            platformTransactionManager.rollback(transactionStatus);\n            throw new RuntimeException(e);\n        }\n    }\n}\n```\n\n이전에 JDBC에 강하게 의존하던 코드들은 사라지고 추상화된 인터페이스에만 의존하고 있다. 이제 스프링의 의존성 주입을 활용하여 데이터 접근 기술에 맞는 트랜잭션 매니저를 적절히 선택하여 활용할 수 있게 되었다.\n\n* `getTransaction(new DefaultTransactionDefinition())`: 트랜잭션을 시작한다. `TransactionStatus`를 반환한다. 현재 트랜잭션에 대한 정보를 포함한다. 이러한\n  정보를 바탕으로 이후 트랜잭션 커밋 혹은 롤백을 진행할 수 있다.\n* `new DefaultTransactionDefinition()`: 트랜잭션과 관련된 옵션을 지정한다. 전부 기본 설정을 활용한다.\n* `commit(transactionStatus)`: 트랜잭션을 커밋한다.\n* `rollback(transactionStatus)`: 트랜잭션을 롤백한다.\n\n트랜잭션 매니저 사용 이전에는 메서드 수행 시 매개변수로 커넥션 객체를 전달해서 같은 커넥션을 유지할 수 있도록 만들었다. 그렇다면 트랜잭션 매니저는 어떻게 같은 커넥션 내에서 동작하도록 보장하는 걸까?\n\n## 트랜잭션 동기화\n\n트랜잭션 동기화는 트랜잭션을 시작하기 위한 커넥션 객체를 특별한 저장소에 보관해 두고 필요할 때 꺼내 쓸 수 있도록 하는 기술이다. 트랜잭션 동기화 저장소는 스레드마다 커넥션 객체를 `독립적`으로 관리하므로 멀티 스레드 환경에서 충돌이 발생하지 않는다. `트랜잭션 매니저`는 `트랜잭션 동기화 매니저`를 통해 이것을 구현했다.\n\n아래는 트랜잭션 매니저가 관리하는 커넥션을 획득하고 반납하는 로직이 반영된 repository이다. dataSource에서 획득하던 이전과 다르게 `DataSourceUtils`를 통해 커넥션을 획득하고 반납한다.\n\n```java\n\n@Repository\npublic class JdbcAccountRepository {\n    // ...\n    public Account save(final Account account) {\n        var connection = DataSourceUtils.getConnection(dataSource);\n        var sql = \"INSERT INTO account(holder, amount) VALUES (?, ?)\";\n        try (var preparedStatement = connection.prepareStatement(sql)) {\n            preparedStatement.setString(1, account.getHolder());\n            preparedStatement.setLong(2, account.getAmount());\n            preparedStatement.executeUpdate();\n\n            return findByHolder(account.getHolder())\n                    .orElseThrow(NoSuchElementException::new);\n        } catch (final SQLException e) {\n            throw new RuntimeException(e);\n        } finally {\n            DataSourceUtils.releaseConnection(connection, dataSource);\n        }\n    }\n    // ...\n}\n```\n\n* `DataSourceUtils.getConnection(dataSource)`: `TransactionSynchronizationManager`가 관리하는 커넥션이 있다면 획득하고 없다면 새롭게 생성하여\n  반환한다.\n* `DataSourceUtils.releaseConnection(connection, dataSource)`: 커넥션을 `close()`를 통해 닫으면 유지할 수 없다. 커넥션은 이후 로직에도 계속 살아 있어야\n  한다. 해당 메서드는 커넥션을 바로 닫는 것이 아니라 트랜잭션 매니저가 관리하지 않을 때 해당 커넥션을 닫는다.\n\n### DataSourceUtils.getConnection(dataSource)\n\n먼저 커넥션을 획득하는 로직을 차근차근 살펴보자.\n\n```java\npublic abstract class DataSourceUtils {\n    // ...\n    public static Connection getConnection(DataSource dataSource) throws CannotGetJdbcConnectionException {\n        try {\n            return doGetConnection(dataSource);\n        } catch (SQLException ex) {\n            throw new CannotGetJdbcConnectionException(\"Failed to obtain JDBC Connection\", ex);\n        } catch (IllegalStateException ex) {\n            throw new CannotGetJdbcConnectionException(\"Failed to obtain JDBC Connection\", ex);\n        }\n    }\n    // ...\n}\n```\n\n주어진 DataSource에서 Connection을 획득한다. `SQLException`을 `UncheckedException`으로 변환하여 호출부를 단순화하고 발생하는 예외를 의미 있게 만든다.\n\n```java\npublic abstract class DataSourceUtils {\n    // ...\n    public static Connection doGetConnection(DataSource dataSource) throws SQLException {\n        Assert.notNull(dataSource, \"No DataSource specified\");\n\n        ConnectionHolder conHolder = (ConnectionHolder) TransactionSynchronizationManager.getResource(dataSource);\n        if (conHolder != null && (conHolder.hasConnection() || conHolder.isSynchronizedWithTransaction())) {\n            conHolder.requested();\n            if (!conHolder.hasConnection()) {\n                logger.debug(\"Fetching resumed JDBC Connection from DataSource\");\n                conHolder.setConnection(fetchConnection(dataSource));\n            }\n            return conHolder.getConnection();\n        }\n        // Else we either got no holder or an empty thread-bound holder here.\n\n        logger.debug(\"Fetching JDBC Connection from DataSource\");\n        Connection con = fetchConnection(dataSource);\n\n        if (TransactionSynchronizationManager.isSynchronizationActive()) {\n            try {\n                // Use same Connection for further JDBC actions within the transaction.\n                // Thread-bound object will get removed by synchronization at transaction completion.\n                ConnectionHolder holderToUse = conHolder;\n                if (holderToUse == null) {\n                    holderToUse = new ConnectionHolder(con);\n                } else {\n                    holderToUse.setConnection(con);\n                }\n                holderToUse.requested();\n                TransactionSynchronizationManager.registerSynchronization(\n                        new ConnectionSynchronization(holderToUse, dataSource));\n                holderToUse.setSynchronizedWithTransaction(true);\n                if (holderToUse != conHolder) {\n                    TransactionSynchronizationManager.bindResource(dataSource, holderToUse);\n                }\n            } catch (RuntimeException ex) {\n                // Unexpected exception from external delegation call -> close Connection and rethrow.\n                releaseConnection(con, dataSource);\n                throw ex;\n            }\n        }\n\n        return con;\n    }\n    // ...\n}\n```\n\n실제로 주어진 DataSource에서 Connection을 획득한다. `doGetConnection()` 메서드는 Connection 객체를 생성해줄 뿐만 아니라 트랜잭션 동기화에 사용할수 있도록 특별한 저장소에 바인딩해준다. 트랜잭션이 동기화된 채로 사용하면 이후 커넥션을 획득할 때 동기화 시킨 데이터베이스 커넥션을 사용하게 된다.\n\n`트랜잭션 추상화`를 적절히 활용하면 JDBC API와 강하게 의존하던 부분도 제거할 수 있다. 또한 `트랜잭션 동기화`를 통해 매번 전달하던 Connection 객체에 대한 의존성도 제거할 수 있게 된다.\n\n```java\n\n@Service\npublic class AccountService {\n    // ...\n    public void withdraw(final Account account, final Long amount) {\n        var transactionStatus = platformTransactionManager.getTransaction(new DefaultTransactionDefinition());\n        try {\n            accountRepository.update(new Account(account.getId(), account.getHolder(), account.getAmount() - amount));\n            platformTransactionManager.commit(transactionStatus);\n        } catch (final Exception e) {\n            platformTransactionManager.rollback(transactionStatus);\n            throw new RuntimeException(e);\n        }\n    }\n}\n```\n\n하지만 아직 몇 가지 문제가 남아 있다. service 계층은 언급한 것 처럼 애플리케이션의 비즈니스 로직이 위치하는 곳이다. 위 코드를 보면 아직도 트랜잭션에 대한 의존성이 남아 있게 된다. 이것을 어떻게 개선할 수 있을까? \n\n다음 시간에는 템플릿 콜백 패턴을 활용한 `TransactionTemplate`과 스프링 AOP를 활용한 선언적 트랜잭션인 `@Transactional`을 활용한 트랜잭션 로직 분리에 대해 알아보려 한다.\n\n## References.\n\n[Interface PlatformTransactionManager](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/PlatformTransactionManager.html)<br>\n이일민 지음, 『토비의 스프링 3.1 Vol. 1 스프링의 이해와 원리』, 에이콘(2012), p349-399.<br>\n[스프링 DB 1편 - 데이터 접근 핵심 원리](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-db-1/dashboard)<br>\n[[Spring] 트랜잭션에 대한 이해와 Spring이 제공하는 Transaction(트랜잭션) 핵심 기술 - (1/3)](https://mangkyu.tistory.com/154)\n"},{"excerpt":"동시성 이슈를 해결하기 위해서는 다양한 방법이 존재한다. 예를 들면 Java의 , 비관적 락과 낙관적 락, 분산 락 등이 존재한다. 이번에는 충돌이 발생하지 않는다고 낙관적으로 가정한 뒤 락을 처리하는 낙관적 락에 대해 알아보려 한다. 작성에 사용된 예제 코드는 optimistic-locking에서 확인해볼 수 있다. 낙관적 락 트랜잭션 충돌이 발생하지 …","fields":{"slug":"/optimistic-locking/"},"frontmatter":{"date":"December 03, 2022","title":"낙관적 락과 동시성 테스트","tags":["optimisitc-locking","낙관적 락"]},"rawMarkdownBody":"\n동시성 이슈를 해결하기 위해서는 다양한 방법이 존재한다. 예를 들면 Java의 `synchronized`, 비관적 락과 낙관적 락, 분산 락 등이 존재한다. 이번에는 충돌이 발생하지 않는다고 낙관적으로 가정한 뒤 락을 처리하는 낙관적 락에 대해 알아보려 한다.\n\n> 작성에 사용된 예제 코드는 [optimistic-locking](https://github.com/hyeonic/blog-code/tree/main/optimistic-locking)에서 확인해볼 수 있다.\n\n## 낙관적 락\n\n트랜잭션 충돌이 발생하지 않는다고 낙관적으로 가정한다. 추가적인 `version`을 기반으로 충돌할 경우 롤백을 진행한다.  가장 큰 장점은 충돌이 일어나지 않는다고 가정하기 때문에 동시 처리에 대한 이점이 많다.\n\n## @Version\n\n낙관적 락을 사용하는 방법은 여러가지가 있지만 대표적으로는 `@Version` 애노테이션을 사용하는 방법이다. `@Version`은 낙관적 락 값으로 사용되는 엔터티 클래스의 버전 필드 또는 속성을 지정한다. 이 버전은 병합 작업을 수행할 때 무결성을 보장하고 낙관적 동시성 제어를 위해 사용 된다. `@Version`은 클래스당 하나의 속성 또는 필드만 사용해야 한다. 둘 이상의 버전 또는 속성 필드를 사용할 수 없다.\n\n![](./version.png)\n\n`@Version`은 엔티티 클래스의 기본 테이블에 매핑되어야 한다. 기본 테이블이 아닌 다른 테이블에 매핑할 수 없다. `@Version`이 지원되는 type은 `int`, `Integer`, `short`, `Short`, `long`, `Long`, `java.sql.Timestamp`이다. `@Version`이 사용된 엔티티는 수정될 때 자동으로 버전이 증가하며 수정할 때 조회 시점과 버전이 다른 경우 예외가 발생한다.\n\n![](./version-transaction.png)\n\n이러한 버전은 엔티티 수정 시점에 최신화되며 JPA에 의해 자동적으로 관리된다.\n\n```sql\nupdate\n    member\nset name=?,\n    version=?\nwhere id = ?\n  and version = ?\n```\n\n만약 WHERE 조건에 의해 수정할 대상이 없는 경우 버전이 증가 했다고 판단하여 예외를 던진다.\n\nSpring Data JPA를 사용할 경우 JPA에 대한 구현체는 기본적으로 hibernate를 사용하게 된다. 이 예외는 기본적으로 hibernate에서 던지는 `StaleStateException` 예외를 Spring이 `HibernateJpaDialect`의 `convertHibernateAccessException()` 메서드를\n통해 `org.springframework.dao` 계층에서 적절한 예외(DataAccessException 타입)로 변환된다.\n\n```java\npackage org.springframework.orm.jpa.vendor;\n\n// ...\npublic class HibernateJpaDialect extends DefaultJpaDialect {\n    // ...\n    protected DataAccessException convertHibernateAccessException(HibernateException ex) {\n        // ...\n        if (ex instanceof StaleStateException) {\n            return new ObjectOptimisticLockingFailureException(ex.getMessage(), ex);\n        }\n        // ...\n    }\n}\n```\n\n### 적용\n\n먼저 Version 칼럼을 사용하기 위한 `Member` 엔티티이다.\n\n```java\n@Entity\npublic class Member {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    @Column\n    private String name;\n\n    @Version\n    private Long version;\n\n    protected Member() {\n    }\n\n    public Member(final String name) {\n        this.name = name;\n    }\n\n    public void changeName(final String name) {\n        this.name = name;\n    }\n\n    // getter..\n}\n```\n\n고유한 `id`와 이름을 나타내는 `name`을 가지고 있다. `@Version`을 통해 엔티티의 버전을 명시하기 위한 칼럼을 추가한다. 위 엔티티를 기반으로 자동으로 생성되는 테이블 DDL을 살펴보면 아래와 같다.\n\n```sql\ncreate table member\n(\n    id      bigint not null auto_increment,\n    name    varchar(255),\n    version bigint,\n    primary key (id)\n)\n```\n\n`version`이라는 칼럼이 추가적으로 생성되어 테이블이 생성된다. 이러한 Version 정보를 사용하면 최초에 적용된 커밋만 반영되고 나머지는 무시된다.\n\n## 주의\n\n`@Version`으로 추가한 필드는 JPA가 직접 관리한다. 그렇기 때문에 개발자가 임의로 수정하지 않도록 주의해야 한다. 단 `벌크 연산`의 경우에는 버전 증가를 위해 강제로 증가시켜야 한다.\n\n> 벌크 연산이란?\n> \n> 여러 건의 데이터를 한 번에 수정(update)하거나 삭제(delete)하는 것을 말한다. (hibernate는 insert도 지원한다.)\n> \n\n## 테스트로 검증하기\n\n낙관적 락이 잘 작동하는지 확인하기 위해서는 동시성 관련 테스트를 진행해야 한다. 이때 대표적으로 사용할 수 있는 방법 중 하나는 `CountDownLatch`를 사용하는 것이다.\n\n### CountDownLatch\n\n다른 스레드에서 수행 중인 일련의 작업이 완료될 때 까지 하나 이상의 스레드가 대기할 수 있도록 하는 동기화 지원이다.\n\n`CountDownLatch`는 지정된 `count`로 초기화된다. `countDown()` 메서드의 호출로 인해 현재 카운트가 0에 도달할 때 까지 `await()` 메서드는 차단되며, \n그 후 대기 중인 모든 스레드가 해제되고 후속 `await()` 호출이 즉시 반환된다. 이것은 일회성 현상으로 카운트를 재설정할 수 없다. 카운트 재설정하는 버전이 필요할 경우 `CyclicBarrier` 사용을 고려한다.\n\n자세한 사용 방법은 별도의 게시글로 작성할 예정이다.\n\n이제 `CountDownLatch`를 활용하여 간단한 동시성 테스트를 진행해보자.\n\n먼저 테스트 진행을 위한 `Member` 엔티티이다.\n\n```java\n@Entity\npublic class Member {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    @Column\n    private String name;\n\n    @Version\n    private Long version;\n\n    protected Member() {\n    }\n\n    public Member(final String name) {\n        this.name = name;\n    }\n\n    public void changeName(final String name) {\n        this.name = name;\n    }\n\n    // getter..\n}\n```\n\nMember 엔티티 관리를 위한 `MemberRepository`이다.\n\n```java\npublic interface MemberRepository extends JpaRepository<Member, Long> {\n}\n```\n\nMember의 비즈니스 로직을 담당하는 `MemberService`이다. 동시성 테스트를 진행할 메서드의 대상이다.\n\n```java\n@Service\n@Transactional(readOnly = true)\npublic class MemberService {\n\n    private final MemberRepository memberRepository;\n\n    public MemberService(final MemberRepository memberRepository) {\n        this.memberRepository = memberRepository;\n    }\n\n    @Transactional\n    public Member save(final Member member) {\n        return memberRepository.save(member);\n    }\n\n    public Member findById(final Long id) {\n        return getMember(id);\n    }\n\n    @Transactional\n    public void changeName(final Long id, final String name) {\n        Member foundMember = getMember(id);\n        foundMember.changeName(name);\n    }\n\n    private Member getMember(final Long id) {\n        return memberRepository.findById(id)\n                .orElseThrow(NoSuchElementException::new);\n    }\n}\n```\n\n자 이제 동시성 테스트를 진행해보자.\n\n```java\n@SpringBootTest\nclass MemberServiceTest {\n    \n    private final MemberService memberService;\n\n    @Autowired\n    MemberServiceTest(final MemberService memberService) {\n        this.memberService = memberService;\n    }\n    \n    @Test\n    void member를_동시에_수정한다() throws InterruptedException {\n        Member member = memberService.save(new Member(\"version 0\"));\n\n        ExecutorService executorService = Executors.newFixedThreadPool(2);\n        CountDownLatch countDownLatch = new CountDownLatch(2);\n\n        AtomicInteger count = new AtomicInteger(0);\n        for (int i = 0; i < 2; i++) {\n            executorService.execute(() -> {\n                try {\n                    memberService.changeName(member.getId(), \"version change\");\n                } catch (final ObjectOptimisticLockingFailureException e) {\n                    count.incrementAndGet();\n                } finally {\n                    countDownLatch.countDown();\n                }\n            });\n        }\n\n        countDownLatch.await();\n\n        Member actual = memberService.findById(member.getId());\n\n        assertAll(() -> {\n            assertThat(count.get()).isEqualTo(1);\n            assertThat(actual.getName()).isEqualTo(\"version change\");\n        });\n    }\n}\n```\n\n * `ExecutorService executorService = Executors.newFixedThreadPool(2)`: 제한된 개수의 스레드 풀을 관리한다. \n * `CountDownLatch countDownLatch = new CountDownLatch(2)`: 스레드 대기를 위한 CountDownLatch이다.\n * `AtomicInteger count = new AtomicInteger(0)`: 여러 스레드에서 동시에 엑세스할 수 있는 환경에서 동시성을 보장하기 위한 Wrapper 클래스이다. 낙관적 락에서 던진 예외를 catch하고 count하기 위해 사용한다.\n * `countDownLatch.countDown()`: countDownLatch에서 명시한 count를 차감한다. `finally`에 정한 이유는 `countDown()`가 무조건 실행되어야 하기 때문이다. 만약 차감하지 않을 경우 무한정 기다리게 된다.\n * `countDownLatch.await()`: countDownLatch에서 명시한 count가 0이 되길 기다린다. 0이면 이후 스레드가 실행한다.\n\n왜 `countDownLatch.await()`를 활용하여 모든 동시 요청을 기다려야 할까? 이유는 동시 요청 이후 메인 스레드는 지속해서 작업을 진행하기 때문이다. 테스트를 진행하는 메인 스레드는 동시 요청과 동시에 나머지 작업을 진행한다. `await()`를 통해 기다리지 않으면 동시 요청에 대한 응답도 받기 이전에 테스트 메인 스레드가 마무리 될 것이다.\n\n## 정리\n\n지금까지 낙관적 락을 활용한 동시성 제어에 대해 알아보았다. JPA에서 제공하는 편리한 애노테이션 덕분에 아주 간단하게 적용할 수 있다. 낙관적 락은 동시에 접근하는 상황에서 최초에 커밋된 것만 반영된다. 만약 동시 요청이 와도 모든 작업이 반영되야 하는 상황에서는 예외 상황에서 추가적인 핸들링이 필요해진다. 낙관적 락은 단순히 충돌을 감지할 뿐이다.\n\n이러한 낙관적 락은 단일 데이터베아스 환경에서는 직접적인 락을 걸지 않기 때문에 성능적인 측면에서 이점이 많다. 또한 다중 애플리케이션 환경에서도 단순히 데이터베이스의 버전 칼럼을 활용하여 동시성을 제어하기 때문에 스케일 아웃한 환경에서도 적용이 가능할 것으로 추측한다.\n\n## References.\n\n[Annotation Type Version](https://docs.oracle.com/javaee/7/api/javax/persistence/Version.html)<br>\n[Class CountDownLatch](https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CountDownLatch.html)<br>\n김영한 지음, 『자바 ORM 표준 JPA 프로그래밍』, 에이콘(2015), p697-700.\n"},{"excerpt":"SimpleJpaRepository의 save()는 어떻게 새로운 엔티티를 판단할까? 를 사용하면 JPA 기반의 repository를 쉽게 구현할 수 있다. 대표적으로 를 통해 보다 더 정교한 기능들을 제공한다. 이를 통해 개발자는 데이터 접근 계층을 손쉽게 구현할 수 있다.  SimpleJpaRepository 는  인터페이스의 기본 구현이다. 이것은 …","fields":{"slug":"/save-persist-merge/"},"frontmatter":{"date":"November 21, 2022","title":"SimpleJpaRepository의 save()는 어떻게 새로운 엔티티를 판단할까?","tags":["우아한테크코스","JPA","save","persist","merge"]},"rawMarkdownBody":"\n## SimpleJpaRepository의 save()는 어떻게 새로운 엔티티를 판단할까?\n\n`Spring Data JPA`를 사용하면 JPA 기반의 repository를 쉽게 구현할 수 있다.\n\n대표적으로 `SimpeJpaRepository`를 통해 `EntityManager`보다 더 정교한 기능들을 제공한다. 이를 통해 개발자는 데이터 접근 계층을 손쉽게 구현할 수 있다. \n\n## SimpleJpaRepository\n\n`SimpleJpaRepository`는 `org.springframework.data.repository.CrudRepository` 인터페이스의 기본 구현이다. 이것은 일반 `EntityManager` 보다 더 정교한 인터페이스를 제공한다. 먼저 엔티티를 영속 시키기 위한 `save()` 메서드를 중점적으로 살펴보려한다. 예시를 살펴보기 위해 먼저 Member 엔티티를 선언한다.\n\n```java\n@Entity\npublic class Member {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    private String name;\n\n    protected Member() {\n    }\n\n    public Member(final Long id, final String name) {\n        this.id = id;\n        this.name = name;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public String getName() {\n        return name;\n    }\n}\n```\n\n간단한 테스트를 통해 동작 방식을 확인해보자.\n\n```java\n@DataJpaTest\n@DisplayNameGeneration(DisplayNameGenerator.ReplaceUnderscores.class)\nclass MemberRepositoryTest {\n\n    private final MemberRepository memberRepository;\n\n    @Autowired\n    MemberRepositoryTest(final MemberRepository memberRepository) {\n        this.memberRepository = memberRepository;\n    }\n\n    @Test\n    void 식별자가_없는_member를_저장한다() {\n        Member member = new Member(null, \"매트\");\n\n        Member actual = memberRepository.save(member);\n\n        assertAll(() -> {\n            assertThat(actual.getId()).isNotNull();\n            assertThat(actual.getName()).isEqualTo(\"매트\");\n        });\n    }\n}\n```\n\n`new Member(null, \"매트\")`를 저장하는 테스트이다. `save()`를 따라가보자.\n\n```java\n@Repository\n@Transactional(readOnly = true)\npublic class SimpleJpaRepository<T, ID> implements JpaRepositoryImplementation<T, ID> { \n    // ...\n    @Transactional \n    @Override \n    public <S extends T> S save(S entity) {\n        \n        Assert.notNull(entity, \"Entity must not be null.\");\n        \n        if (entityInformation.isNew(entity)) {\n            em.persist(entity);\n            return entity;\n        } else {\n            return em.merge(entity);\n        }\n    }\n    // ...\n}\n```\n\n로직을 살펴보면 `entityInformation.isNew(entity)`를 통해 해당 `entity`가 `new`인지 확인한다.\n * `entityInformation.isNew(entity)`가 `true`이면 `em.persist(entity)`한다.\n * `entityInformation.isNew(entity)`가 `false`이면 `em.merge(entity)`한다.\n\n그렇다면 `isNew()`는 어떻게 새로운 `entity`인지 확인할까? 구현 코드를 살펴보자.\n\n```java\npublic class JpaMetamodelEntityInformation<T, ID> extends JpaEntityInformationSupport<T, ID> {\n    // ...\n    @Override\n    public boolean isNew(T entity) {\n\n        if (!versionAttribute.isPresent()\n                || versionAttribute.map(Attribute::getJavaType).map(Class::isPrimitive).orElse(false)) {\n            return super.isNew(entity);\n        }\n\n        BeanWrapper wrapper = new DirectFieldAccessFallbackBeanWrapper(entity);\n\n        return versionAttribute.map(it -> wrapper.getPropertyValue(it.getName()) == null).orElse(true);\n    }\n    // ...\n}\n```\n\n`JpaMetamodelEntityInformation`는 JPA Metamodel을 사용하여 도메인 클래스의 id 필드를 찾는 `org.springframework.data.repository.core.EntityInformation` 구현체이다. 해당 클래스의 `isNew()`를 살펴보면 `super.isNew(entity)`을 호출하고 있다.\n\n```java\npublic abstract class AbstractEntityInformation<T, ID> implements EntityInformation<T, ID> {\n    // ...\n    public boolean isNew(T entity) {\n\n        ID id = getId(entity);\n        Class<ID> idType = getIdType();\n\n        if (!idType.isPrimitive()) {\n            return id == null;\n        }\n\n        if (id instanceof Number) {\n            return ((Number) id).longValue() == 0L;\n        }\n\n        throw new IllegalArgumentException(String.format(\"Unsupported primitive id type %s\", idType));\n    }\n    // ...\n}\n```\n\n`AbstractEntityInformation`는 `EntityInformation`의 구현을 위한 기본 클래스이다. `getId(Object)`가 null을 반환하거나 식별자가 `Java primitive`이고 `getId(Object)`가 0을 반환할 때마다 새로운 엔티티로 간주한다.\n\n먼저 `getId()`를 통해 제네릭으로 명시한 `ID`를 반환한다.\n\n```java\npublic class JpaMetamodelEntityInformation<T, ID> extends JpaEntityInformationSupport<T, ID> {\n    // ...\n    @Override\n    @Nullable\n    @SuppressWarnings(\"unchecked\")\n    public ID getId(T entity) {\n\n        // check if this is a proxy. If so use Proxy mechanics to access the id.\n        PersistenceProvider persistenceProvider = PersistenceProvider.fromMetamodel(metamodel);\n\n        if (persistenceProvider.shouldUseAccessorFor(entity)) {\n            return (ID) persistenceProvider.getIdentifierFrom(entity);\n        }\n\n        // if not a proxy use Spring mechanics to access the id.\n        BeanWrapper entityWrapper = new DirectFieldAccessFallbackBeanWrapper(entity);\n\n        if (idMetadata.hasSimpleId()) {\n            // 실제 반환하는 부분\n            return (ID) entityWrapper.getPropertyValue(idMetadata.getSimpleIdAttribute().getName());\n        }\n\n        BeanWrapper idWrapper = new IdentifierDerivingDirectFieldAccessFallbackBeanWrapper(idMetadata.getType(), metamodel);\n        boolean partialIdValueFound = false;\n\n        for (SingularAttribute<? super T, ?> attribute : idMetadata) {\n            Object propertyValue = entityWrapper.getPropertyValue(attribute.getName());\n\n            if (propertyValue != null) {\n                partialIdValueFound = true;\n            }\n\n            idWrapper.setPropertyValue(attribute.getName(), propertyValue);\n        }\n\n        return partialIdValueFound ? (ID) idWrapper.getWrappedInstance() : null;\n    }\n    // ...\n}\n```\n\n실제 디버깅을 진행해보면 `idMetadata.hasSimpleId()`를 통해 simpleId 유무를 확인하고 `(ID)`를 통해 명시한 타입으로 변환하고 있다. `Java primitive type`인 경우 제네릭으로 표현할 수 없기 때문에 그에 해당하는 `Wrapper Class`으로 변환하는 것으로 추측한다.\n\n정리하면 `save()` 시점에 `isNew()` 내부에 `getId(Object)`가 null을 반환하거나 식별자가 `Java primitive`이고 `getId(Object)`가 0을 반환할 때마다 새로운 엔티티로 간주한다. 새로운 엔티티로 간주된 것은 `em.persist(entity)`를 통해 처리된다.\n\n이 밖에도 새로운 엔티티를 식별하는 방법은 여러가지가 있다. `@Version`를 활용한 방법, 엔티티 클래스에 `Persistable<ID>` 인터페이스를 구현하는 것 등이 있다. 자세한 구현 방법은 따로 다루지 않겠다. \n\n### [번외] 엔티티 id, primitive type vs Wrapper Class\n\n`Wrapper Class`는 객체이므로 `null` 대입이 가능하다. 반면 primitive type은 null을 대입할 수 없다. \n실제 hibernate 공식 문서를 살펴보면 `Wrapper Class`를 추천하고 있다.\n\n> We recommend that you declare consistently-named identifier attributes on persistent classes and that you use a nullable (i.e., non-primitive) type.\n> \n> 영속 클래스에는 일관되게 명명된 식별자 속성을 선언하고 null 가능한(즉, 원시가 아닌) 유형을 사용하는 것이 좋다.\n\n## persist() vs merge()\n\n지금 까지 `isNew()`를 통해 내부적으로 어떻게 새로운 엔티티로 간주하는지 알아보았다. 새로운 엔티티로 간주된 것과 아닌 것의 `save()` 로직에 대해 살펴보자. `persist()`는 Member 데이터를 기반으로 `insert`를 호출한다.\n\n```java\n@DataJpaTest\n@DisplayNameGeneration(DisplayNameGenerator.ReplaceUnderscores.class)\nclass MemberRepositoryTest {\n    // ...\n    @Test\n    @Rollback(value = false)\n    void 식별자가_없는_member를_저장한다() {\n        Member member = new Member(null, \"매트\");\n\n        Member actual = memberRepository.save(member);\n\n        assertAll(() -> {\n            assertThat(actual.getId()).isNotNull();\n            assertThat(actual.getName()).isEqualTo(\"매트\");\n        });\n    }\n    // ...\n}\n```\n\n * `Rollback(value = false)`: 롤백하지 않고 insert하여 실행되는 쿼리를 확인한다.\n\n```\nHibernate: insert into member (name, id) values (?, ?)\n```\n\n다음은 임의의 식별자를 명시한 뒤 `save()`한다.\n\n```java\n@DataJpaTest\n@DisplayNameGeneration(DisplayNameGenerator.ReplaceUnderscores.class)\nclass MemberRepositoryTest {\n    // ...\n    @Test\n    @Rollback(value = false)\n    void 식별자를_1로_지정한_member를_저장한다() {\n        Member member = new Member(1L, \"매트\");\n\n        Member actual = memberRepository.save(member);\n\n        assertAll(() -> {\n            assertThat(actual.getId()).isNotNull();\n            assertThat(actual.getName()).isEqualTo(\"매트\");\n        });\n    }\n    // ...\n}\n```\n\n위와 같이 준영속 상태에서 저장할 경우 `merge()`가 발생한다. `merge()`는 `select`를 통해 엔티티가 존재하는지 확인한 뒤 없으면 `insert`를 진행한다.\n\n```\nHibernate: select member0_.id as id1_0_0_, member0_.name as name2_0_0_ from member member0_ where member0_.id=?\nHibernate: insert into member (name, id) values (?, ?)\n```\n\n## 정리\n\n지금까지 `SimpleJpaRepository`의 `save()`를 통해 `persist()`와 `merge()`의 차이에 대해 알아보았다. `save()`는 `isNew()` 통해 새로운 엔티티인지를 판별한다. 예를들어 `Long`을 활용할 경우 `null`이거나 `0L`일 때 `true`를 반환하게 된다.\n\n그 밖에도 다양한 방식을 통해 새로운 엔티티로 인식될 수 있다. 핵심은 `merge()`로 인식될 되기 이전에 엔티티는 영속성 컨텍스트에서 관리되지 않는 준영속 상태이기 때문에 `Dirty Checking`과 같은 이점을 활용할 수 없다. 이것을 잘 고려하여 엔티티의 id를 설정해야 한다.\n\n## References.\n\n[Spring Data JPA](https://spring.io/projects/spring-data-jpa) <br>\n김영한 지음, 『자바 ORM 표준 JPA 프로그래밍』, 에이콘(2015), p115.\n"},{"excerpt":"OSIV OSIV는 Open Session In View의 준말로, 영속성 컨텍스트를 뷰까지 열어둔다는 것을 의미이다. 영속성 컨텍스트가 유지된다는 의미는 뷰에서도 과 같이 영속성 컨텍스트의 이점을 누릴 수 있다는 것이다. 요청 당 트랜잭션 OSIV의 핵심은 뷰에서도 이 가능하도록 하는 것이다. 가장 단순한 방법은 요청이 들어오자 마자  혹은 를 거치는 …","fields":{"slug":"/osiv/"},"frontmatter":{"date":"October 24, 2022","title":"OSIV와 사용하며 직면한 문제","tags":["우아한테크코스","OSIV","JPA"]},"rawMarkdownBody":"\n## OSIV\n\nOSIV는 Open Session In View의 준말로, 영속성 컨텍스트를 뷰까지 열어둔다는 것을 의미이다. 영속성 컨텍스트가 유지된다는 의미는 뷰에서도 `Lazy Loading`과 같이 영속성 컨텍스트의 이점을 누릴 수 있다는 것이다.\n\n## 요청 당 트랜잭션\n\nOSIV의 핵심은 뷰에서도 `Lazy Loading`이 가능하도록 하는 것이다. 가장 단순한 방법은 요청이 들어오자 마자 `Filter` 혹은 `Interceptor`를 거치는 시점에 `트랜잭션을 시작`하고 요청이 끝날 때 `트랜잭션을 종료`하는 것이다. 이것을 `요청 당 트랜잭션 방식`의 `OSIV`라 하며 초창기에 사용되던 방식이다. 이것을 그림으로 표현하면 아래와 같다.\n\n![](./1.png)\n\n그림을 살펴보면 요청부터 응답까지 영속성 컨텍스트의 생존 범위가 늘어나게 된다. 이제 뷰에서도 `Lazy Loading`을 진행할 수 있지만 몇 가지 단점을 가지고 있다. \n\n먼저 뷰에서도 엔티티의 수정이 가능해진다. 영속성 컨텍스트의 범위가 늘어나기 때문에 뷰에서 엔티티의 수정이 일어나면 `Dirty Checking` 과정을 통해 응답 시점에, 즉 트랜잭션이 끝나는 시점에 데이터베이스에 반영된다.\n\n뷰에서 데이터를 수정하는 것의 가장 큰 문제는 데이터의 변경 지점을 찾기 어렵게 만든다는 것이다. 비즈니스 로직이 담긴 서비스 계층에서 데이터를 수정한 뒤 영속하는 것은 당연한 것 처럼 받아들일 수 있다. 보통 서비스 계층에서 로직을 시작할 때 `@Transactional` 애노테이션을 통해 선언적 트랜잭션을 명시한 후 비즈니스 로직을 수행한다. 하지만 뷰에서의 엔티티 속성 변경으로 데이터베이스에 영속되는 것은 우리가 뷰에게 원하는 방향은 아니다.\n\n또한 데이터베이스 관련 로직이 필요하지 않은 부분에도 `불필요하게 데이터베이스 커넥션이 활용`될 수 있다. 요청 당 트랜잭션은 요청과 동시에 데이터베이스 커넥션을 커넥션 풀에서 획득한다. 결국 트랜잭션이 끝나는 응답 시점까지 데이터베이스 커넥션을 물고 있는 것이다. 해당 로직 내에서 데이터베이스와 관련된 로직이 처리되지 않는다면 `불필요한 커넥션 자원을 낭비`하고 있는 것과 다름 없다.\n\n## 비즈니스 계층 트랜잭션\n\n요청과 동시에 트랜잭션을 획득하는 요청 당 트랜잭션은 많은 단점을 가지고 있다. 스프링에서는 이러한 단점을 개선하기 위해 비즈니스 계층 트랜잭션을 제공하고 있다.\n\n### OpenSessionInViewFilter\n\n```java\npackage org.springframework.orm.hibernate5.support;\n...\npublic class OpenSessionInViewFilter extends OncePerRequestFilter {\n    ...\n}\n```\n\n하이버네이트 OSIV 서블릿 필터이다. OpenSessionViewFilter는 필터 내에 Session을 오픈 하지만 트랜잭션은 시작하지 않는다. 트랜잭션을 시작하지 않기 때문에 실제 데이터베이스의 커넥션을 획득하지 않는다. Session은 생성되기 때문에 `영속성 컨텍스트만 생성`된다.\n\n### OpenSessionInViewInterceptor\n\n```java\npackage org.springframework.orm.hibernate5.support;\n...\npublic class OpenSessionInViewInterceptor implements AsyncWebRequestInterceptor {\n    ...\n}\n```\n\n하이버네이트 OSIV 스프링 인터셉터이다. Filter와 동일하게 Interceptor에서 Session은 오픈 하지만 트랜잭션은 시작하지 않는다.\n\n### OpenEntityManagerInViewFilter\n\n```java\npackage org.springframework.orm.jpa.support;\n...\npublic class OpenEntityManagerInViewFilter extends OncePerRequestFilter {\n    ...\n}\n```\n\nJPA에서 제공하는 OSIV 서블릿 필터이다.\n\n### OpenEntityManagerInViewInterceptor\n\n```java\npackage org.springframework.orm.jpa.support;\n...\npublic class OpenEntityManagerInViewInterceptor extends EntityManagerFactoryAccessor implements AsyncWebRequestInterceptor {\n    ...\n}\n```\n\nJPA에서 제공하는 OSIV 스프링 인터셉터이다. \n\n이제 위 객체들을 필요에 따라 필터 혹은 인터셉터에 등록하여 사용하면 된다. \n\n스프링 부트는 `application properties` 설정 중 `spring.jpa.open-in-view`을 통해 지정이 가능하다. \n\n```yaml\nspring:\n    jpa:\n        open-in-view: true\n```\n\n아래는 스프링 부트에서 OSIV 관련 설정을 자동으로 해주는 `JpaWebConfiguration`이다. \n\n```java\n@Configuration(proxyBeanMethods = false)\n@EnableConfigurationProperties(JpaProperties.class)\npublic abstract class JpaBaseConfiguration implements BeanFactoryAware {\n  ...\n  @Configuration(proxyBeanMethods = false)\n\t@ConditionalOnWebApplication(type = Type.SERVLET)\n\t@ConditionalOnClass(WebMvcConfigurer.class)\n\t@ConditionalOnMissingBean({ OpenEntityManagerInViewInterceptor.class, OpenEntityManagerInViewFilter.class })\n\t@ConditionalOnMissingFilterBean(OpenEntityManagerInViewFilter.class)\n\t@ConditionalOnProperty(prefix = \"spring.jpa\", name = \"open-in-view\", havingValue = \"true\", matchIfMissing = true)\n\tprotected static class JpaWebConfiguration {\n\n\t\tprivate static final Log logger = LogFactory.getLog(JpaWebConfiguration.class);\n\n\t\tprivate final JpaProperties jpaProperties;\n\n\t\tprotected JpaWebConfiguration(JpaProperties jpaProperties) {\n\t\t\tthis.jpaProperties = jpaProperties;\n\t\t}\n\n\t\t@Bean\n\t\tpublic OpenEntityManagerInViewInterceptor openEntityManagerInViewInterceptor() {\n\t\t\tif (this.jpaProperties.getOpenInView() == null) {\n\t\t\t\tlogger.warn(\"spring.jpa.open-in-view is enabled by default. \"\n\t\t\t\t\t\t+ \"Therefore, database queries may be performed during view \"\n\t\t\t\t\t\t+ \"rendering. Explicitly configure spring.jpa.open-in-view to disable this warning\");\n\t\t\t}\n\t\t\treturn new OpenEntityManagerInViewInterceptor();\n\t\t}\n\n\t\t@Bean\n\t\tpublic WebMvcConfigurer openEntityManagerInViewInterceptorConfigurer(\n\t\t\t\tOpenEntityManagerInViewInterceptor interceptor) {\n\t\t\treturn new WebMvcConfigurer() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void addInterceptors(InterceptorRegistry registry) {\n\t\t\t\t\tregistry.addWebRequestInterceptor(interceptor);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n}\n```\n\n- `ConditionalOnProperty`: Property의 조건에 따라 작동하는 `Bean`이다. application.yml에 있는 값을 기준으로 Bean을 생성한다.\n\n간단히 코드를 살펴보면 `OpenEntityManagerInViewInterceptor`를 빈으로 등록하는 것을 확인할 수 있다. 자세한 동작 과정은 추후 살펴보려한다.\n\n무튼 스프링에서 제공하는 OSIV를 사용하면 트랜잭션의 범위를 비즈니스 계층으로 좁힐 수 있다. 그림으로 표현하면 아래와 같다.\n\n![](./2.png)\n\n요청이 들어오면 OSIV 설정 정보에 따라 필터 혹은 인터셉터에서 `영속성 컨텍스트`를 생성한다. 여기서 중요한 것은 트랜잭션을 시작하지 않는다는 것이다. \n\n그렇다면 트랜잭션은 언제 시작할까? 바로 서비스 계층에서 `@Transactional`을 마주할 때 미리 생성한 영속성 컨텍스트를 기반으로 시작한다.\n\n그 다음 서비스 계층에서 모든 트랜잭션이 마무리되면 트랜잭션을 커밋한다. 단 `영속성 컨텍스트`는 지속된다. 영속성 컨텍스트는 OSIV로 지정한 범위까지 유지된다. 이때 영속성 컨텍스트를 종료하지만 `flush()`는 호출되지 않는다.\n\n정리하면 아래와 같다.\n\n- 영속성 컨텍스트가 트랜잭션 범위 내에 있으면 엔티티를 `조회`하고 `수정`할 수 있다.\n- 영속성 컨텍스트가 트랜잭션 범위 밖에 위치하면 엔티티 `조회`만 가능하다. 즉 `Lazy Loading`이 가능하다는 것을 의미한다.\n\n## OSIV를 사용하며 직면한 문제\n\n`@Transational` 애노테이션을 사용할 때 `영속성 컨텍스트`를 가져와 트랜잭션 처리를 위해 `데이터베이스 커넥션을 획득`한다. \n\nOSIV는 트랜잭션이 끝나도 영속성 컨텍스트를 유지하고 있다. 즉 트랜잭션 범위 외에도 `엔티티 조회`가 가능하다. 이것이 의미하는 바는 데이터베이스 커넥션을 계속 붙들고 있다는 것을 의미한다. 그림으로 표현하면 아래와 같다.\n\n![](./3.png)\n\nOSIV는 뷰에서 영속성 컨텍스트를 유연하게 활용할 수 있어서 다양한 이점을 누릴 수 있다. 다만 `Interceptor`이후 동작하는 `ArgumentResolver`에서 트랜잭션을 활용할 경우 성능 상에 문제가 발생할 수 있다.\n\n아래는 Spring MVC를 간소화한 그림이다.\n\n![](./4.png)\n\n`ArgumentResolver`를 등록하면 핸들러로 들어온 데이터를 추가 가공하는 등의 `전처리 작업`을 진행할 수 있다. 보통 회원의 존재 여부와 같이 인증이 필요한 부분에 공통적으로 활용할 수 있는데, 이때 회원이 존재하는지 확인하기 위해 `데이터베이스`를 필요로 하는 경우 문제가 발생할 수 있다.\n\n가령 아래와 같은 `ArgumentResolver`가 있다고 가정한다.\n\n```java\n@Component\npublic class AuthenticationPrincipalArgumentResolver implements HandlerMethodArgumentResolver {\n\n    private final AuthService authService;\n\n    public AuthenticationPrincipalArgumentResolver(final AuthService authService) {\n        this.authService = authService;\n    }\n\n    @Override\n    public boolean supportsParameter(final MethodParameter parameter) {\n        return parameter.hasParameterAnnotation(AuthenticationPrincipal.class);\n    }\n\n    @Override\n    public Object resolveArgument(final MethodParameter parameter, final ModelAndViewContainer mavContainer,\n                                  final NativeWebRequest webRequest, final WebDataBinderFactory binderFactory) {\n        HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class);\n        String accessToken = AuthorizationExtractor.extract(request);\n        Long id = authService.extractMemberId(accessToken);\n        return new LoginMember(id);\n    }\n}\n```\n\n`@AuthenticationPrincipal` 애노테이션이 붙은 매개변수를 채우기 이전에 `authService.extractMemberId(accessToken)`을  통해 회원의 정보를 추출하고 있다. 해당 메서드 내부에서는 데이터베이스 트랜잭션을 통해 회원 정보를 조회하고 있다.\n\n```java\n@Transactional(readOnly = true)\n@Service\npublic class AuthService {\n    ...\n    public Long extractMemberId(final String accessToken) {\n        Long memberId = tokenCreator.extractPayload(accessToken);\n        memberRepository.validateExistsById(memberId);\n        return memberId;\n    }\n}\n```\n\n`extractMemberId()` 메서드는 `@Transactional(readOnly = true)`을 통해 읽기 전용으로 트랜잭션을 활용하고 있다.\n\n그렇다면 이러한 상황에서 어떠한 문제가 발생할까? OSIV는 `트랜잭션 시작 시점`에 `데이터베이스 커넥션을 획득`한다. 즉 `ArgumentResolver`에서 회원 검증을 위한 조회 로직을 수행하는 시점에 데이터베이스 커넥션을 획득한다는 것이다. 이것을 다시 한 번 그림으로 살펴보자.\n\n![](./5.png)\n\n한 번 획득한 `데이터베이스 커넥션`은 OSIV 설정으로 인해 지정 범위까지 유지된다. 즉 트랜잭션 범위 내에서만 데이터베이스 커넥션이 유지되는 것이 아니라 `요청 중 최초`에 지정된 커넥션을 재사용하기 때문에 오랜시간 동안 커넥션 자원을 사용하는 것이다.\n\n보통 데이터베이스와 연결을 위한 커넥션 자원을 비싼 비용을 가지고 있다. 이것을 절약하기 위해 커넥션 풀에 일정 개수의 커넥션을 생성한 뒤 재사용하는 방식을 활용하곤 한다. 결국 커넥션은 `한정된 자원`이다. 오랜시간 커넥션을 물고 있다는 것은 `병목`이 발생할 가능성이 커진다는 것을 의미한다. 다수의 요청이 발생할 경우 커넥션을 획득하지 못한 요청은 `대기`하게 될 것이다. 모든 케이스에 해당하는 것은 아니지만 실시간 트래픽이 중요한 애플리케이션의 경우 커넥션의 개수가 부족하여 장애로 이어질 수 있다.\n\n## 정리\n\nOSIV는 영속성 컨텍스트의 생존 범위를 늘려주어 엔티티 `Lazy Loading`과 같은 다양한 이점을 누릴 수 있다. 스프링을 사용할 경우 OSIV를 비즈니스 계층 트랜잭션으로 활용하여 보다 더 안정적으로 영속성 컨텍스트를 활용할 수 있다.\n\n하지만 이러한 이점을 누리기 위해서는 오랜시간 데이터베이스 커넥션을 활용해야 한다. 실시간 트래픽이 주가 되는 애플리케이션의 경우 한정된 커넥션 개수가 부족하여 장애로 이어질 수 있음을 염두해 두어야 한다.\n\n## References.\n\n[OpenEntityManagerInViewInterceptor](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/orm/jpa/support/OpenEntityManagerInViewInterceptor.html)<br/>\n김영한 지음, 『자바 ORM 표준 JPA 프로그래밍』, 에이콘(2015), p593-607.\n"},{"excerpt":"커버링 인덱스 MySQL 8.0 이상, InnoDB 스토리지 엔진을 기준으로 작성되었다. 인덱스를 사용하여 처리하는 쿼리 중 가장 큰 부하를 차지하는 부분은 어디일까? 바로 인덱스 검색에서 일치하는 키 값의 이다. 그림을 살펴보면 인덱스 검색에서 일치하는 키 값을 데이터 파일에서 읽을 때 비교적 느린 속도를 가진 디스크 I/O가 발생한다.  N개의 인덱스…","fields":{"slug":"/covering-index/"},"frontmatter":{"date":"October 10, 2022","title":"커버링 인덱스","tags":["우아한테크코스","커버링 인덱스"]},"rawMarkdownBody":"\n## 커버링 인덱스\n\n> MySQL 8.0 이상, InnoDB 스토리지 엔진을 기준으로 작성되었다.\n\n인덱스를 사용하여 처리하는 쿼리 중 가장 큰 부하를 차지하는 부분은 어디일까? 바로 인덱스 검색에서 일치하는 키 값의 `레코드를 읽는 것`이다.\n\n그림을 살펴보면 인덱스 검색에서 일치하는 키 값을 데이터 파일에서 읽을 때 비교적 느린 속도를 가진 디스크 I/O가 발생한다.\n\n![](./image-1.png)\n\nN개의 인덱스 검색 시 최악의 경우 N번의 디스크 I/O가 발생할 수 있다. \n\n이것을 커버링 인덱스를 활용하여 개선할 수 있다. 커버링 인덱스는 데이터 파일을 읽지 않고 인덱스만 읽어 불필요한 디스크 I/O를 줄일 수 있다.\n\n먼저 간단한 예제를 위한 crew 테이블이다. 데이터는 대략 `100만건`을 기준으로 한다.\n\n```sql\nCREATE TABLE crew (\n    id INT NOT NULL AUTO_INCREMENT,\n    nickname VARCHAR(20) NOT NULL,\n    track VARCHAR(20) NOT NULL,\n    year INT NOT NULL,\n    CONSTRAINT pk_crew_id PRIMARY KEY (id)  \n);\n```\n\n- `id`: 고유 식별자\n- `nickname`: 닉네임\n- `track`: 진행 중인 track (e.g. FRONTEND, BACKEND 등)\n- `year`: 기수 (e.g. 1기, 2기 등)\n\n## 인덱스 설정\n\ncrew 테이블에서 닉네임이 `a ~ d` 사이이며 `BACKEND` 트랙을 진행 중인 크루를 조회한다고 가정한다. 쿼리로 표현하면 아래와 같다.\n\n```sql\nSELECT * \nFROM crew \nWHERE nickname BETWEEN 'a' AND 'd' AND track = 'BACKEND';   \n```\n\n위 쿼리에 인덱스를 적용하기 위해 `nickname`과 `track`으로 복합 인덱스를 설정한다.\n\n```sql\nALTER TABLE crew ADD INDEX idx_crew_nickname_track (nickname, track);   \n```\n\n이제 실행 계획을 살펴보자.\n\n```sql\nmysql> EXPLAIN SELECT * FROM crew WHERE nickname BETWEEN 'a' AND 'd' AND track = 'BACKEND';\n+----+-------------+-------+------------+------+-------------------------+------+---------+------+--------+----------+-------------+    \n| id | select_type | table | partitions | type | possible_keys           | key  | key_len | ref  | rows   | filtered | Extra       |    \n+----+-------------+-------+------------+------+-------------------------+------+---------+------+--------+----------+-------------+    \n|  1 | SIMPLE      | crew  | NULL       | ALL  | idx_crew_nickname_track | NULL | NULL    | NULL | 997049 |     3.70 | Using where |    \n+----+-------------+-------+------------+------+-------------------------+------+---------+------+--------+----------+-------------+    \n```\n\n`*`를 활용하여 모든 칼럼을 조회할 경우 옵티마이저는 인덱스를 활용하여 레코드를 읽는 것 보다 데이터 파일을 바로 읽는 것이 더욱 빠르다고 판단하여 `풀 테이블 스캔(ALL)`을 진행한 것을 확인할 수 있다.\n\n> 인덱스를 통해 레코드를 읽는 것 > 데이터 파일을 바로 읽는 것 (비용 측면)\n> \n\n## 커버링 인덱스 활용\n\n이제 `커버링 인덱스` 활용을 위해 모든 칼럼을 조회(`*`)하는 쿼리에서 `nickname`과 `track` 칼럼을 활용하여 조회하는 방식으로 개선한다.\n\n```sql\nSELECT nickname, track \nFROM crew \nWHERE nickname BETWEEN 'a' AND 'd' AND track = 'BACKEND';   \n```\n\n다시 실행 계획을 살펴보자.\n\n```sql\nmysql> EXPLAIN SELECT nickname, track FROM crew WHERE nickname BETWEEN 'a' AND 'd' AND track = 'BACKEND';\n+----+-------------+-------+------------+-------+-------------------------+-------------------------+---------+------+--------+----------+--------------------------+   \n| id | select_type | table | partitions | type  | possible_keys           | key                     | key_len | ref  | rows   | filtered | Extra                    |   \n+----+-------------+-------+------------+-------+-------------------------+-------------------------+---------+------+--------+----------+--------------------------+   \n|  1 | SIMPLE      | crew  | NULL       | range | idx_crew_nickname_track | idx_crew_nickname_track | 164     | NULL | 368652 |    10.00 | Using where; Using index |   \n+----+-------------+-------+------------+-------+-------------------------+-------------------------+---------+------+--------+----------+--------------------------+   \n```\n\n`type`을 살펴보면 `Index Range Scan`이 발생한 것을 볼 수 있다. 또한 추가적으로 확인해야 할 부분이 있는데, `Extra` 칼럼의 `Using index`이다. 커버링 인덱스를 타게 되면 `Extra` 칼럼에 `Using index`가 표시되는 것을 확인할 수 있다.\n\n## 조회  속도 비교\n\n이제 `모든 칼럼을 조회하는 쿼리`와 `커버링 인덱스가 가능한 쿼리`의 조회 속도를 비교해보자. 테이블에는 100만건의 데이터가 있다.\n\n먼저 모든 칼럼의 조회 속도이다.\n\n```sql\nSELECT *\nFROM crew \nWHERE nickname BETWEEN 'a' AND 'd' AND track = 'BACKEND';   \n\n+----------+---------+\n| nickname | track   |\n+----------+---------+\n| a0002ccc | BACKEND |\n| a000319e | BACKEND |\n| a00058f1 | BACKEND |\n| ...      | ...     |\n| cfffd6f4 | BACKEND |\n| cfffdb4a | BACKEND |\n| cffffbb2 | BACKEND |\n+----------+---------+\n93617 rows in set (3.04 sec)\n```\n\n다음은 커버링 인덱스로 개선한 조회 쿼리이다.\n\n```sql\nSELECT nickname, track \nFROM crew \nWHERE nickname BETWEEN 'a' AND 'd' AND track = 'BACKEND';   \n\n+----------+---------+\n| nickname | track   |\n+----------+---------+\n| a0002ccc | BACKEND |\n| a000319e | BACKEND |\n| a00058f1 | BACKEND |\n| ...      | ...     |\n| cfffd6f4 | BACKEND |\n| cfffdb4a | BACKEND |\n| cffffbb2 | BACKEND |\n+----------+---------+  \n93617 rows in set (0.54 sec)\n```\n\n`3.04 sec → 0.54 sec` 로 조회 성능이 개선된 것을 확인할 수 있다. 100만건 보다 많은 데이터가 있다면 보다 더 유의미한 차이가 날 것이라 기대한다.\n\n## 커버링 인덱스의 숨겨진 비밀\n\n커버링 인덱스에는 한 가지 비밀이 더 숨겨져 있다. 만약 `프라이머리 키`인 `id`를 함께 조회하는 이 쿼리는 어떤 인덱스를 탈까?\n\n```sql\nSELECT id, nickname, track \nFROM crew \nWHERE nickname BETWEEN 'a' AND 'd' AND track = 'BACKEND';   \n```\n\n실행 계획을 살펴보자.\n\n```sql\nmysql> EXPLAIN SELECT id, nickname, track FROM crew WHERE nickname BETWEEN 'a' AND 'd' AND track = 'BACKEND';\n+----+-------------+-------+------------+-------+-------------------------+-------------------------+---------+------+--------+----------+--------------------------+   \n| id | select_type | table | partitions | type  | possible_keys           | key                     | key_len | ref  | rows   | filtered | Extra                    |   \n+----+-------------+-------+------------+-------+-------------------------+-------------------------+---------+------+--------+----------+--------------------------+   \n|  1 | SIMPLE      | crew  | NULL       | range | idx_crew_nickname_track | idx_crew_nickname_track | 164     | NULL | 368652 |    10.00 | Using where; Using index |   \n+----+-------------+-------+------------+-------+-------------------------+-------------------------+---------+------+--------+----------+--------------------------+   \n```\n\n앞선 예시와 동일하게 커버링 인덱스를 타는 것을 확인할 수 있다. `프라이머리 키`는 `복합 인덱스`로 설정하지 않았는데 왜 같은 결과가 나올까?\n\n그에 대한 해답은 `InnoDB`의 `세컨더리 인덱스`의 특수한 구조 덕분이다. 세컨더리 인덱스의 리프 노드는 실제 레코드의 주소를 가지고 있는 것이 아닌, 클러스터드 인덱스가 걸린 프라이머리 키를 주소로 가지고 있다.\n\n![](./image-2.png)\n\n그렇기 때문에 이 프라이머리 키를 포함한 조회 쿼리도 충분히 커버링 인덱스로 활용이 가능하다.\n\n## References.\n\n백은빈, 이성욱, 『Real MySQL 8.0』, 위키북스(2021), p476 ~ 479\n"},{"excerpt":"우아한테크코스 미션 중 Spring의 을 직접 구현해보며 순수한 JDBC만 사용했을 때 들을 분리하며 리팩토링하는 과정을 경험하였다. 미션을 진행하며 실제 Spring의 JdbcTemplate 내부 코드를 살펴보았는데, 특정한 패턴을 가진 코드가 반복되는 것을 확인할 수 있었다. 간단한 예제를 통해 Spring은 반복된 코드를 어떻게 개선 하였는지 알아보…","fields":{"slug":"/template-callback/"},"frontmatter":{"date":"October 09, 2022","title":"jdbcTemplate을 만들며 마주한 Template Callback 패턴","tags":["우아한테크코스","Spring","jdbcTempate","Template Callback 패턴"]},"rawMarkdownBody":"\n우아한테크코스 미션 중 Spring의 `JdbcTemplate`을 직접 구현해보며 순수한 JDBC만 사용했을 때 `중복되는 로직`들을 분리하며 리팩토링하는 과정을 경험하였다.\n\n미션을 진행하며 실제 Spring의 JdbcTemplate 내부 코드를 살펴보았는데, 특정한 패턴을 가진 코드가 반복되는 것을 확인할 수 있었다. 간단한 예제를 통해 Spring은 반복된 코드를 어떻게 개선 하였는지 알아보려 한다.\n\n구현 코드는 [jwp-dashboard-jdbc](https://github.com/hyeonic/jwp-dashboard-jdbc/tree/step1)에서 확인할 수 있다.\n\n## 데이터베이스와 통신하기\n\nJava에서 데이터베이스와 통신하기 위해서는 아래와 같은 과정이 필요하다.\n\n * 커넥션을 연결한다.\n * SQL을 전달한다.\n * 응답을 확인한다.\n\n이러한 과정은 JDBC API를 통해 적절히 추상화 되어 있다. 자세한 내용은 [JDBC](https://hyeonic.github.io/jdbc)에 정리해두었다. 적절한 `추상화` 덕분에 우리는 어떤 데이터베이스를 사용하는지 신경 쓰지 않고 비즈니스 로직에 집중할 수 있게 되었다.\n\n자 이제 JDBC API를 사용하여 User를 추가하는 간단한 로직을 작성해보자.\n\n```java\npublic class UserDao {\n\n    private final DataSource dataSource;\n    \n    public UserDao(final DataSource dataSource) {\n        this.dataSource = dataSource;\n    }\n\n    public void insert(final User user) {\n        var sql = \"INSERT INTO users (account, password, email) VALUES (?, ?, ?)\";\n        try (var connection = dataSource.getConnection();\n             var preparedStatement = connection.prepareStatement(sql)) {\n\n            preparedStatement.setString(1, user.getAccount());\n            preparedStatement.setString(2, user.getPassword());\n            preparedStatement.setString(3, user.getEmail());\n\n            preparedStatement.executeUpdate();\n        } catch (final SQLException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n```\n\njava 7에 등장한 `try-with-resources`도 활용해보고, connection 생성을 위해 DataSource를 생성하는 방식도 외부에서 주입 받도록 설정하였다. 여기서 User 삭제하기 위한 `delete` 메서드가 추가된다고 가정하자.\n\n```java\npublic class UserDao {\n\n    private final DataSource dataSource;\n    \n    public UserDao(final DataSource dataSource) {\n        this.dataSource = dataSource;\n    }\n\n    public void insert(final User user) {\n        var sql = \"INSERT INTO users (account, password, email) VALUES (?, ?, ?)\";\n        try (var connection = dataSource.getConnection();\n             var preparedStatement = connection.prepareStatement(sql)) {\n\n            preparedStatement.setString(1, user.getAccount());\n            preparedStatement.setString(2, user.getPassword());\n            preparedStatement.setString(3, user.getEmail());\n\n            preparedStatement.executeUpdate();\n        } catch (final SQLException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public void delete(final Long id) {\n        var sql = \"DELETE FROM user WHERE id = ?\";\n        try (var connection = dataSource.getConnection();\n             var prepareStatement = connection.prepareStatement(sql)) {\n\n            prepareStatement.setLong(1, id);\n\n            prepareStatement.executeUpdate();\n        } catch (SQLException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n```\n\n슬슬 중복되는 코드가 눈에 보이기 시작한다. 또한 커넥션을 획득하기 위한 `getConnection()`나 `prepareStatement()` 등은 `Checked Exception`인 `SQLException`을 catch 하도록 강제하고 있다.\n\n중복되는 로직은 메서드 분리를 통해 개선하면 그만이다. 하지만 가장 큰 문제는 따로 있다. 우리가 `UserDao`에게 가지길 원하는 책임은 User를 저장하고, 삭제하고, 조회하는 등의 데이터 관리 측면에 가깝다. 하지만 위 코드는 데이터베이스에게 커넥션을 획득하고, 쿼리를 전송하는 등 `관심사 밖의 로직`까지 포함하고 있다.\n\n만약 이러한 Dao가 늘어나면 어떻게 될까? 각각의 Dao는 자신의 `비즈니스 로직`과 `데이터베이스 통신을 위한 로직`들을 반복해서 작성해야 할 것이다. \n\n## JdbcTemplate\n\n`JdbcTemplate`은 `org.springframework.jdbc.core` 패키지의 중심 클래스이다. 리소스 생성 및 해제를 처리하므로 커넥션을 닫는 것을 잊어버리는 등의 일반적인 오류를 방지할 수 있다. \n\nJdbcTemplate은 아래와 같은 일을 담당한다.\n\n * SQL 쿼리를 실행한다.\n * statement 및 stored procedure를 호출을 업데이트한다.\n * ResultSet 인스턴스에 대한 반복 및 반환된 매개 변수 값을 추출을 수행한다.\n * JDBC 예외를 catch하고 `org.springframework.dao`에 정의된 일반적이고 보다 유익한 예외 계층을 반환한다.\n\n단순히 JDBC를 사용하는 것 보다 중복되는 데이터베이스와 관련된 로직을 대신 처리해주며 비즈니스 로직에 집중할 수 있게 만들어준다. 자세한 내용은 [3.3.1. Using JdbcTemplate](https://docs.spring.io/spring-framework/docs/current/reference/html/data-access.html#jdbc-JdbcTemplate)을 살펴보자.\n\n자 이제 이러한 장점을 잘 기억해두고 간단한 버전의 JdbcTemplate을 만들어보자. 먼저 데이터베이스와의 통신 과정을 UserDao에서 분리한다.\n\n> 직접 만든 JdbcTemplate의 메서드 시그니처는 실제 Spring JdbcTemplate을 참고하였다. \n\n```java\npublic class CustomJdbcTemplate {\n    private final DataSource dataSource;\n\n    public CustomJdbcTemplate(final DataSource dataSource) {\n        this.dataSource = dataSource;\n    }\n\n    public <T> List<T> query(final String sql, final RowMapper<T> rowMapper) {\n        try (var connection = dataSource.getConnection();\n             var preparedStatement = connection.prepareStatement(sql)) {\n            var resultSet = preparedStatement.executeQuery();\n            return toRows(rowMapper, resultSet);\n        } catch (final SQLException e) {\n            throw new DataAccessException(e);\n        }\n    }\n\n    public <T> T queryForObject(final String sql, final RowMapper<T> rowMapper, Object... args) {\n        try (var connection = dataSource.getConnection();\n             var preparedStatement = connection.prepareStatement(sql)) {\n            setParams(preparedStatement, args);\n            var resultSet = preparedStatement.executeQuery();\n            return DataAccessUtils.singleResult(toRows(rowMapper, resultSet));\n        } catch (final SQLException e) {\n            throw new DataAccessException(e);\n        }\n    }\n\n    private <T> List<T> toRows(final RowMapper<T> rowMapper, final ResultSet resultSet) throws SQLException {\n        var rows = new ArrayList<T>();\n        while (resultSet.next()) {\n            rows.add(rowMapper.mapRow(resultSet));\n        }\n        return rows;\n    }\n\n    public void update(final String sql, final Object... args) {\n        try (var connection = dataSource.getConnection();\n             var preparedStatement = connection.prepareStatement(sql)) {\n            setParams(preparedStatement, args);\n            preparedStatement.executeUpdate();\n        } catch (final SQLException e) {\n            throw new DataAccessException(e);\n        }\n    }\n\n    private void setParams(final PreparedStatement preparedStatement, final Object... args) throws SQLException {\n        for (int i = 0; i < args.length; i++) {\n            preparedStatement.setObject(i + 1, args[i]);\n        }\n    }\n}\n```\n\nJdbcTemplate에 데이터베이스 통신과 관련된 로직을 모두 이동시켰다. 덕분에 `UserDao`는 SQL 쿼리 작성한 진행하면 데이터베이스에서 조회한 값을 적절히 반환할 수 있게 되었다.\n\n```java\npackage com.techcourse.dao;\n\n// 전부 제거된 JDBC 관련 의존성\nimport com.techcourse.domain.User;\nimport nextstep.jdbc.core.JdbcTemplate;\nimport nextstep.jdbc.core.RowMapper;\n\npublic class UserDao {\n    ...\n    private final JdbcTemplate jdbcTemplate;\n\n    public UserDao(final JdbcTemplate jdbcTemplate) {\n        this.jdbcTemplate = jdbcTemplate;\n    }\n\n    public void insert(final User user) {\n        var sql = \"INSERT INTO users (account, password, email) VALUES (?, ?, ?)\";\n        jdbcTemplate.update(sql, user.getAccount(), user.getPassword(), user.getEmail());\n    }\n\n    public void update(final User user) {\n        var sql = \"UPDATE users SET account = ?, password = ?, email = ? WHERE id = ?\";\n        jdbcTemplate.update(sql, user.getAccount(), user.getPassword(), user.getEmail(), user.getId());\n    }\n    ...\n}\n```\n\n많이 개선되었지만 아직 문제가 남아있다. `CustomJdbcTemplate`을 살펴보면 각 메서드가 데이터베이스 커넥션과 통신하기 위해 매번 열고 닫고를 반복하고 있다. \n\n## 템플릿 콜백 패턴\n\n`템플릿 콜백 패턴`은 메서드를 통해 전략을 주입 받은 형태이다. `전략 패턴`의 한 종류라고 볼 수 있다. `전략 패턴`에서 핵심은 `변하는 부분`과 `변하지 않는 부분`을 잘 구분하고, 변하는 부분을 전략으로 추출해야 한다.\n\n위 로직에서 `변하는 부분(중복되는 부분)`과 `변하지 않는 부분(중복되지 않는 부분)`은 어디일까? 바로 아래와 같다.\n\n```java\npublic class CustomJdbcTemplate {\n    ...\n    public <T> List<T> query(final String sql, final RowMapper<T> rowMapper) {\n        try (var connection = dataSource.getConnection();                   // 변하지 않는 부분     \n             var preparedStatement = connection.prepareStatement(sql)) {    // 변하지 않는 부분     \n            var resultSet = preparedStatement.executeQuery();               // 변하는 부분          \n            return toRows(rowMapper, resultSet);                            // 변하는 부분          \n        } catch (final SQLException e) {                                    // 변하지 않는 부분     \n            throw new DataAccessException(e);                               // 변하지 않는 부분     \n        }                                                               \n    }\n    ...\n}\n```\n\n> `템플릿`: 변하지 않는 부분에 해당한다. <br>\n> `콜백`: 다른 코드의 매개변수로 넘겨주는 실행 가능한 코드를 말한다. 콜백을 넘겨받는 메서드는 필요에 따라 적절히 활용한다. Java에는 객체 없이 메서드를 독립적으로 관리할 수 없다. Java 8 이후에는 람다를 활용하여 콜백 함수를 정의하곤 한다.\n\n> 템플릿 콜백 패턴은 GOF의 디자인 패턴은 아니다. 스프링 내부에서 자주 사용하여 이렇게 부른다. 간단히 생각하면 전략 패턴을 메서드 실행 시점에 주입한 형태라고 생각하면 된다. 스프링 내부에서 XxxTemplate의 형태가 있다면 템플릿 콜백 패턴을 활용했다고 보면 된다.\n\n`템플릿 콜백 패턴`도 동일하다. 변화되는 부분을 독립된 클래스, 익명 내부 클래스, 람다를 활용하여 `메서드 실행 시점에 주입`하는 형태이다. 말로하면 너무 장황하니 바로 코드로 살펴보자.\n\n먼저 반복되는, 변하지 않는 부분을 메서드로 추출한다.\n\n```java\npublic class CustomJdbcTemplate {\n    ...\n    private <T> T execute(final String sql, final PreparedStatementCallback<T> action) {\n        try (var connection = dataSource.getConnection();\n             var preparedStatement = connection.prepareStatement(sql)) {\n            return action.doInPreparedStatement(preparedStatement);\n        } catch (final SQLException e) {\n            throw new DataAccessException(e);\n        }\n    }\n}\n```\n\n핵심은 `PreparedStatementCallback<T> action`이다. Java는 객체 없이 독립적인 메서드를 생성할 수 없기 때문에 함수형 인터페이스를 활용한다.\n\n```java\n@FunctionalInterface\npublic interface PreparedStatementCallback<T> {\n\n    T doInPreparedStatement(final PreparedStatement preparedStatement) throws SQLException, DataAccessException;\n}\n```\n\n이제 `execute()` 메서드 실행 시점에 필요한 행위을 구현하여 매개변수로 넘겨준다. \n\n```java\npublic class CustomJdbcTemplate {\n    ...\n   public <T> List<T> query(final String sql, final RowMapper<T> rowMapper) {\n        return execute(sql, preparedStatement -> {\n            var resultSet = preparedStatement.executeQuery();\n            return toRows(rowMapper, resultSet);\n        });\n    }\n\n    public <T> T queryForObject(final String sql, final RowMapper<T> rowMapper, Object... args) {\n        return execute(sql, preparedStatement -> {\n            setParams(preparedStatement, args);\n            var resultSet = preparedStatement.executeQuery();\n            return DataAccessUtils.singleResult(toRows(rowMapper, resultSet));\n        });\n    }\n    ...\n}\n```\n\n이제 각각의 메서드는 `변하는 부분`만을 가지고 있다. 이렇게 변하는 부분은 `람다`를 통해 적절히 구현한 뒤 전달하는 형태로 개선할 수 있다.\n\n## 정리\n\n간단한 예제를 통해 Spring은 어떠한 방식으로 `JdbcTemplate`을 구성 했는지에 대해 알아보았다. 이전에는 단순히 사용하는데 급급했지만 직접 만들어보며 라이브러리의 의도를 보다 더 명확하게 파악할 수 있었다.\n\n코드가 중복된다는 것은 중복되는 코드에 변화가 생길 때 영향의 범위가 커진다는 것을 의미한다. 즉 이러한 중복의 범위를 줄여야 한다. \n\n템플릿 콜백 패턴은 `변하는 부분`을 함수형 인터페이스로 분리하여 매개 변수로 전달 받는다. 덕분에 `변하지 않는 부분`은 중복되지 않고 재사용하여 개선할 수 있다.\n\n### References.\n[jwp-dashboard-jdbc](https://github.com/hyeonic/jwp-dashboard-jdbc/tree/step1)<br>\n[JdbcTemplate](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/jdbc/core/JdbcTemplate.html)<br>\n[3.3.1. Using JdbcTemplate](https://docs.spring.io/spring-framework/docs/current/reference/html/data-access.html#jdbc-JdbcTemplate)<br>\n[스프링 핵심 원리 - 고급편](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B3%A0%EA%B8%89%ED%8E%B8)\n"},{"excerpt":"는 Java 프로그래밍 언어에서 을 제공한다. 를 사용하면 관계형 데이터베이스에서 스프레드 시트 및 플랫 파일에 이르기까지 거의 모든 데이터 소스에 접근할 수 있다. JDBC 기술은 tools와 alternate interfaces를 구축할 수 있는 common base를 제공한다. 특정 DBMS에서 JDBC API를 사용하려면 JDBC 기술과 데이터베이…","fields":{"slug":"/jdbc/"},"frontmatter":{"date":"October 08, 2022","title":"JDBC","tags":["우아한테크코스","JDBC"]},"rawMarkdownBody":"\n`JDBC (Java Database Connectivity) API`는 Java 프로그래밍 언어에서 `범용 데이터 접근`을 제공한다. `JDBC API`를 사용하면 관계형 데이터베이스에서 스프레드 시트 및 플랫 파일에 이르기까지 거의 모든 데이터 소스에 접근할 수 있다. JDBC 기술은 tools와 alternate interfaces를 구축할 수 있는 common base를 제공한다.\n\n특정 DBMS에서 JDBC API를 사용하려면 JDBC 기술과 데이터베이스 사이를 중재하는 JDBC 기술 기반의 드라이버가 필요하다. 다양한 요인에 따라 드라이버는 순전히 Java 프로그래밍 언어 또는 Java 프로그래밍 언어와 JNI (Java Native Interface) 네이티브 메서드가 혼합된 형태로 작성될 수 있다. \n\n## 왜 등장하게 되었을까?\n\n애플리케이션 개발을 위해서는 데이터를 활용해야 한다. 이러한 데이터는 적절한 저장소에서 안전하게 관리되어야 한다. 이것을 보통 데이터베이스에 보관한다.\n\n클라이언트는 애플리케이션의 서버를 통해 데이터를 조작한다. 애플리케이션 서버는 이러한 데이터를 적절히 관리하기 위해 아래 과정을 거치며 데이터베이스와 통신한다.\n\n- 커넥션을 연결한다.\n- SQL을 전달한다.\n- 결과 응답을 확인한다.\n\n데이터베이스의 종류는 수십가지이다. 각각의 데이터베이스는 커넥션을 연결하고, SQL을 전달하고 응답을 확인하는 방법이 각기 다르다. 이러한 문제를 해결하기 위해 JDBC라는 `표준`이 등장 하게 되었다. 우리는 구현체에 신경 쓰지 않고 JDBC에 명세된 표준 API에 의존하여 애플리케이션 서버를 구축하면 된다.\n\n물론 인터페이스만으로 애플리케이션이 동작하지 않는다. 해당 인터페이스를 적절히 구현한 구현체가 필요하다. 보통 이러한 구현체는 각 데이터베이스 회사에서 구현한 라이브러리로 제공된다. 이것을 JDBC 드라이버라 한다. 우리가 MySQL에 접근하기 위해서 gradle에 `runtimeOnly 'mysql:mysql-connector-java'`을 추가한 경험이 있을 것이다. 이 라이브러리 내부에는 JDBC의 표준 인터페이스가 적절히 `구현`되어 제공된다.\n\n## 표준의 이점은 무엇일까?\n\nJava는 이렇게 인터페이스를 통한 표준을 적절히 제공해주고 있다. 이것의 장점은 표준을 통해 구현된 구현체를 직접적으로 의존하지 않고 개발을 진행할 수 있다. \n\n표준을 통해 인터페이스만 의존하면 구현체는 손 쉽게 `변경`할 수 있을 것이다. 이것은 결국 객체지향 관점에서 인터페이스를 통한 `느슨한 결합`을 통해 유연하게 의존 객체를 변경할 수 있다는 것을 의미한다.\n\n## Driver와 Datasource\n\n### Driver\n\n```java\npublic interface Driver {\n\n    Connection connect(String url, java.util.Properties info)\n        throws SQLException;\n\n    boolean acceptsURL(String url) throws SQLException;\n\n    DriverPropertyInfo[] getPropertyInfo(String url, java.util.Properties info)\n                         throws SQLException;\n\n    int getMajorVersion();\n\n    int getMinorVersion();\n\n    boolean jdbcCompliant();\n\n    public Logger getParentLogger() throws SQLFeatureNotSupportedException;\n}\n```\n\n모든 Driver 클래스에서 구현해야 하는 인터페이스이다. Java SQL 프레임워크는 여러 데이터베이스 드라이버를 허용한다. 각 드라이버는 드라이버 인터페이스를 구현한 클래스를 제공해야 한다. DirverManager는 찾을 수 있는 드라이버를 로드 하기 위해 시도하고, 주어진 connection 요청에 대해 각 드라이버에게 대상 URL에 연결을 시도하도록 차례로 요청한다.\n\n```java\nclass DriverManagerTest {\n\n    private static final String H2_URL = \"jdbc:h2:./test\";\n    private static final String USER = \"sa\";\n    private static final String PASSWORD = \"\";\n\n    @Test\n    void driverManager() throws SQLException {\n        try (final Connection connection = DriverManager.getConnection(H2_URL, USER, PASSWORD)) {\n            assertThat(connection.isValid(1)).isTrue();\n        }\n    }\n```\n\nJDBC는 `java.sql.Connection` 표준 인터페이스를 정의한다. 각 데이터베이스 벤더사들은 그에 맞는 구현체를 구현한다. \n\n`DriverManager`는 라이브러리로 등록된 드라이버 목록을 `자동`으로 인식한다. `getConnection()` 메서드를 실행하는 시점에 등록된 `Connection` 구현체를 반환하게 된다.\n\n### DataSource\n\n데이터베이스 커넥션을 획득하기 위해서는 DriverManager를 통해 복잡한 과정을 거쳐야만 가능하다. 커넥션을 획득하는 것은 단순해보이지만 굉장히 `비싼 비용`을 가지고 있다.\n\n- 데이터베이스와 TCP/IP 통신을 진행한 뒤 커넥션을 연결한다.\n- 연결된 커넥션으로 ID, PASSWORD 등을 데이터베이스에 전달한다.\n- 인증이 완료되면 데이터베이스 세션을 생성한다.\n- 커넥션 생성이 완료되면 응답한다.\n- 응답 받은 드라이버는 커넥션 객체를 생성하여 반환한다.\n\n보통 비싼 생성 비용을 가진 커넥션 객체는 미리 `생성`한 뒤 `재사용` 하는 방식으로 개선한다. 이것을 `데이터베이스 커넥션 풀`이라 한다.\n\n`커넥션 풀`에 속한 커넥션은 데이터베이스와 `항상 연결된 상태`를 유지한다. 사용자는 SQL 요청을 위해 매번 커넥션을 연결하는 것이 아니라 커넥션 풀에서 `유휴 상태의 커넥션`을 꺼내 사용한 뒤 적절히 `반납`한다. 여기서 반납한다는 것은 커넥션을 종료하는 것이 아니라 다시 `커넥션 풀로 반환`한다는 의미이다.\n\n`DriverManager`를 활용한 커넥션 생성은 매 `요청 마다 새롭게 생성하는 구조`를 가진다. `DataSource`는 이러한 단점을 극복하기 위해 `커넥션 획득 방법`을 적절히 `추상화`하였다.\n\n```java\npublic interface DataSource  extends CommonDataSource, Wrapper {\n\n  Connection getConnection() throws SQLException;\n\n  Connection getConnection(String username, String password)\n    throws SQLException;\n\n  @Override\n  java.io.PrintWriter getLogWriter() throws SQLException;\n\n  @Override\n  void setLogWriter(java.io.PrintWriter out) throws SQLException;\n\n  @Override\n  void setLoginTimeout(int seconds) throws SQLException;\n\n  @Override\n  int getLoginTimeout() throws SQLException;\n\n  default ConnectionBuilder createConnectionBuilder() throws SQLException {\n        throw new SQLFeatureNotSupportedException(\"createConnectionBuilder not implemented\");\n  };\n\n}\n```\n\nDataSource 인터페이스는 각 데이터베이스 벤더사에 의해 구현된다. 구현에는 세 가지 유형을 가지고 있다.\n\n- `Basic implementation`: 표준 Connection 객체를 생성한다.\n- `Connection Pooling implementation`: connection pooling에 자동으로 참여하는 Connection 객체를 생성한다. 이 구현은 중간 계층 connection pooling manager와 함께 동작한다.\n- `Distributed transaction implementation`: 분산 트랜잭션에 사용할 수 있는 Connection 객체를 생성하고 거의 항상 connection pooling에 참여한다. 이 구현은 중간 계층의 트랜잭션 manger와 함께 작동하며 거의 항상 connection pooling manager와 함께 작동한다.\n\nDataSource 객체를 통해 접근하는 드라이버는 DriverManger에 등록되지 않는다. 대신 조회 작업을 통해 DataSource 객체를 검색한 다음 Connection 객체를 만드는 데 사용된다. 기본 구현의 경우 DataSource 객체를 통해 얻은 연결은 DriverManger를 통해 얻은 연결과 동일하다.\n\n```java\nclass DataSourceTest {\n\n    private static final String H2_URL = \"jdbc:h2:./test\";\n    private static final String USER = \"sa\";\n    private static final String PASSWORD = \"\";\n\n    @Test\n    void dataSource() throws SQLException {\n        final JdbcDataSource dataSource = new JdbcDataSource();\n        dataSource.setURL(H2_URL);\n        dataSource.setUser(USER);\n        dataSource.setPassword(PASSWORD);\n\n        try (final var connection = dataSource.getConnection()) {\n            assertThat(connection.isValid(1)).isTrue();\n        }\n    }\n}\n```\n\nDataSource는 데이터베이스 연결을 위한 정보를 생성과 동시에 설정할 수 있다. DriverManager 처럼 connection을 연결할 때 마다 정보를 전달할 필요가 없다. 덕분에 한 번 세팅 해두면 dataSource를 의존한 객체는 편리하게 connection을 가져다 쓸 수 있다.\n\n또한 커넥션 풀을 구현한 `DataSource` 구현체를 활용할 수 있다. 아래는 h2 드라이버에 구현된 `JdbcConnectionPool`이다.\n\n```java\npackage org.h2.jdbcx;\n\npublic final class JdbcConnectionPool\n        implements DataSource, ConnectionEventListener, JdbcConnectionPoolBackwardsCompat {\n    ...\n    @Override\n    public Connection getConnection() throws SQLException {\n        ... \n    }\n}\n```\n\n정리하면 `DataSource`는 다양한 구현체를 사용하여 `커넥션 풀을 구성`하고, 인터페이스를 통한 객체간의 `느슨한 결합`을 유지할 수 있다.\n\n- 느슨한 결합은 데이터베이스를 쉽게 전환할 수 있도록 도와준다.\n- Connection을 만드는 것은 많은 비용을 소모한다. 대부분의 데이터베이스는 이것을 개선하기 위해 커넥션 풀을 제공한다.\n\n## Connection\n\n특정 데이터베이스와 connection(session)이다. SQL문이 실행되고 연결 컨텍스트 내에서 결과가 반환된다.\n\nConnection 객체의 데이터베이스는 테이블, 지원되는 SQL 문법, stored procedures, 연결 기능 등을 설명하는 정보를 제공할 수 있다. 이 정보는 `getMetaData()` 메서드를 사용하여 가져온다.\n\n## Statement와 PreparedStatement\n\n두 인터페이스는 모두 `SQL 쿼리 전달`을 위한 역할이다. 내부적으로 `CheckedException`인 `SQLException`을 던지기 때문에 예외에 대한 추가적인 처리를 진행해야 한다.\n\n```java\npublic class SQLException extends java.lang.Exception\n                          implements Iterable<Throwable> {\n\n    ...\n    public SQLException(String reason, String SQLState, int vendorCode) {\n        super(reason);\n        this.SQLState = SQLState;\n        this.vendorCode = vendorCode;\n        if (!(this instanceof SQLWarning)) {\n            if (DriverManager.getLogWriter() != null) {\n                DriverManager.println(\"SQLState(\" + SQLState +\n                                                \") vendor code(\" + vendorCode + \")\");\n                printStackTrace(DriverManager.getLogWriter());\n            }\n        }\n    }\n    ...\n}\n```\n\n### Statement\n\n`Statement` 객체가 생성되면 `executeQuery()` 메서드를 호출하여 SQL문을 실행시킬 수 있다. 메서드의 인수로 SQL문을 담은 `String 객체`를 전달한다. 정적인 쿼리문을 처리할 수 있다. 쿼리문에 값이 미리 입력되어 있어야 한다.\n\n### PreparedStatement\n\nSQL 문장이 미리 컴파일되고 실행 시간동안 인수값을 위한 공간을 확보할 수 있다. `Statement` 객체의 SQL은 실행될 때 마다 서버에서 분석해야 하는 반면, `PreparedStatement` 객체는 한 번 분석되면 `재사용` 하여 효율적으로 사용할 수 있다. \n\n각각의 인수에 대해 `place holder`를 사용하여 SQL 문장을 정의할 수 있다. 동일한 SQL문을 특정 값만 바꿔 여러 번 실행해야 할 때 혹은 인수가 많아서 SQL 문을 정리해야 할 때 유용하다.\n\n## ResultSet\n\n일반적으로 데이터베이스 쿼리문을 실행하여 생성되는 데이터베이스 결과 집합을 나타내기 위한 데이터 테이블이다. \n\nResultSet 객체는 현재 데이터 행을 가리키는 커서를 유지한다. 처음에 커서는 첫 번째 행 앞에 배치된다. `next()` 메서드는 커서를 다음 행으로 옮기고 ResultSet 객체에 행이 더 이상 없을 때 false를 반환하므로 결과 집합을 반복하는 while loop에서 사용할 수 있다.\n\n기본 `ResultSet` 객체는 업데이트할 수 없으며 앞으로만 이동하는 커서만 존재한다. 따라서 첫 번째 행부터 마지막 행까지 한 번만 반복할 수 있다. \n\n## SQLException은 왜 Checked Exception일까?\n\n`DataSource`를 활용하여 `Connection`, `Statement`, `ResultSet`과 같은 객체를 사용하다 보면 대부분 `SQLException`을 던지는 것을 확인할 수 있다. \n\n생길 수 있는 예외를 명시하는 것은 개발자가 해당 객체를 사용할 때 인지할 수 있는 좋은 수단이 된다. 다만 `SQLException`의 경우 `Exception` 클래스를 상속한 `Checked Exception`이기 때문에 컴파일 시점에 예외 핸들링을 강제한다.\n\n때문에 객체를 사용할 때 마다 반복적인 `try-catch-finally`로 자원을 해제 시켜야 한다. 그나마 Java 7 이후에는 `try-with-resources`가 등장 했기 때문에 전보다는 깔끔한 코드를 작성할 수 있게 되었다\n\n```java\npackage nextstep.jdbc.core;\n\n...\n\npublic class JdbcTemplate {\n    ...\n    private <T> T execute(final String sql, final PreparedStatementCallback<T> action) {\n        try (var connection = dataSource.getConnection();\n             var preparedStatement = connection.prepareStatement(sql)) {\n            return action.doInPreparedStatement(preparedStatement);\n        } catch (final SQLException e) {\n            throw new DataAccessException(e);\n        }\n    }\n}\n```\n\n`Effective Java 아이템 70 - 복구할 수 있는 상황에는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 사용하라`에 따르면 `Checked Exception`이 적절한 상황은 `호출한 쪽에서 복구하리라 여겨지는 상황이라면 Checked Exception을 사용하라`고 명시되어 있다.\n\n만약 `Connection` 객체 연결 실패로 `SQLException`이 발생 했다고 가정해보자. 과연 개발자는 `catch`에서 어떠한 복구 전략을 떠올릴 수 있을까? 이미 실패한 연결을 다시 요청해야 할까? 그렇다고 예외를 무시하는 것은 바람직하지 못하다. 결국 보다 더 유의미한 예외로 포장하여 다시 전파할 뿐이다.\n\n이러나 저러나 `Checked Exception`은 개발자에게 처리를 강제하는 것은 여전하다. 아무래도 외부 서버와의 통신을 진행하면 예측할 수 없기 때문에 이러한 `처리를 강제`하는 취지에서 등장 하지 않았을까 판단한다. \n\n## References.\n\n[https://all-record.tistory.com/79](https://all-record.tistory.com/79)<br>\n[https://docs.oracle.com/javase/8/docs/api/java/sql/DriverManager.html](https://docs.oracle.com/javase/8/docs/api/java/sql/DriverManager.html)<br>\n[https://docs.oracle.com/javase/8/docs/api/javax/sql/DataSource.html](https://docs.oracle.com/javase/8/docs/api/javax/sql/DataSource.html)<br>\n[스프링 DB 1편 - 데이터 접근 핵심 원리](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-db-1#)<br>\n조슈아 블로크 지음, 개앞맴시(이복연) 옮김, 『이펙티브 자바』, 프로그래밍 인사이트(2020), p390-392.\n"},{"excerpt":"현재 우아한테크코스에서는  미션을 진행하고 있다. 지금까지 를 활용하여 기본적으로 적용되던 이었지만 어떠한 목적으로 등장 했으며, 무엇을 제공해주는지 알지 못한채 웹 애플리케이션 개발을 위해서만 사용하곤 했다. 직접 Tomcat을 만들어가는 미션을 시작한 만큼 이번 기회를 통해 에 대해 간단히 정리해보려 한다. 해당 게시글은 Tomcat 9.x.x 버전을…","fields":{"slug":"/basic-tomcat/"},"frontmatter":{"date":"September 03, 2022","title":"Tomcat","tags":["우아한테크코스","Tomcat","Java EE","Jakarta EE","Web Container"]},"rawMarkdownBody":"\n현재 우아한테크코스에서는 `Tomcat 구현하기` 미션을 진행하고 있다. 지금까지 `Spring Boot`를 활용하여 기본적으로 적용되던 `Tomcat`이었지만 어떠한 목적으로 등장 했으며, 무엇을 제공해주는지 알지 못한채 웹 애플리케이션 개발을 위해서만 사용하곤 했다. 직접 Tomcat을 만들어가는 미션을 시작한 만큼 이번 기회를 통해 `Tomcat`에 대해 간단히 정리해보려 한다.\n\n> 해당 게시글은 Tomcat 9.x.x 버전을 기준으로 작성 되었습니다.\n\n## Tomcat 이란?\n\n`Tomcat`은 `Server`이다. `Server`란 사전적 의미로 네트워크에서 다른 컴퓨터 및 소프트웨어와 같은 클라이언트에게 `서비스`를 `제공`하는 주체이다. 그렇다면 `Tomcat`은 클라이언트에게 어떤 것을 `제공`해주기 위한 `Server`일까?\n\n## Java Enterprise Edition (Java EE)\n\n`Java`로 분산 애플리케이션 개발을 목적으로 만들었다. Enterprise 애플리케이션을 개발 및 실행 하기 위한 기술과 환경을 제공하며 Servlet, JSP, EJB, JDBC 등 `Server`를 개발하기 위해 필요한 기술들의 `스펙`을 모아둔 것이다. \n\n이러한 명세가 모여 하나의 Java EE가 정의되면 해당 명세를 기반으로 구현한 것을 `WAS (Web Application Server)`라 부른다. 대표적으로 GlassFish, JBoss와 같은 제품들이 존재한다.\n\n이 밖에도 모바일 환경에 필요한 컴포넌트를 모아둔 `Java Micro Edition`, 표준 환경(Desktop Application)에서 제공하기 위한 `Standard Edition`이 있다.\n\n> 이클립스 재단으로 이관된 Java EE의 공식 명칭은 Jakarta EE로 변경 되었다. 자세한 내용은 [Java EE에서 Jakarta EE로의 전환](https://www.samsungsds.com/kr/insights/java_jakarta.html)에서 확인해볼 수 있다.\n\nTomcat 9.x.x 까지는 `Java EE`의 명세를 따라간다. Tomcat 10.x.x 버전 이후 부터 `Jakarta EE`를 기반으로 진행되고 있다. 실제 [Tomcat github](https://github.com/apache/tomcat)에 들어가보면 아래와 같이 구성되어 있는 것을 확인할 수 있다.\n\n**Tomcat 9.0.x**\n\n![](./tomcat9.png)\n \n**Tomcat 10.0.x**\n\n![](./tomcat10.png)\n\n## Java EE 서버의 Container\n\n![](./java-ee-containers.png)\n\n위 그림은 클라이언트와 Java EE 서버가 통신하는 구조를 보여 준다. `Web Contatiner`는 웹 브라우저에서 HTTP를 통해 들어온 요청에 대한 처리를 담당한다. `EJB Contatiner`는 `Web Contatiner` 혹은 직접적인 통신으로 들어온 요청에 대한 `비즈니스 로직`을 수행한다. \n\n단순한 `Application 클라이언트`의 경우 HTTP가 아닌 다른 방식을 활용하여 Java EE 서버의 `EJB Container`를 통해 비즈니스 로직을 수행할 수 있다. 하지만 `웹 브라우저 클라이언트`의 경우엔 다르다. 오직 HTTP 통신을 위한 `Web Container`를 거쳐야만 `EJB Container`의 비즈니스 로직을 수행할 수 있다.\n\n이러한 `Container`에는 `Servlet`, `JSP`와 같은 다양한 컴포넌트로 구성되어 있다. 이러한 Java EE의 서버 내부는 컴포넌트를 묶은 `Container`로 구분할 수 있다.\n\n아래는 Java EE 7의 Architecture Diagram이다.\n\n![](./java-ee-7-architecture.png)\n\n> 각 Container의 컴포넌트가 궁금하다면 Java EE Architecture diagram, Jakarta Architecture diagram와 같은 키워드로 검색 시 확인할 수 있다. [Architecture](https://jakarta.ee/specifications/platform/8/platform-spec-8.html#architecture)\n\n## Web Container\n\n그렇다면 도대체 `Java EE`와 `Tomcat`은 어떤 관련이 있는 걸까? 앞서 언급한 것처럼 Java EE 스펙을 구현한 것을 `WAS`라고 부른다. 대부분 Tomcat을 검색 해보면 대표적인 `WAS`로 소개되곤 한다.\n\n사실 `Tomcat`은 온전한 `WAS`라고 볼 수 없다. `Tomcat`은 오로지 `Java EE Container` 중 `Web Container`만을 구현하였기 때문이다.\n\n![](./web-container.png)\n\n그렇기 때문에 `Web Container`을 구현한 `Tomcat`은 `HTTP` 통신에 대한 요청만 처리할 수 있다.\n\n# Tomcat Version\n\n아래는 `Tomcat`의 버전 별 `Web Container`에 속한 `컴포넌트의 명세 버전`을 가져온 것이다.\n\n![](./tomcat-version.png)\n\n`Tomcat 9.0.x`의 경우 `Servlet 4.0`, `JSP 2.3`, `WebSocket 1.1` 등을 지원하고 있는 것을 확인할 수 있다. 또한 `Java 8` 이후를 사용해야 동작 가능 하다.\n\n# 정리\n\n지금까지 `Tomcat`과 `Java EE`에 대해 간단히 알아보았다. 우리가 지금까지 알고 있던 `WAS`와는 다르게 `Tomcat`은 오직 `Java EE`의 `Web Container`만을 구현하고 있다. \n\n다시 한번 질문에 대한 답변을 정리해보려 한다. `Tomcat`은 클라이언트에게 어떤 것을 `제공`해주기 위한 `Server`일까? `Tomcat`은 `Web Container` 스펙의 `구현`이며, `HTTP`에 대한 요청을 처리할 수 있는 `Server`이다.\n\n## References.\n\n[Java EE에서 Jakarta EE로의 전환](https://www.samsungsds.com/kr/insights/java_jakarta.html)<br>\n[Java EE Clients](https://docs.oracle.com/cd/E19575-01/819-3669/bnabc/index.html)<br>\n[Architecture](https://jakarta.ee/specifications/platform/8/platform-spec-8.html#architecture)<br>\n[Apache Tomcat Versions](https://tomcat.apache.org/whichversion.html)\n"},{"excerpt":"@MappedSuperclass 부모 클래스를 상속 받는 자식 클래스에게 매핑 정보만 제공할 때 사용한다. 즉, 단순히 으로만 사용하기 때문에 추상 클래스 처럼 사용할 수 있다. 특징으로는 아래와 같다. 테이블과 직접적인 매핑 없이 자식 클래스가 매핑 정보를 상속하기 위해 사용한다. 해당 클래스는 직접 생성하여 사용할 일이 없기 때문에 추상 클래스를 권장…","fields":{"slug":"/mappedsuperclass-vs-embedded/"},"frontmatter":{"date":"August 22, 2022","title":"@MappedSuperclass vs @Embedded","tags":["우아한테크코스","상속","조합","MappedSuperclass","Embedded"]},"rawMarkdownBody":"\n## @MappedSuperclass\n\n부모 클래스를 상속 받는 자식 클래스에게 매핑 정보만 제공할 때 사용한다. 즉, 단순히 `매핑 정보를 상속할 목적`으로만 사용하기 때문에 추상 클래스 처럼 사용할 수 있다. 특징으로는 아래와 같다.\n\n * 테이블과 직접적인 매핑 없이 자식 클래스가 매핑 정보를 상속하기 위해 사용한다.\n * 해당 클래스는 직접 생성하여 사용할 일이 없기 때문에 추상 클래스를 권장한다.\n\n정리하면 테이블과 관계 없이 단순히 엔티티가 공통으로 사용하는 `매핑 정보를 모아주는 역할`을 담당한다. \n\n## @Embedded\n\n새로운 값 타입을 직접 정의해서 사용할 수 있다. JPA에서는 이것을 임베디드 타입이라고 한다. 보다 더 객체지향적인 코드 작성을 위해 사용할 수 있다. 해당 애노테이션을 활용하면 객체의 책임에 대한 `응집도`를 높일 수 있으며, 코드가 더욱 명확해질 것이다. 특징으로는 아래와 같다.\n\n * `@Embeddable`: 값 타입을 정의하는 곳에 표시\n * `@Embedded`: 값 타입을 사용하는 곳에 표시\n    * 둘 중 하나는 생략 가능\n * 기본 생성자 필수\n * 임베디드 타입을 포함한 모든 값 타입은 엔티티의 생명주기에 의존한다. 즉 `Composition 관계`와 가깝게 그려진다.\n\n이러한 임베디드 타입은 단순히 엔티티의 값으로 표현되기 대문에 해당 값이 속한 엔티티 테이블에 매핑된다. 이러한 임베디드 타입 덕분에 객체와 테이블을 아주 세밀하게 조작하고 매핑할 수 있게 되었다. 잘 설계한 ORM 애플리케이션은 매핑한 테이블 수 보다 클래스 수가 더 많아질 것이다.\n\n## @MappedSuperclass vs @Embedded\n\n결국 두 애노테이션 모두 엔티티의 비슷한 속성을 분리하여 효과적으로 관리할 수 있는 공통점이 있다. 이 둘이 가장 큰 차이점은 바로 `상속`을 사용하는 것과 `위임`을 사용하는 것에 대한 차이이다.\n\n아래는 객체가 생성되는 시점에 시간을 기록하기 위한 필드를 각각의 방식으로 작성한 것이다.\n\n### @MappedSuperclass를 활용한 방식\n\n먼저 `@MappedSuperclass`를 활용한 방식이다.\n\n> _간단한 예시를 위해 필드 주입을 활용 하였다._\n\n```java\n@MappedSuperclass\npublic abstract class BaseEntity {\n\n    @Column(name = \"created_at\", nullable = false)\n    private LocalDateTime createdAt = LocalDateTime.now();\n\n    // getter\n}\n```\n\n```java\n@Entity\npublic class MappedSuperclassCrew extends BaseEntity {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    @Column\n    private String name;\n\n    @Column\n    private Integer age;\n\n    @Enumerated(EnumType.STRING)\n    private Track track;\n\n    protected MappedSuperclassCrew() {\n    }\n\n    public MappedSuperclassCrew(final String name, final Integer age, final Track track) {\n        this.name = name;\n        this.age = age;\n        this.track = track;\n    }\n\n    // getter\n}\n```\n\n앞서 언급한 것처럼 `@MappedSuperclass`을 활용하면 추상 클래스를 통해 중복된 필드를 상속 받아 편리하게 활용할 수 있다.\n\n### @Embedded를 활용한 방식\n\n다음은 `@Embedded` 활용한 방식이다.\n\n> _간단한 예시를 위해 필드 주입을 활용 하였다._\n\n```java\n@Embeddable\npublic class TraceDateTime {\n\n    @Column(name = \"created_at\", nullable = false, updatable = false)\n    private LocalDateTime createAt = LocalDateTime.now();\n\n    protected TraceDateTime() {\n    }\n\n    // getter\n}\n```\n\n```java\n@Entity\npublic class EmbeddedCrew {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    @Column\n    private String name;\n\n    @Column\n    private Integer age;\n\n    @Enumerated(EnumType.STRING)\n    private Track track;\n\n    @Embedded\n    private TraceDateTime traceDateTime;\n\n    protected EmbeddedCrew() {\n    }\n\n    public EmbeddedCrew(final String name, final Integer age, final Track track) {\n        this.name = name;\n        this.age = age;\n        this.track = track;\n    }\n\n    // getter\n}\n```\n\n## 정리\n\n결국 단순히 이야기 하면 두 애노테이션의 가장 큰 차이는 `상속`과 `위임`이다. 보다 더 유연한 객체를 다루기 위해 부모 클래스와 의존성이 강하게 엮인 `상속 보단 조합`을 고려하곤 한다. 하지만 위 같은 예시의 경우 단순히 `엔티티의 중복된 필드를 재사용하기 위한 목적`이 크기 때문에 상속을 고려하는 것이 더욱 편리하다. 또한 `@MappedSuperclass`과 `Auditing` 기능을 함께 활용하면 더 편리하게 필드 값을 다룰 수 있을 것이다.\n\n`JPQL`을 활용할 때도 차이가 발생한다.\n\n```java\npublic interface MappedSuperclassCrewRepository extends JpaRepository<MappedSuperclassCrew, Long> {\n\n    @Query(\"SELECT c \" \n            + \"FROM MappedSuperclassCrew c \" \n            + \"WHERE c.createdAt > :dateTime\")\n    List<MappedSuperclassCrew> findByCreatedAtGreaterThan(final LocalDateTime dateTime);\n}\n```\n\n```java\npublic interface EmbeddedCrewRepository extends JpaRepository<EmbeddedCrew, Long> {\n\n    @Query(\"SELECT c \"\n            + \"FROM EmbeddedCrew c \"\n            + \"WHERE c.traceDateTime.createAt > :dateTime\")\n    List<EmbeddedCrewRepository> findByCreatedAtGreaterThan(final LocalDateTime dateTime);\n}\n```\n\n임베디드 타입을 사용할 경우 `c.traceDateTime.createAt`과 같이 필드명을 명시해주어야 한다.\n\n## References.\n\n김영한, 『자바 ORM 표준 JPA 프로그래밍』, 에이콘(2015), p251-254, p321-325. <br>\n[임베디드 타입과 @MappedSuperclass 차이](https://www.inflearn.com/questions/18578)\n"},{"excerpt":"Google은 Refresh Token을 쉽게 내주지 않는다. 우리 달록은 캘린더를 손쉽게 공유할 수 이다. 현재에는 우리 서비스 내에서만 일정이 등록 가능한 상태이다. 추후 확장성을 고려하여 와 연동하기 위해 Google에서 제공하는 token 정보를 관리해야 하는 요구사항이 추가 되었다. code를 활용한 AccessToken 및 IdToken 발급 …","fields":{"slug":"/google-refresh-token/"},"frontmatter":{"date":"August 16, 2022","title":"Google은 Refresh Token을 쉽게 내주지 않는다.","tags":["우아한테크코스","달록","OAuth","OpenId","refresh token"]},"rawMarkdownBody":"\n## Google은 Refresh Token을 쉽게 내주지 않는다.\n\n우리 [달록](https://github.com/woowacourse-teams/2022-dallog)은 캘린더를 손쉽게 공유할 수 `구독형 캘린더 공유 서비스`이다. 현재에는 우리 서비스 내에서만 일정이 등록 가능한 상태이다. 추후 확장성을 고려하여 `Google Calendar API`와 연동하기 위해 Google에서 제공하는 token 정보를 관리해야 하는 요구사항이 추가 되었다.\n\n## code를 활용한 AccessToken 및 IdToken 발급\n\nGoogle은 OAuth 2.0 요청 때 적절한 `scope(e.g. openid)`를 추가하면 `OpenID Connect`를 통해 Google 리소스에 접근 가능한 `Access Token`, AccessToken을 재발급 받기 위한 `Refresh Token`, 회원의 정보가 담긴 `IdToken`을 발급해준다. \n\n`Access Token`의 경우 짧은 만료 시간을 가지고 있기 때문에 google `Access Token` 재발급을 위한 `Refresh Token`을 저장하고 관리해야 한다. `Refresh Token`은 `Access Token`보다 긴 만료 시간을 가지고 있기 때문에 보안에 유의해야 한다. 그렇기 때문에 프론트 측에서 관리하는 것 보다 달록 DB에 저장한 뒤 관리하기로 결정 하였다. 참고로 Google은 보통 아래와 같은 이유가 발생할 때 `Refresh Token`을 만료시킨다고 한다.\n\n[Refresh Token 만료](https://developers.google.com/identity/protocols/oauth2#expiration)\n\n * 사용자가 앱의 액세스 권한을 취소한 경우\n * Refresh Token이 6개월 동안 사용되지 않은 경우\n * 사용자가 비밀번호를 변경했으며 Gmail scope가 포함된 경우\n * 사용자가 계정에 부여된 Refresh Token 한도를 초과한 경우\n * 세션 제어 정책이 적용되는 Google Cloud Platform 조직에 사용자가 속해있는 경우\n\n정리하면 `Refresh Token`은 만료 기간이 비교적 길기 때문에 서버 측에서 안전하게 보관하며 필요할 때 리소스 접근을 위한 `Access Token`을 발급 받는 형태를 구상하게 되었다.\n\n우리 [달록](https://github.com/woowacourse-teams/2022-dallog)은 아래와 같은 형태로 인증이 이루어진다. \n\n![](./oauth-flow.png)\n\n> _달록팀 후디 고마워요!_\n\n프론트 측에서 `OAuth 인증`을 위해서는 달록 서버에서 제공하는 `OAuth 인증을 위한 페이지 uri`을 활용해야 한다. 달록 서버는 해당 uri를 생성하여 전달한다. 로직은 아래 코드로 구현되어 있다.\n\n```java\n@Component\npublic class GoogleOAuthUri implements OAuthUri {\n\n    private final GoogleProperties properties;\n\n    public GoogleOAuthUri(final GoogleProperties properties) {\n        this.properties = properties;\n    }\n\n    @Override\n    public String generate() {\n        return properties.getOAuthEndPoint() + \"?\"\n                + \"client_id=\" + properties.getClientId() + \"&\"\n                + \"redirect_uri=\" + properties.getRedirectUri() + \"&\"\n                + \"response_type=code&\"\n                + \"scope=\" + String.join(\" \", properties.getScopes());\n    }\n}\n```\n\n이제 브라우저에서 해당 uri에 접속하면 아래와 같은 페이지를 확인할 수 있다.\n\n![](./google-oauth-uri.png)\n\n계정을 선택하면 `redirect uri`와 함께 `code` 값이 전달되고, google의 token을 발급 받기 위해 백엔드 서버로 `code` 정보를 전달하게 된다. 아래는 실제 code 정보를 기반으로 google token을 생성한 뒤 `id token`에 명시된 정보를 기반으로 회원을 생성 or 조회한 뒤 `달록 리소스에 접근하기 위한 access token`을 발급해주는 API이다.\n\n```java\n@RequestMapping(\"/api/auth\")\n@RestController\npublic class AuthController {\n\n    private final AuthService authService;\n\n    public AuthController(final AuthService authService) {\n        this.authService = authService;\n    }\n    ...\n    @PostMapping(\"/{oauthProvider}/token\")\n    public ResponseEntity<TokenResponse> generateToken(@PathVariable final String oauthProvider,\n                                                       @RequestBody final TokenRequest tokenRequest) {\n        TokenResponse tokenResponse = authService.generateToken(tokenRequest.getCode());\n        return ResponseEntity.ok(tokenResponse);\n    }\n    ...\n}\n```\n\n * `authService.generateToken(tokenRequest.getCode())`: code 정보를 기반으로 google 토큰 정보를 조회한다. 메서드 내부에서 [code을 액세스 토큰 및 ID 토큰으로 교환](https://developers.google.com/identity/protocols/oauth2/openid-connect#exchangecode)에서 제공된 형식에 맞춰 google에게 code 정보를 전달하고 토큰 정보를 교환한다. \n\n실제 Google에서 토큰 정보를 교환 받는 클라이언트를 담당하는 `GoogleOAuthClient`이다. 핵심은 인가 코드를 기반으로 `GoogleTokenResponse`를 발급 받는 다는 것이다.\n```java\n@Component\npublic class GoogleOAuthClient implements OAuthClient {\n\n    private static final String JWT_DELIMITER = \"\\\\.\";\n\n    private final GoogleProperties properties;\n    private final RestTemplate restTemplate;\n    private final ObjectMapper objectMapper;\n\n    public GoogleOAuthClient(final GoogleProperties properties, final RestTemplateBuilder restTemplateBuilder,\n                             final ObjectMapper objectMapper) {\n        this.properties = properties;\n        this.restTemplate = restTemplateBuilder.build();\n        this.objectMapper = objectMapper;\n    }\n\n    @Override\n    public OAuthMember getOAuthMember(final String code) {\n        // code을 액세스 토큰 및 ID 토큰으로 교환\n        GoogleTokenResponse googleTokenResponse = requestGoogleToken(code);\n        String payload = getPayload(googleTokenResponse.getIdToken());\n        UserInfo userInfo = parseUserInfo(payload);\n\n        String refreshToken = googleTokenResponse.getRefreshToken();\n        return new OAuthMember(userInfo.getEmail(), userInfo.getName(), userInfo.getPicture(), refreshToken);\n    }\n\n    private GoogleTokenResponse requestGoogleToken(final String code) {\n        HttpHeaders headers = new HttpHeaders();\n        headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);\n        MultiValueMap<String, String> params = generateTokenParams(code);\n\n        HttpEntity<MultiValueMap<String, String>> request = new HttpEntity<>(params, headers);\n        return fetchGoogleToken(request).getBody();\n    }\n\n    private MultiValueMap<String, String> generateTokenParams(final String code) {\n        MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n        params.add(\"client_id\", properties.getClientId());\n        params.add(\"client_secret\", properties.getClientSecret());\n        params.add(\"code\", code);\n        params.add(\"grant_type\", \"authorization_code\");\n        params.add(\"redirect_uri\", properties.getRedirectUri());\n        return params;\n    }\n\n    private ResponseEntity<GoogleTokenResponse> fetchGoogleToken(\n            final HttpEntity<MultiValueMap<String, String>> request) {\n        try {\n            return restTemplate.postForEntity(properties.getTokenUri(), request, GoogleTokenResponse.class);\n        } catch (RestClientException e) {\n            throw new OAuthException(e);\n        }\n    }\n\n    private String getPayload(final String jwt) {\n        return jwt.split(JWT_DELIMITER)[1];\n    }\n\n    private UserInfo parseUserInfo(final String payload) {\n        String decodedPayload = decodeJwtPayload(payload);\n        try {\n            return objectMapper.readValue(decodedPayload, UserInfo.class);\n        } catch (JsonProcessingException e) {\n            throw new OAuthException(\"id 토큰을 읽을 수 없습니다.\");\n        }\n    }\n\n    private String decodeJwtPayload(final String payload) {\n        return new String(Base64.getUrlDecoder().decode(payload), StandardCharsets.UTF_8);\n    }\n    ...\n}\n```\n\n이제 Google에게 제공 받은 `Refresh Token`을 저장해보자.\n\n## Refresh Token에 채워진 null\n\n이게 무슨 일인가, 분명 요청 형식에 맞춰 헤더를 채워 디버깅을 해보면 계속해서 `null` 값으로 전달되고 있는 것이다. 즉, Google 측에서 Refresh Token을 보내주지 않고 있다는 것을 의미한다.\n\n![](./google-refresh-token-null.png)\n\n다시 한번 [액세스 토큰 새로고침 (오프라인 액세스)](https://developers.google.com/identity/protocols/oauth2/web-server#offline)를 살펴보았다.\n\n![](./google-refresh-token-docs.png)\n\n정리하면 [Google OAuth 2.0 서버로 리디렉션](https://developers.google.com/identity/protocols/oauth2/web-server#redirecting)할 때 query parameter에 `access_type`을 `offline`으로 설정해야 한다는 것이다. 다시 되돌아 가서 Google 인증 요청을 위한 uri를 생성하는 메서드를 아래와 같이 수정하였다.\n\n```java\n@Component\npublic class GoogleOAuthUri implements OAuthUri {\n\n    private final GoogleProperties properties;\n\n    public GoogleOAuthUri(final GoogleProperties properties) {\n        this.properties = properties;\n    }\n\n    @Override\n    public String generate() {\n        return properties.getOAuthEndPoint() + \"?\"\n                + \"client_id=\" + properties.getClientId() + \"&\"\n                + \"redirect_uri=\" + properties.getRedirectUri() + \"&\"\n                + \"response_type=code&\"\n                + \"scope=\" + String.join(\" \", properties.getScopes()) + \"&\"\n                + \"access_type=offline\"; // 추가된 부분\n    }\n}\n```\n\n이제 다시 요청을 진행해보자! 분명 `refresh token`이 정상적으로 교환될 것이다.\n\n## 또 다시 Refresh Token에 채워진 null\n\n분명 문서에 명시한 대로 설정을 진행했지만 아직도 동일하게 `null` 값이 채워져 있다.\n\n![](./google-refresh-token-null-2.png)\n\n> _해달라는 데로 다해줬는데..._\n\n## 엄격한 Google\n\nGoogle은 OAuth 2.0을 통해 인증을 받을 때 Refresh Token을 굉장히 엄격하게 다룬다. 사용자가 로그인을 진행할 때 마다 Refresh Token 정보를 주는 것이 아니라, Google에 등록된 App에 최초 로그인 할 때만 제공해준다. 즉, 재로그인을 진행해도 Refresh Token은 발급해주지 않는다. \n\nGoogle의 의도대로 동작하려면 내가 우리 서비스에 최초로 로그인을 진행하는 시점에만 Refresh Token을 발급받고 서버 내부에 저장한 뒤 필요할 때 꺼내 사용해야 한다.\n\n하지만 우리 서버는 모종의 이유로 최초에 받아온 Refresh Token을 저장하지 못할 수 있다. 이때 [Google OAuth 2.0 서버로 리디렉션](https://developers.google.com/identity/protocols/oauth2/web-server#redirecting)할 때 `prompt`를 `consent`로 설정하게 되면 매 로그인 마다 사용자에게 동의를 요청하기 때문에 강제로 `Refresh Token`을 받도록 지정할 수 있다.\n\n이제 진짜 마지막이다. 아래와 같이 수정한 뒤 다시 디버깅을 진행하였다.\n\n```java\n@Component\npublic class GoogleOAuthUri implements OAuthUri {\n\n    private final GoogleProperties properties;\n\n    public GoogleOAuthUri(final GoogleProperties properties) {\n        this.properties = properties;\n    }\n\n    @Override\n    public String generate() {\n        return properties.getOAuthEndPoint() + \"?\"\n                + \"client_id=\" + properties.getClientId() + \"&\"\n                + \"redirect_uri=\" + properties.getRedirectUri() + \"&\"\n                + \"response_type=code&\"\n                + \"scope=\" + String.join(\" \", properties.getScopes()) + \"&\"\n                + \"access_type=offline\"\n                + \"prompt=consent\"; // 추가된 부분\n    }\n}\n```\n\n![](./google-refresh-token-success.png)\n\n정상적으로 발급 되는 것을 확인할 수 있다!\n\n## 문제점\n\n하지만 여기서 문제가 하나 있다. 단순히 `prompt`를 `consent`로 설정할 경우 우리 서비스에 가입된 사용자는 Google OAuth 2.0 인증을 진행할 때 매번 재로그인을 진행해야 한다. 이것은 사용자에게 매우 `불쾌한 경험`으로 다가올 수 있다. 즉 우리는 매번 `재로그인`을 통해 Refresh Token을 발급 받는 것이 아닌, 최초 로그인 시 `Refresh Token`을 발급 받은 뒤 적절한 저장소에 저장하고 관리해야 한다.\n\n그렇다면 실제 운영 환경이 아닌 테스트 환경에서는 어떻게 해야 할까? 운영 환경과 동일한 `Google Cloud Project`를 사용할 경우 최초 로그인을 진행할 때 `내 권한 정보가 등록`된다. 즉 Refresh Token을 재발급 받을 수 없다는 것을 의미한다. \n\n우리 달록은 운영 환경과 테스트 환경에서 서로 다른 `Google Cloud Project`를 생성하여 관리하는 방향에 대해 고민하고 있다. 이미 Spring Profile 기능을 통해 각 실행 환경에 대한 설정을 분리해두었기 때문에 쉽게 적용이 가능할 것이라 기대한다. 정리하면 아래와 같다.\n\n * `운영 환경`: Refresh Token 발급을 위해 `accept_type`을 `offline`으로 설정한다. 단 최초 로그인에만 Refresh Token을 발급 받기 위해 `prompt`는 명시하지 않는다.\n * `개발 환경`: 개발 환경에서는 매번 DataBase가 초기화 되기 때문에 Refresh Token을 유지하여 관리할 수 없다. 테스트를 위한 추가적인 `Google Cloud Project`를 생성한 뒤, `accept_type`을 `offline`으로, `prompt`는 `consent`로 설정하여 매번 새롭게 Refresh Token을 받도록 세팅한다.\n\n## 정리\n\n영어를 번역기로 해석한 수준의 문장으로 인해 많은 시간을 삽질하게 되었다. 덕분에 Google에서 의도하는 Refresh Token에 대한 사용 방식과 어디에서 저장하고 관리해야 하는지에 대해 좀 더 깊은 고민을 할 수 있게 되었다. 만약 나와 같은 상황에 직면한 사람이 있다면 이 글이 도움이 되길 바란다!\n\n## References.\n\n[dallog repository](https://github.com/woowacourse-teams/2022-dallog)<br>\n[https://github.com/devHudi](https://github.com/devHudi)<br>\n[passport.js에서 구글 OAuth 진행 시 Refresh Token을 못 받아오는 문제 해결](https://m.blog.naver.com/dldbdgml99/222013891067)<br>\n"},{"excerpt":"properties 객체로 다루기 Spring에서 이나 에 존재하는 값을 불러오는 방법에는 대표적으로  애노테이션을 사용한 방법과 를 사용한 방법이 존재한다. 두 방식을 직접 적용해 본 뒤 차이와 이점에 대해 알아보려 한다. @Value 사용하기 는 기본적으로 설정 정보를 단일값으로 주입 받기 위해 사용된다. 아래는 실제 달록 프로젝트에서 적용한 예시이다…","fields":{"slug":"/properties-to-object/"},"frontmatter":{"date":"July 27, 2022","title":"properties 객체로 다루기","tags":["우아한테크코스","달록","properties"]},"rawMarkdownBody":"\n## properties 객체로 다루기\n\nSpring에서 `application.yml`이나 `application.properties`에 존재하는 값을 불러오는 방법에는 대표적으로 `@Value` 애노테이션을 사용한 방법과 `@ConfigurationProperties`를 사용한 방법이 존재한다. 두 방식을 직접 적용해 본 뒤 차이와 이점에 대해 알아보려 한다.\n\n## @Value 사용하기\n\n`@Value`는 기본적으로 설정 정보를 단일값으로 주입 받기 위해 사용된다. 아래는 실제 달록 프로젝트에서 적용한 예시이다.\n\n```java\n@Component\npublic class GoogleOAuthClient implements OAuthClient {\n\n    private static final String JWT_DELIMITER = \"\\\\.\";\n\n    private final String clientId;\n    private final String clientSecret;\n    private final String grantType;\n    private final String redirectUri;\n    private final String tokenUri;\n    private final RestTemplate restTemplate;\n    private final ObjectMapper objectMapper;\n\n    public GoogleOAuthClient(@Value(\"${oauth.google.client-id}\") final String clientId,\n                             @Value(\"${oauth.google.client-secret}\") final String clientSecret,\n                             @Value(\"${oauth.google.grant-type}\") final String grantType,\n                             @Value(\"${oauth.google.redirect-uri}\") final String redirectUri,\n                             @Value(\"${oauth.google.token-uri}\") final String tokenUri,\n                             final RestTemplateBuilder restTemplateBuilder, final ObjectMapper objectMapper) {\n        this.clientId = clientId;\n        this.clientSecret = clientSecret;\n        this.grantType = grantType;\n        this.redirectUri = redirectUri;\n        this.tokenUri = tokenUri;\n        this.restTemplate = restTemplateBuilder.build();\n        this.objectMapper = objectMapper;\n    }\n\t\t...\n}\n```\n\n간단하게 적용이 가능하지만 공통으로 묶인 프로퍼티가 많아질 경우 코드가 지저분해진다. 이러한 프로퍼티 값들을 객체로 매핑하여 사용하기 위한 애노테이션으로 `@ConfigurationProperties`가 존재한다.\n\n## @ConfigurationProperties\n\n우리는 때때로 DB 설정을 작성하기 위해 `application.yml`을 통해 관련 정보를 작성하곤 한다. 아래는 간단한 h2 DB를 연결하기 위한 설정을 적은 예시이다.\n\n```yaml\nspring:\n  datasource:\n    url: jdbc:h2:~/dallog;MODE=MYSQL;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE\n    username: sa\n```\n\n이러한 설정들은 어디서 어떻게 활용되고 있을까? 실제 바인딩 되고 있는 객체를 따라가보자.\n\n```java\n@ConfigurationProperties(prefix = \"spring.datasource\")\npublic class DataSourceProperties implements BeanClassLoaderAware, InitializingBean {\n\t\n    private ClassLoader classLoader;\n    private boolean generateUniqueName = true;\n\tprivate String name;\n\tprivate Class<? extends DataSource> type;\n\tprivate String driverClassName;\n\tprivate String url;\n    ...\n}\n```\n\n위 `DataSourceProperties`는 우리가 `application.yml`에 작성한 설정 정보를 기반으로 객체로 추출하고 있다. 이것은 Spring Boot의 자동설정으로 `DataSource`가 빈으로 주입되는 시점에 설정 정보를 활용하여 생성된다. \n\n간단히 디버깅을 진행해보면 Bean이 주입되는 시점에 아래와 같이 `application.yml`에 명시한 값들을 추출한 `DataSourceProperties`를 기반으로 생성하고 있다.\n\n![](./debug-1.png)\n\n![](./debug-2.png)\n\n정리하면 우리는 Spring Boot를 사용하며 자연스럽게 `@ConfigurationProperties`를 활용하여 만든 객체를 사용하고 있는 것이다.\n\n이제 우리가 작성한 설정 값을 기반으로 객체를 생성해서 활용해보자. 아래는 실제 프로젝트에서 사용하고 있는 `application.yml`의 일부를 가져온 것이다.\n\n```yaml\n...\noauth:\n  google:\n    client-id: ${GOOGLE_CLIENT_ID}\n    client-secret: ${GOOGLE_CLIENT_SECRET}\n    redirect-uri: ${GOOGLE_REDIRECT_URI}\n    oauth-end-point: https://accounts.google.com/o/oauth2/v2/auth\n    response-type: code\n    scopes:\n        - https://www.googleapis.com/auth/userinfo.profile\n        - https://www.googleapis.com/auth/userinfo.email\n    token-uri: ${GOOGLE_TOKEN_URI}\n    grant-type: authorization_code\n...\n```\n\n이것을 객체로 추출하기 위해서는 아래와 같이 작성해야 한다.\n\n```java\n@ConfigurationProperties(\"oauth.google\")\n@ConstructorBinding\npublic class GoogleProperties {\n\n    private final String clientId;\n    private final String clientSecret;\n    private final String redirectUri;\n    private final String oAuthEndPoint;\n    private final String responseType;\n    private final List<String> scopes;\n    private final String tokenUri;\n    private final String grantType;\n\n    public GoogleProperties(final String clientId, final String clientSecret, final String redirectUri,\n                            final String oAuthEndPoint, final String responseType, final List<String> scopes,\n                            final String tokenUri, final String grantType) {\n        this.clientId = clientId;\n        this.clientSecret = clientSecret;\n        this.redirectUri = redirectUri;\n        this.oAuthEndPoint = oAuthEndPoint;\n        this.responseType = responseType;\n        this.scopes = scopes;\n        this.tokenUri = tokenUri;\n        this.grantType = grantType;\n    }\n\n    public String getClientId() {\n        return clientId;\n    }\n\n    public String getClientSecret() {\n        return clientSecret;\n    }\n\n    public String getRedirectUri() {\n        return redirectUri;\n    }\n\n    public String getoAuthEndPoint() {\n        return oAuthEndPoint;\n    }\n\n    public String getResponseType() {\n        return responseType;\n    }\n\n    public List<String> getScopes() {\n        return scopes;\n    }\n\n    public String getTokenUri() {\n        return tokenUri;\n    }\n\n    public String getGrantType() {\n        return grantType;\n    }\n}\n```\n\n- `@ConfigurationProperties`: 프로퍼티에 있는 값을 클래스로 바인딩하기 위해 사용하는 애노테이션이다. `@ConfigurationProperties`는 값을 바인딩하기 위해 기본적으로 `Setter`가 필요하다. 하지만 `Setter`를 열어둘 경우 불변성을 보장할 수 없다. 이때 생성자를 통해 바인딩 하기 위해서는 `@ConstructorBinding`을 활용할 수 있다.\n- `@ConstructorBinding`: 앞서 언급한 것 처럼 생성자를 통해 바인딩하기 위한 목적의 애노테이션이다.\n\n```java\n@Configuration\n@EnableConfigurationProperties(GoogleProperties.class)\npublic class PropertiesConfig {\n}\n```\n\n- `@EnableConfigurationProperties`: 클래스를 지정하여 스캐닝 대상에 포함시킨다.\n\n### 개선하기\n\n```java\n@Component\npublic class GoogleOAuthClient implements OAuthClient {\n\n    private static final String JWT_DELIMITER = \"\\\\.\";\n\n    private final GoogleProperties googleProperties;\n    private final RestTemplate restTemplate;\n    private final ObjectMapper objectMapper;\n\n    public GoogleOAuthClient(final GoogleProperties googleProperties, final RestTemplateBuilder restTemplateBuilder,\n                             final ObjectMapper objectMapper) {\n        this.googleProperties = googleProperties;\n        this.restTemplate = restTemplateBuilder.build();\n        this.objectMapper = objectMapper;\n    }\n    ...\n}\n```\n\n이전 보다 적은 수의 필드를 활용하여 설정 정보를 다룰 수 있도록 개선되었다.\n\n### 정리\n\n 우리는 `application.yml` 혹은 `application.properties`에 작성하여 메타 정보를 관리할 수 있다. 클래스 내부에서 관리할 경우 수정하기 위해서는 해당 클래스에 직접 접근해야 한다. 하지만 설정 파일로 분리할 경우 우리는 환경에 따라 유연하게 값을 설정할 수 있다. 또한 `@ConfigurationProperties` 애노테이션을 사용할 경우 클래스로 값을 바인딩하기 때문에 연관된 값을 한 번에 바인딩할 수 있다.\n\n## References.\n\n[달록 repository](https://github.com/woowacourse-teams/2022-dallog)<br>\n[[Spring] @Value와 @ConfigurationProperties의 사용법 및 차이 - (2/2)](https://mangkyu.tistory.com/207)<br>\n[appendix.configuration-metadata.annotation-processor](https://docs.spring.io/spring-boot/docs/2.7.1/reference/html/configuration-metadata.html#appendix.configuration-metadata.annotation-processor)\n"},{"excerpt":"외부와 의존성 분리하기 도메인 로직은 우리가 지켜야할 매우 소중한 비즈니스 로직들이 담겨있다. 이러한 도메인 로직들은 변경이 최소화되어야 한다. 그렇기 때문에 외부와의 의존성을 최소화 해야 한다.  인터페이스 활용하기 우선 우리가 지금까지 학습한 것 중 객체 간의 의존성을 약하게 만들어 줄 수 있는 수단으로 인터페이스를 활용할 수 있다. 간단한 예시로 를…","fields":{"slug":"/separated-interface/"},"frontmatter":{"date":"July 24, 2022","title":"외부와 의존성 분리하기","tags":["우아한테크코스","달록","분리된 인터페이스","의존성 분리"]},"rawMarkdownBody":"\n## 외부와 의존성 분리하기\n\n도메인 로직은 우리가 지켜야할 매우 소중한 비즈니스 로직들이 담겨있다. 이러한 도메인 로직들은 변경이 최소화되어야 한다. 그렇기 때문에 외부와의 의존성을 최소화 해야 한다. \n\n### 인터페이스 활용하기\n\n우선 우리가 지금까지 학습한 것 중 객체 간의 의존성을 약하게 만들어 줄 수 있는 수단으로 인터페이스를 활용할 수 있다. 간단한 예시로 `JpaRepository`를 살펴보자.\n\n```java\npublic interface MemberRepository extends JpaRepository<Member, Long> {\n\n    Optional<Member> findByEmail(final String email);\n\n    boolean existsByEmail(final String email);\n}\n```\n\n이러한 인터페이스 덕분에 우리는 실제 DB에 접근하는 내부 구현에 의존하지 않고 데이터를 조작할 수 있다. 핵심은 `실제 DB에 접근하는 행위`이다.\n\n아래는 `Spring Data`가 만든 `JpaRepository의 구현체` `SimpleJpaRepository`의 일부를 가져온 것이다.\n\n```java\n@Repository\n@Transactional(readOnly = true)\npublic class SimpleJpaRepository<T, ID> implements JpaRepositoryImplementation<T, ID> {\n\n\tprivate static final String ID_MUST_NOT_BE_NULL = \"The given id must not be null!\";\n\n\tprivate final JpaEntityInformation<T, ?> entityInformation;\n\tprivate final EntityManager em;\n\tprivate final PersistenceProvider provider;\n\n\tprivate @Nullable CrudMethodMetadata metadata;\n\tprivate EscapeCharacter escapeCharacter = EscapeCharacter.DEFAULT;\n\n\tpublic SimpleJpaRepository(JpaEntityInformation<T, ?> entityInformation, EntityManager entityManager) {\n\n\t\tAssert.notNull(entityInformation, \"JpaEntityInformation must not be null!\");\n\t\tAssert.notNull(entityManager, \"EntityManager must not be null!\");\n\n\t\tthis.entityInformation = entityInformation;\n\t\tthis.em = entityManager;\n\t\tthis.provider = PersistenceProvider.fromEntityManager(entityManager);\n\t}\n  ...\n}\n```\n\n해당 구현체는 `entityManger`를 통해 객체를 영속 시키는 행위를 진행하고 있기 때문에 `영속 계층`에 가깝다고 판단했다. 즉 도메인의 입장에서 `MemberRepository`를 바라볼 때 단순히 `JpaRepository`를 상속한 인터페이스를 가지고 있기 때문에 `영속 계층`에 대한 직접적인 의존성은 없다고 봐도 무방하다. 정리하면 우리는 인터페이스를 통해 실제 구현체에 의존하지 않고 로직을 수행할 수 있게 된다. \n\n### 관점 변경하기\n\n이러한 사례를 외부 서버와 통신을 담당하는 우리가 직접 만든 인터페이스인 `OAuthClient`에 대입해본다. `OAuthClient`의 가장 큰 역할은 n의 소셜에서 `OAuth 2.0`을 활용한 인증의 행위를 정의한 인터페이스이다. google, github 등 각자에 맞는 요청을 처리하기 위해 `OAuthClient`를 구현한 뒤 로직을 처리할 수 있다. 아래는 실제 google의 인가 코드를 기반으로 토큰 정보에서 회원 정보를 조회하는 로직을 담고 있다.\n\n```java\npublic interface OAuthClient {\n\n    OAuthMember getOAuthMember(final String code);\n}\n```\n\n```java\n@Component\npublic class GoogleOAuthClient implements OAuthClient {\n\n    private static final String JWT_DELIMITER = \"\\\\.\";\n\n    private final String googleRedirectUri;\n    private final String googleClientId;\n    private final String googleClientSecret;\n    private final String googleTokenUri;\n    private final RestTemplate restTemplate;\n    private final ObjectMapper objectMapper;\n\n    public GoogleOAuthClient(@Value(\"${oauth.google.redirect_uri}\") final String googleRedirectUri,\n                             @Value(\"${oauth.google.client_id}\") final String googleClientId,\n                             @Value(\"${oauth.google.client_secret}\") final String googleClientSecret,\n                             @Value(\"${oauth.google.token_uri}\") final String googleTokenUri,\n                             final RestTemplate restTemplate, final ObjectMapper objectMapper) {\n        this.googleRedirectUri = googleRedirectUri;\n        this.googleClientId = googleClientId;\n        this.googleClientSecret = googleClientSecret;\n        this.googleTokenUri = googleTokenUri;\n        this.restTemplate = restTemplate;\n        this.objectMapper = objectMapper;\n    }\n\n    @Override\n    public OAuthMember getOAuthMember(final String code) {\n        GoogleTokenResponse googleTokenResponse = requestGoogleToken(code);\n        String payload = getPayloadFrom(googleTokenResponse.getIdToken());\n        String decodedPayload = decodeJwtPayload(payload);\n\n        try {\n            return generateOAuthMemberBy(decodedPayload);\n        } catch (JsonProcessingException e) {\n            throw new IllegalArgumentException();\n        }\n    }\n\n    private GoogleTokenResponse requestGoogleToken(final String code) {\n        HttpHeaders headers = new HttpHeaders();\n        headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);\n        MultiValueMap<String, String> params = generateRequestParams(code);\n\n        HttpEntity<MultiValueMap<String, String>> request = new HttpEntity<>(params, headers);\n        return restTemplate.postForEntity(googleTokenUri, request, GoogleTokenResponse.class).getBody();\n    }\n\n    private MultiValueMap<String, String> generateRequestParams(final String code) {\n        MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n        params.add(\"client_id\", googleClientId);\n        params.add(\"client_secret\", googleClientSecret);\n        params.add(\"code\", code);\n        params.add(\"grant_type\", \"authorization_code\");\n        params.add(\"redirect_uri\", googleRedirectUri);\n        return params;\n    }\n\n    private String getPayloadFrom(final String jwt) {\n        return jwt.split(JWT_DELIMITER)[1];\n    }\n\n    private String decodeJwtPayload(final String payload) {\n        return new String(Base64.getUrlDecoder().decode(payload), StandardCharsets.UTF_8);\n    }\n\n    private OAuthMember generateOAuthMemberBy(final String decodedIdToken) throws JsonProcessingException {\n        Map<String, String> userInfo = objectMapper.readValue(decodedIdToken, HashMap.class);\n        String email = userInfo.get(\"email\");\n        String displayName = userInfo.get(\"name\");\n        String profileImageUrl = userInfo.get(\"picture\");\n\n        return new OAuthMember(email, displayName, profileImageUrl);\n    }\n}\n```\n\n보통의 생각은 인터페이스인 `OAuthClient`와 구현체인 `GoogleOAuthClient`를 같은 패키지에 두려고 할 것이다. `GoogleOAuthClient`는 외부 의존성을 강하게 가지고 있기 때문에 `domain` 패키지와 별도로 관리하기 위한 `infrastructure` 패키지가 적합할 것이다. 결국 인터페이스인 `OAuthClient` 또한 `infrastructure`에 위치하게 될 것이다. 우리는 이러한 생각에서 벗어나 새로운 관점에서 살펴봐야 한다.\n\n앞서 언급한 의존성에 대해 생각해보자. 위 `OAuthClient`를 사용하는 주체는 누구일까? 우리는 이러한 주체를 `domain` 내에 인증을 담당하는 `auth` 패키지 내부의 `Authservice`로 결정 했다. 아래는 실제 `OAuthClient`를 사용하고 있는 주체인 `AuthService`이다.\n\n```java\n@Transactional(readOnly = true)\n@Service\npublic class AuthService {\n\n    private final OAuthEndpoint oAuthEndpoint;\n    private final OAuthClient oAuthClient;\n    private final MemberService memberService;\n    private final JwtTokenProvider jwtTokenProvider;\n\n    public AuthService(final OAuthEndpoint oAuthEndpoint, final OAuthClient oAuthClient,\n                       final MemberService memberService, final JwtTokenProvider jwtTokenProvider) {\n        this.oAuthEndpoint = oAuthEndpoint;\n        this.oAuthClient = oAuthClient;\n        this.memberService = memberService;\n        this.jwtTokenProvider = jwtTokenProvider;\n    }\n\n    public String generateGoogleLink() {\n        return oAuthEndpoint.generate();\n    }\n\n    @Transactional\n    public TokenResponse generateTokenWithCode(final String code) {\n        OAuthMember oAuthMember = oAuthClient.getOAuthMember(code);\n        String email = oAuthMember.getEmail();\n\n        if (!memberService.existsByEmail(email)) {\n            memberService.save(generateMemberBy(oAuthMember));\n        }\n\n        Member foundMember = memberService.findByEmail(email);\n        String accessToken = jwtTokenProvider.createToken(String.valueOf(foundMember.getId()));\n\n        return new TokenResponse(accessToken);\n    }\n\n    private Member generateMemberBy(final OAuthMember oAuthMember) {\n        return new Member(oAuthMember.getEmail(), oAuthMember.getProfileImageUrl(), oAuthMember.getDisplayName(), SocialType.GOOGLE);\n    }\n}\n```\n\n지금 까지 설명한 구조의 패키지 구조는 아래와 같다.\n\n```\n└── src\n    ├── main\n    │   ├── java\n    │   │   └── com\n    │   │       └── allog\n    │   │           └── dallog\n    │   │               ├── auth\n    │   │               │   └── application\n    │   │               │       └── AuthService.java\n    │   │               ...\n    │   │               ├── infrastructure\n    │   │               │   ├── oauth\n    │   │               │   │   └── client\n    │   │               │   │       ├── OAuthClient.java\n    │   │               │   │       └── GoogleOAuthClient.java\n    │   │               │   └── dto\n    │   │               │       └── OAuthMember.java     \n    │   │               └── AllogDallogApplication.java\n    |   |\n    │   └── resources\n    │       └── application.yml\n```\n\n결국 이러한 구조는 아래와 같이 `domain` 패키지에서 `infrastructure`에 의존하게 된다.\n  \n```java\n...\nimport com.allog.dallog.infrastructure.dto.OAuthMember; // 의존성 발생!\nimport com.allog.dallog.infrastructure.oauth.client.OAuthClient; // 의존성 발생!\n...\n\n@Transactional(readOnly = true)\n@Service\npublic class AuthService {\n\t...\n    private final OAuthClient oAuthClient;\n    ...\n\n    @Transactional\n    public TokenResponse generateTokenWithCode(final String code) {\n        OAuthMember oAuthMember = oAuthClient.getOAuthMember(code);\n        ...\n    }\n    ...\n}\n```\n\n### Separated Interface Pattern\n\n`분리된 인터페이스`를 활용하자. 즉 `인터페이스`와 `구현체`를 각각의 패키지로 분리한다. 분리된 인터페이스를 사용하여 `domain` 패키지에서 인터페이스를 정의하고 `infrastructure` 패키지에 구현체를 둔다. 이렇게 구성하면 인터페이스에 대한 종속성을 가진 주체가 구현체에 대해 인식하지 못하게 만들 수 있다.\n\n아래와 같은 구조로 인터페이스와 구현체를 분리했다고 가정한다.\n\n```\n└── src\n    ├── main\n    │   ├── java\n    │   │   └── com\n    │   │       └── allog\n    │   │           └── dallog\n    │   │               ├── auth\n    │   │               │   ├── application\n    │   │               │   │   ├── AuthService.java\n    │   │               │   │   └── OAuthClient.java\n    │   │               │   └── dto\n    │   │               │       └── OAuthMember.java         \n    │   │               ...\n    │   │               ├── infrastructure\n    │   │               │   ├── oauth\n    │   │               │       └── client\n    │   │               │           └── GoogleOAuthClient.java\n    │   │               └── AllogDallogApplication.java\n    |   |\n    │   └── resources\n    │       └── application.yml\n```\n\n자연스럽게 `domain` 내에 있던 `infrastructure` 패키지에 대한 의존성도 제거된다. 즉 외부 서버와의 통신을 위한 의존성이 완전히 분리된 것을 확인할 수 있다.\n\n```java\n...\nimport com.allog.dallog.auth.dto.OAuthMember; // auth 패키지 내부를 의존\n...\n@Transactional(readOnly = true)\n@Service\npublic class AuthService {\n\t...\n    private final OAuthClient oAuthClient;\n    ...\n\n    @Transactional\n    public TokenResponse generateTokenWithCode(final String code) {\n        OAuthMember oAuthMember = oAuthClient.getOAuthMember(code);\n        ...\n    }\n    ...\n}\n```\n\n## References.\n\n[Separated Interface](https://www.martinfowler.com/eaaCatalog/separatedInterface.htmlhttps://www.martinfowler.com/eaaCatalog/separatedInterface.html)\n"},{"excerpt":"개요 기본 키 할당 전략에 대한 학습을 진행하고 있었다. 기본 키 전략을 로 진행하면 데이터베이스에게 키 생성을 위임하기 때문에 JPA에서 기본 키 값을 얻어오기 위해서는 추가적인 데이터베이스 조회가 필요하다. 하지만 저장 관련 테스트를 진행했을 때 어디에도 조회와 관련된 쿼리는 찾을 수 없었다. 이게 어떻게 된 일인지 알아보려 한다. IDENTITY 앞…","fields":{"slug":"/identity-strategy/"},"frontmatter":{"date":"July 10, 2022","title":"IDENTITY 전략는 추가 조회를 하지 않을 수 있다.","tags":["우아한테크코스","jpa","IDENTITY"]},"rawMarkdownBody":"\n\n![](https://user-images.githubusercontent.com/59357153/152970395-a31c8134-fc89-449f-b4dc-441e03df929c.png)\n\n## 개요\n\n기본 키 할당 전략에 대한 학습을 진행하고 있었다. 기본 키 전략을 `IDENTITY`로 진행하면 데이터베이스에게 키 생성을 위임하기 때문에 JPA에서 기본 키 값을 얻어오기 위해서는 추가적인 데이터베이스 조회가 필요하다. 하지만 저장 관련 테스트를 진행했을 때 어디에도 조회와 관련된 쿼리는 찾을 수 없었다. 이게 어떻게 된 일인지 알아보려 한다.\n\n## IDENTITY\n\n앞서 언급한 것 처럼 `IDENTITY`는 기본 키 생성을 위한 전략을 데이터베이스에 위임 하는 것이다. `MySQL`은 보통 기본 키 자동 생성을 위해 `AUTO_INCREMENT`을 활용한다. 아래와 같이 `DDL`을 작성하면 INSERT할 때 자동으로 기본 키가 채워진다.\n\n```sql\ncreate table station (\n   id bigint auto_increment,\n    name varchar(255) not null,\n    primary key (id)\n)\n```\n\n하지만 기본 키 생성을 데이터베이스에서 진행할 경우 값이 저장되야 비로소 기본 키 값을 확인할 수 있다. 이제 JPA에 해당 전략을 적용하면 아래와 같이 작성할 수 있다.\n\n```java\n@Entity\npublic class Station {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    @Column(nullable = false)\n    private String name;\n\n    protected Station() {\n    }\n\n    public Station(String name) {\n        this.name = name;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public String getName() {\n        return name;\n    }\n}\n```\n\n간단한 예시를 위한 지하철 엔티티이다. 지하철은 이름을 가질 수 있고 기본 키 생성 전략은 `IDENTITY`이므로 데이터베이스에서 자동으로 생성된다. 만약 기본 키가 필요한 경우 조회를 위한 추가적인 쿼리가 필요할 것이다.\n\n이제 `Station`을 저장하고 id값을 조회하는 테스트를 작성한 뒤 실행했다.\n\n```java\n@DataJpaTest\nclass StationRepositoryTest {\n\n    @Autowired\n    protected StationRepository stationRepository;\n\n    @Test\n    void save() {\n        Station station = stationRepository.save(new Station(\"잠실역\"));\n\n        assertAll(() -> {\n            assertThat(station.getId()).isNotNull();\n            assertThat(station.getName()).isEqualTo(\"잠실역\");\n        });\n    }\n}\n```\n\n```bash\n2022-07-10 00:56:55.797  INFO 99986 --- [    Test worker] o.h.e.t.j.p.i.JtaPlatformInitiator       : HHH000490: Using JtaPlatform implementation: [org.hibernate.engine.transaction.jta.platform.internal.NoJtaPlatform]\n2022-07-10 00:56:55.806  INFO 99986 --- [    Test worker] j.LocalContainerEntityManagerFactoryBean : Initialized JPA EntityManagerFactory for persistence unit 'default'\n2022-07-10 00:56:56.498  INFO 99986 --- [    Test worker] subway.domain.StationRepositoryTest      : Started StationRepositoryTest in 2.891 seconds (JVM running for 3.606)\n2022-07-10 00:56:56.524  INFO 99986 --- [    Test worker] o.s.t.c.transaction.TransactionContext   : Began transaction (1) for test context [DefaultTestContext@6a362409 testClass = StationRepositoryTest, testInstance = subway.domain.StationRepositoryTest@2aa5eecd, testMethod = save@StationRepositoryTest, testException = [null], mergedContextConfiguration = [MergedContextConfiguration@36ea6a37 testClass = StationRepositoryTest, locations = '{}', classes = '{class subway.Application}', contextInitializerClasses = '[]', activeProfiles = '{}', propertySourceLocations = '{}', propertySourceProperties = '{org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTestContextBootstrapper=true}', contextCustomizers = set[org.springframework.boot.test.autoconfigure.OverrideAutoConfigurationContextCustomizerFactory$DisableAutoConfigurationContextCustomizer@3258d1dc, org.springframework.boot.test.autoconfigure.actuate.metrics.MetricsExportContextCustomizerFactory$DisableMetricExportContextCustomizer@4b4d3ed5, org.springframework.boot.test.autoconfigure.filter.TypeExcludeFiltersContextCustomizer@351584c0, org.springframework.boot.test.autoconfigure.properties.PropertyMappingContextCustomizer@e1aa1b8f, org.springframework.boot.test.autoconfigure.web.servlet.WebDriverContextCustomizerFactory$Customizer@22a24ec8, [ImportsContextCustomizer@84d34eb key = [org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration, org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration, org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration, org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration, org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration, org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration, org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration, org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration, org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration, org.springframework.boot.test.autoconfigure.jdbc.TestDatabaseAutoConfiguration, org.springframework.boot.test.autoconfigure.orm.jpa.TestEntityManagerAutoConfiguration]], org.springframework.boot.test.context.filter.ExcludeFilterContextCustomizer@3df27965, org.springframework.boot.test.json.DuplicateJsonObjectContextCustomizerFactory$DuplicateJsonObjectContextCustomizer@2794add4, org.springframework.boot.test.mock.mockito.MockitoContextCustomizer@0, org.springframework.boot.test.context.SpringBootTestArgs@1, org.springframework.boot.test.context.SpringBootTestWebEnvironment@0], contextLoader = 'org.springframework.boot.test.context.SpringBootContextLoader', parent = [null]], attributes = map['org.springframework.test.context.event.ApplicationEventsTestExecutionListener.recordApplicationEvents' -> false]]; transaction manager [org.springframework.orm.jpa.JpaTransactionManager@11ce4c44]; rollback [true]\nHibernate: \n    insert \n    into\n        station\n        (id, name) \n    values\n        (null, ?)\n2022-07-10 00:56:56.612 TRACE 99986 --- [    Test worker] o.h.type.descriptor.sql.BasicBinder      : binding parameter [1] as [VARCHAR] - [잠실역]\n2022-07-10 00:56:56.671  INFO 99986 --- [    Test worker] o.s.t.c.transaction.TransactionContext   : Rolled back transaction for test: [DefaultTestContext@6a362409 testClass = StationRepositoryTest, testInstance = subway.domain.StationRepositoryTest@2aa5eecd, testMethod = save@StationRepositoryTest, testException = [null], mergedContextConfiguration = [MergedContextConfiguration@36ea6a37 testClass = StationRepositoryTest, locations = '{}', classes = '{class subway.Application}', contextInitializerClasses = '[]', activeProfiles = '{}', propertySourceLocations = '{}', propertySourceProperties = '{org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTestContextBootstrapper=true}', contextCustomizers = set[org.springframework.boot.test.autoconfigure.OverrideAutoConfigurationContextCustomizerFactory$DisableAutoConfigurationContextCustomizer@3258d1dc, org.springframework.boot.test.autoconfigure.actuate.metrics.MetricsExportContextCustomizerFactory$DisableMetricExportContextCustomizer@4b4d3ed5, org.springframework.boot.test.autoconfigure.filter.TypeExcludeFiltersContextCustomizer@351584c0, org.springframework.boot.test.autoconfigure.properties.PropertyMappingContextCustomizer@e1aa1b8f, org.springframework.boot.test.autoconfigure.web.servlet.WebDriverContextCustomizerFactory$Customizer@22a24ec8, [ImportsContextCustomizer@84d34eb key = [org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration, org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration, org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration, org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration, org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration, org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration, org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration, org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration, org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration, org.springframework.boot.test.autoconfigure.jdbc.TestDatabaseAutoConfiguration, org.springframework.boot.test.autoconfigure.orm.jpa.TestEntityManagerAutoConfiguration]], org.springframework.boot.test.context.filter.ExcludeFilterContextCustomizer@3df27965, org.springframework.boot.test.json.DuplicateJsonObjectContextCustomizerFactory$DuplicateJsonObjectContextCustomizer@2794add4, org.springframework.boot.test.mock.mockito.MockitoContextCustomizer@0, org.springframework.boot.test.context.SpringBootTestArgs@1, org.springframework.boot.test.context.SpringBootTestWebEnvironment@0], contextLoader = 'org.springframework.boot.test.context.SpringBootContextLoader', parent = [null]], attributes = map['org.springframework.test.context.event.ApplicationEventsTestExecutionListener.recordApplicationEvents' -> false]]\n2022-07-10 00:56:56.683  INFO 99986 --- [extShutdownHook] j.LocalContainerEntityManagerFactoryBean : Closing JPA EntityManagerFactory for persistence unit 'default'\nBUILD SUCCESSFUL in 4s\n```\n\n쿼리 로그를 살펴보면 insert와 관련된 쿼리를 제외하곤 전혀 찾아볼 수 없다. 또한 위 테스트는 정상적으로 실행되므로 id 값은 적절히 잘 조회 되었을 것이다.\n\n## 기본 키 조회 쿼리는 어디에?\n\n`IDENTITY` 전략은 `JDBC`에 `Statement`의 `getGeneratedKeys()` 메서드를 통해 데이터를 저장과 동시에 기본키를 얻어 올 수 있다. JPA의 구현체인 hibernate는 이 메서드를 활용하여 데이터베이스와 한 번의 통신으로 처리한다. 즉 생성과 동시에 기본 키를 얻어오기 때문에 한 번의 `INSERT`로 해결할 수 있다.\n\n`getGeneratedKeys`의 공식 문서를 살펴보면 아래와 같은 내용을 확인할 수 있다.\n\n### 공식 문서 중 일부\nRetrieves any auto-generated keys created as a result of executing this Statement object. If this Statement object did not generate any keys, an empty ResultSet object is returned.\n\n**Statement로 실행한 결과로 생성된 자동 생성 키를 검색한다. 만약 Statement 객체가 키를 생성하지 않은 경우 빈 ResultSet을 반환한다.**\n\nNote: If the columns which represent the auto-generated keys were not specified, the JDBC driver implementation will determine the columns which best represent the auto-generated keys.\n\n**참고: 자동 생성된 키를 나타내는 열이 지정되지 않은 경우 JDBC 드라이버 구현에 따라 자동 생성된 키를 가장 잘 나타내는 열이 결정된다.**\n\nReturns: a ResultSet object containing the auto-generated key(s) generated by the execution of this Statement object\n\n**반환: Statement 객체의 실행으로 생성된 자동 생성 키가 들어 있는 ResultSet 객체이다.**\n\n`Statement` 인터페이스는 현재 h2 드라이버의 의존성을 추가한 프로젝트 에서 작성하였기 때문에 내부에 구현체 `JdbcStatement`를 사용하고 있다. 간단히 디버그 모드를 통해 save 시점에 해당 메서드가 사용되는지 확인한다.\n\n![](https://user-images.githubusercontent.com/59357153/178113850-3ae31510-548a-46d2-b98b-ff7e5474356a.png)\n\n## 정리\n\n`IDENTITY` 전략은 `INSERT` 이후 기본 키에 대한 조회를 진행할 수 있다. 즉 데이터베이스에 추가적인 조회가 필요하다. 하지만 JDBC Statement의 `getGeneratedKeys` 메서드 덕분에 데이터 저장과 동시에 기본 키를 얻을 수 있다.\n\n### 참고 사항\n\nJPA에서 엔티티는 영속 상태가 되기 위해 식별자를 반드시 필요로 한다. IDENTITY의 경우 데이터베이스에 저장되어야 식별자를 조회할 수 있는 특성으로 인해 트랜잭션이 지원하는 쓰기 지연을 활용할 수 없다. 즉 영속 시키는 즉시 데이터베이스에 쿼리를 전달한다.\n\n## References.\n\n[Returning the Generated Keys in JDBC](https://www.baeldung.com/jdbc-returning-generated-keys) <br>\n[Interface Statement](https://docs.oracle.com/en/java/javase/11/docs/api/java.sql/java/sql/Statement.html#getGeneratedKeys()) <br>\n김영한 지음, 『자바 ORM 표준 JPA 프로그래밍』, 에이콘(2015), p133-135.\n"},{"excerpt":"이번 팀 프로젝트를 진행하며 손쉽게 일정을 등록하고 관리할 수 있는 공유 캘린더를 주제로 진행하게 되었다. 캘린더를 기반한 도메인이 주를 이루기 때문에 날짜와 시간에 대한 조작이 필요했다. 이번 기회를 통해 이전에 잘 사용하지 않았던 Java의 날짜, 시간을 다루기 위한 객체에 대해 알아보려 한다. JDK 8 이전 JDK 8 이전에는 날짜와 시간을 다루기…","fields":{"slug":"/local-date-time/"},"frontmatter":{"date":"July 03, 2022","title":"java에서 날짜, 시간 제대로 사용하기","tags":["우아한테크코스","알록달록","LocalDateTime"]},"rawMarkdownBody":"\n![](https://user-images.githubusercontent.com/59357153/152970395-a31c8134-fc89-449f-b4dc-441e03df929c.png)\n\n이번 팀 프로젝트를 진행하며 손쉽게 일정을 등록하고 관리할 수 있는 공유 캘린더를 주제로 진행하게 되었다. 캘린더를 기반한 도메인이 주를 이루기 때문에 날짜와 시간에 대한 조작이 필요했다. 이번 기회를 통해 이전에 잘 사용하지 않았던 Java의 날짜, 시간을 다루기 위한 객체에 대해 알아보려 한다.\n\n## JDK 8 이전\n\nJDK 8 이전에는 날짜와 시간을 다루기 위해 주로 `java.util.Date`와 `java.util.Calender`를 사용했다. 하지만 해당 클래스는 아래와 같이 많은 문제를 가지고 있었다. \n\n * 불변 객체가 아니다. 즉 내부 필드를 바꿀 수 있는 메서드가 제공되며 만약 여러 객체에서 공유되어 사용될 경우 부작용이 생길 우려가 있다. \n * 헷갈리는 월 지정방식이다. `JDK 1.0`에서 Date 클래스는 `1월`을 `0`으로 표현하였기 때문에 직관적이지 않다. 가독성을 높이기 위해 일부는 `9월`을 `9 - 1`로 지정하는 방식을 사용하곤 한다.\n * 일관성이 없는 요일 상수를 가지고 있다. `Calendar.WEDNESDAY`의 경우 `public static final int WEDNESDAY = 4`로 수요일을 `4`로 표현하고 있다. 하지만 `Date` 객체의 `getDay()` 메서드를 통해 요일을 구하면 수요일은 `3`으로 표현된다.\n\n그 밖에도 다양한 문제들을 가지고 있다. 자세한 설명은 [Java의 날짜와 시간 API](https://d2.naver.com/helloworld/645609)에서 확인할 수 있다.\n\n## JDK 8 이후\n\n위에서 언급한 문제를 해결하기 위해 JDK 8 이후 `LocalDate`, `LocalTime`, `LocalDateTime`이 등장하였다. 이러한 객체는 기존 `Date`와 `Calender`를 개선하기 위해 등장한 라이브러리인 `joda time`의 영향을 받아 유사하게 설계되었다. 이제 각 객체의 공식 문서를 살펴보자.\n\n### LocalDate\n\n::: tip 공식 문서 중 일부\n\nA date without a time-zone in the ISO-8601 calendar system, such as 2007-12-03. LocalDate is an immutable date-time object that represents a date, often viewed as year-month-day. Other date fields, such as day-of-year, day-of-week and week-of-year, can also be accessed. For example, the value \"2nd October 2007\" can be stored in a LocalDate.\n\n**ISO-8601 달력 시스템에 \"2007-12-03\"와 같이 표준 시간대가 없는 날짜이다. LocalDate는 날짜를 나타내는 불변의 날짜-시간 객체로, 종종 year-month-day로 표시된다. 요일, 요일 및 요일과 같은 다른 날짜 필드도 접근할 수 있다. 예를들면 \"2007년 10월 2일\" 값은 LocalDate에 저장할 수 있다.**\n\nThis class does not store or represent a time or time-zone. Instead, it is a description of the date, as used for birthdays. It cannot represent an instant on the time-line without additional information such as an offset or time-zone.\n\n**이 클래스는 시간 또는 표준 시를 저장하거나 나타내지 않는다. 대신 생일에 사용되는 날짜에 대해 표현한다. ofset 또는 표준 시와 같은 추가정보 없이 타임라인의 순간을 나타낼 수 없다.**\n\nThe ISO-8601 calendar system is the modern civil calendar system used today in most of the world. It is equivalent to the proleptic Gregorian calendar system, in which today's rules for leap years are applied for all time. For most applications written today, the ISO-8601 rules are entirely suitable. However, any application that makes use of historical dates, and requires them to be accurate will find the ISO-8601 approach unsuitable.\n\n**ISO-8601 달력 체계는 오늘날 대부분의 세계에서 사용되는 현대 민간 달력 체계이다. 오늘날 윤년에 대한 규칙이 모든 시간에 적용되는 프로프래틱 그레고리력 체계와 같다. 오늘날 작성된 대부분의 응용 프로그램에는 ISO-8601 규칙이 전적으로 적합하다. 그러나 과거 날짜를 사용하고 정확한 날짜를 요구하는 모든 응용 프로그램은 ISO-8601 접근법이 적합하지 않다는 것을 알게 될 것이다.**\n\nThis is a value-based class; use of identity-sensitive operations (including reference equality (==), identity hash code, or synchronization) on instances of LocalDate may have unpredictable results and should be avoided. The equals method should be used for comparisons.\n\n**이것은 값 기반의 클래스이다. (==), 해시 코드 및 동기화와 같은 작업을 할 때 예측할 수 없는 결과가 발생할 수 있으므로 피해야 한다. 비교를 위해서는 동등 방법을 활용해야 한다.**\n\n:::\n\n아래는 간단히 `LocalDate`에 존재하는 기능들을 테스트 한 것이다.\n\n```java\npublic class LocalDateTest {\n\n    @DisplayName(\"LocalDate를 생성한다.\")\n    @Test\n    void creat() {\n        LocalDate localDate = LocalDate.of(2022, 07, 03);\n\n        assertThat(localDate).isEqualTo(\"2022-07-03\");\n    }\n\n    @DisplayName(\"현재 시간을 구한다.\")\n    @Test\n    void now() {\n        LocalDate now = LocalDate.now();\n\n        assertThat(now).isNotNull();\n    }\n\n    @DisplayName(\"일을 더한다.\")\n    @Test\n    void plusDays() {\n        LocalDate localDate = LocalDate.of(2022, 07, 03);\n        LocalDate plusLocalDate = localDate.plusDays(1);\n\n        assertThat(plusLocalDate).isEqualTo(\"2022-07-04\");\n    }\n\n    @DisplayName(\"주를 더한다.\")\n    @Test\n    void plusWeeks() {\n        LocalDate localDate = LocalDate.of(2022, 07, 03);\n        LocalDate plusLocalDate = localDate.plusWeeks(5);\n\n        assertThat(plusLocalDate).isEqualTo(\"2022-08-07\");\n    }\n\n    @DisplayName(\"월을 더한다.\")\n    @Test\n    void plusMonths() {\n        LocalDate localDate = LocalDate.of(2022, 07, 03);\n        LocalDate plusLocalDate = localDate.plusMonths(7);\n\n        assertThat(plusLocalDate).isEqualTo(\"2023-02-03\");\n    }\n    \n    @DisplayName(\"연을 더한다.\")\n    @Test\n    void plusYears() {\n        LocalDate localDate = LocalDate.of(2022, 07, 03);\n        LocalDate plusLocalDate = localDate.plusYears(5);\n\n        assertThat(plusLocalDate).isEqualTo(\"2027-07-03\");\n    }\n\n    @DisplayName(\"두 날짜를 비교하여 과거를 판단한다.\")\n    @Test\n    void isBefore() {\n        LocalDate first = LocalDate.of(2022, 07, 03);\n        LocalDate second = LocalDate.of(2023, 07, 03);\n\n        boolean result = first.isBefore(second);\n\n        assertThat(result).isTrue();\n    }\n\n    @DisplayName(\"두 날짜를 비교하여 미래를 판단한다.\")\n    @Test\n    void isAfter() {\n        LocalDate first = LocalDate.of(2022, 07, 03);\n        LocalDate second = LocalDate.of(2023, 07, 03);\n\n        boolean result = second.isAfter(first);\n\n        assertThat(result).isTrue();\n    }\n\n    @DisplayName(\"동일한 날짜의 동등성을 판단한다.\")\n    @Test\n    void equals() {\n        LocalDate first = LocalDate.of(2022, 07, 03);\n        LocalDate second = LocalDate.of(2022, 07, 03);\n\n        boolean result = first.equals(second);\n\n        assertThat(result).isTrue();\n    }\n}\n```\n\n주로 year, month, day에 대한 메서드가 존재한다. 값 객체이기 때문에 내부의 값들이 동일하면 모두 동일한 객체로 판단한다. 또한 두 날짜를 비교하여 과거와 미래에 대한 판단도 진행할 수 있다.\n\n### LocalTime\n\n::: tip 공식 문서 중 일부\n\nA time without a time-zone in the ISO-8601 calendar system, such as 10:15:30.\nLocalTime is an immutable date-time object that represents a time, often viewed as hour-minute-second. Time is represented to nanosecond precision. For example, the value \"13:45.30.123456789\" can be stored in a LocalTime.\n\n**ISO-8601 달력 시스템에서 \"10:15:30\"과 같이 표준 시간대가 없는 시간이다. LocalTime은 시간을 나타내는 불변의 날짜-시간 객체이다. 종종 hour-minute-second로 표시된다. 시간은 나노초 정밀도로 표현된다. 예를들면 \"13:45.30.123456789\"과 같이 지정할 수 있다.**\n\nThis class does not store or represent a date or time-zone. Instead, it is a description of the local time as seen on a wall clock. It cannot represent an instant on the time-line without additional information such as an offset or time-zone.\n\n**이 클래스는 날짜 또는 표준시를 저장하거나 나타내지 않는다. 대신, 벽시계에 보이는 현지 시간에 대한 설명이다. offset 또는 표준시와 같은 추가 정보 없이 타임라인의 순간을 나타낼 수 없다.**\n\nThe ISO-8601 calendar system is the modern civil calendar system used today in most of the world. This API assumes that all calendar systems use the same representation, this class, for time-of-day.\n\n**ISO-8601 달력 체계는 오늘날 대부분의 세계에서 사용되는 현대 민간 달력 체계이다. 이 API는 모든 캘린더 시스템이 동일한 표현을 사용한다고 가정한다.**\n\nThis is a value-based class; use of identity-sensitive operations (including reference equality (==), identity hash code, or synchronization) on instances of LocalTime may have unpredictable results and should be avoided. The equals method should be used for comparisons.\n\n**이것은 값 기반의 클래스이다. (==), 해시 코드 및 동기화와 같은 작업을 할 때 예측할 수 없는 결과가 발생할 수 있으므로 피해야 한다. 비교를 위해서는 동등 방법을 활용해야 한다.**\n\n:::\n\n아래는 간단히 `LocalTime`에 존재하는 기능들을 테스트 한 것이다.\n\n```java\npublic class LocalTimeTest {\n\n    @DisplayName(\"LocalTime을 생성한다.\")\n    @Test\n    void create() {\n        LocalTime localTime = LocalTime.of(18, 30, 15);\n        assertThat(localTime).isEqualTo(\"18:30:15\");\n\n        LocalTime secondWithoutLocalTime = LocalTime.of(18, 30);\n        assertThat(secondWithoutLocalTime).isEqualTo(\"18:30\");\n    }\n\n    @DisplayName(\"현재 시간을 구한다.\")\n    @Test\n    void now() {\n        LocalTime now = LocalTime.now();\n\n        assertThat(now).isNotNull();\n    }\n\n    @DisplayName(\"시간을 더한다.\")\n    @Test\n    void plusHours() {\n        LocalTime localTime = LocalTime.of(18, 30, 15);\n\n        LocalTime plusLocalTime = localTime.plusHours(3);\n\n        assertThat(plusLocalTime).isEqualTo(\"21:30:15\");\n    }\n\n    @DisplayName(\"분을 더한다.\")\n    @Test\n    void plusMinutes() {\n        LocalTime localTime = LocalTime.of(18, 30, 15);\n\n        LocalTime plusLocalTime = localTime.plusMinutes(40);\n\n        assertThat(plusLocalTime).isEqualTo(\"19:10:15\");\n    }\n\n    @DisplayName(\"초를 더한다.\")\n    @Test\n    void plusSeconds() {\n        LocalTime localTime = LocalTime.of(18, 30, 15);\n\n        LocalTime plusLocalTime = localTime.plusSeconds(15);\n\n        assertThat(plusLocalTime).isEqualTo(\"18:30:30\");\n    }\n\n    @DisplayName(\"두 시간을 비교하여 과거를 판단한다.\")\n    @Test\n    void isBefore() {\n        LocalTime first = LocalTime.of(18, 30, 15);\n        LocalTime second = LocalTime.of(20, 30, 15);\n\n        boolean result = first.isBefore(second);\n\n        assertThat(result).isTrue();\n    }\n\n    @DisplayName(\"두 시간을 비교하여 미래를 판단한다.\")\n    @Test\n    void isAfter() {\n        LocalTime first = LocalTime.of(18, 30, 15);\n        LocalTime second = LocalTime.of(20, 30, 15);\n\n        boolean result = second.isAfter(first);\n\n        assertThat(result).isTrue();\n    }\n\n    @DisplayName(\"동일한 시간의 동등성을 판단한다.\")\n    @Test\n    void equals() {\n        LocalTime first = LocalTime.of(18, 30, 15);\n        LocalTime second = LocalTime.of(18, 30, 15);\n\n        boolean result = first.equals(second);\n\n        assertThat(result).isTrue();\n    }\n}\n```\n\n대부분 `LocalDate`와 유사하지만 시분초 조작에 초점을 두고 있다. 주의해야 할 점은 `LocalTime`의 초와 나노초는 항상 생략이 가능하다. 초를 생략할 경우 `HH:mm`으로 표기된다.\n\n### LocalDateTime\n\n::: tip 공식 문서 중 일부\n\nA date-time without a time-zone in the ISO-8601 calendar system, such as 2007-12-03T10:15:30. LocalDateTime is an immutable date-time object that represents a date-time, often viewed as year-month-day-hour-minute-second. Other date and time fields, such as day-of-year, day-of-week and week-of-year, can also be accessed. Time is represented to nanosecond precision. For example, the value \"2nd October 2007 at 13:45.30.123456789\" can be stored in a LocalDateTime.\n\n**ISO-8601 캘린더 시스템에 \"2007-12-03T 10:15:30\"과 같이 표준 시간대가 없는 날짜이다. LocalDateTime은 날짜/시간을 나타내는 불변의 날짜-시간 객체로 종종 년-월-시-분-초로 표시된다. 시간은 나노초 정밀도로 표현된다. 예를 들면 \"2007년 10월 2일 13:45:30.123456789\" 값은 LocalDateTime에 저장할 수 있다.**\n\nThis class does not store or represent a time-zone. Instead, it is a description of the date, as used for birthdays, combined with the local time as seen on a wall clock. It cannot represent an instant on the time-line without additional information such as an offset or time-zone.\n\n**이 클래스는 표준시를 저장하거나 나타내지 않는다. 대신, 이것은 생일날 사용되는 날짜를 벽시계에 보이는 현지 시간과 결합한 것이다. offset 또는 표준시와 같은 추가 정보 없이 타임라인의 순간을 나타낼 수 없다.**\n\nThe ISO-8601 calendar system is the modern civil calendar system used today in most of the world. It is equivalent to the proleptic Gregorian calendar system, in which today's rules for leap years are applied for all time. For most applications written today, the ISO-8601 rules are entirely suitable. However, any application that makes use of historical dates, and requires them to be accurate will find the ISO-8601 approach unsuitable.\n\n**ISO-8601 달력 체계는 오늘날 대부분의 세계에서 사용되는 현대 민간 달력 체계이다. 이것은 오늘날 윤년에 대한 규칙이 모든 시간에 적용되는 프로프랙틱 그레고리력 체계와 같다. 오늘날 작성된 대부분의 응용 프로그램에는 ISO-8601 규칙이 전적으로 적합하다. 그러나 과거 날짜를 사용하고 정확한 날짜를 요구하는 모든 응용 프로그램은 ISO-8601 접근법이 적합하지 않다는 것을 알게 될 것이다.**\n\nThis is a value-based class; use of identity-sensitive operations (including reference equality (==), identity hash code, or synchronization) on instances of LocalDateTime may have unpredictable results and should be avoided. The equals method should be used for comparisons.\n\n**이것은 값 기반의 클래스이다. (==), 해시 코드 및 동기화와 같은 작업을 할 때 예측할 수 없는 결과가 발생할 수 있으므로 피해야 한다. 비교를 위해서는 동등 방법을 활용해야 한다.**\n\n:::\n\n아래는 간단히 `LocalDateTime`에 존재하는 기능들을 테스트 한 것이다.\n\n```java\npublic class LocalDateTimeTest {\n\n    @DisplayName(\"LocalDateTime을 생성한다.\")\n    @Test\n    void create() {\n        LocalDateTime localDateTime = LocalDateTime.of(2022, 07, 03, 18, 30);\n\n        assertThat(localDateTime).isEqualTo(\"2022-07-03T18:30\");\n    }\n\n    @DisplayName(\"LocalDate와 LocalTime을 활용하여 LocalDateTime을 생성한다.\")\n    @Test\n    void localDateWithLocalTime() {\n        LocalDate localDate = LocalDate.of(2022, 07, 03);\n        LocalTime localTime = LocalTime.of(18, 30);\n\n        LocalDateTime localDateTime = LocalDateTime.of(localDate, localTime);\n\n        assertThat(localDateTime).isEqualTo(\"2022-07-03T18:30\");\n    }\n\n    @DisplayName(\"LocalDateTime을 활용하여 LocalDate와 LocalTime을 구한다.\")\n    @Test\n    void getLocalDateAndGetLocalTime() {\n        LocalDate localDate = LocalDate.of(2022, 07, 03);\n        LocalTime localTime = LocalTime.of(18, 30);\n        LocalDateTime localDateTime = LocalDateTime.of(localDate, localTime);\n\n        assertThat(localDateTime.toLocalDate()).isEqualTo(localDate);\n        assertThat(localDateTime.toLocalTime()).isEqualTo(localTime);\n    }\n}\n```\n\n날짜 및 시간을 더하고 비교하는 것은 앞서 작성한 `LocalDate`, `LocalTime`과 유사하다. 추가로 존재하는 기능은 `LocalDate`와 `LocalTime`을 활용하여 `LocalDateTime`을 손쉽게 만들 수 있고, `LocalDateTime`으로 `LocalDate`와 `LocalTime`을 손쉽게 변환할 수 있다.\n\n## 정리\n\n프로젝트 도입에 앞서 간단히 LocalDate, LocalTime, LocalDateTime의 사용법에 대해 알아보았다. Java에서 날짜 조작에 대한 대부분의 편리한 기능들을 제공하고 있기 때문에 단순히 문자열로 처리하는 것 보다 매우 효율적으로 다룰 수 있다. 또한 JDK 8 이전에 제공된 클래스들은 많은 문제들을 가지고 있었다. JDK 8 이후 등장한 클래스들은 이러한 문제들을 적절히 해결하여 제공되기 때문에 다양한 이점들을 잘 활용하여 사용하면 좋을 것 이라 판단한다.\n\n## References.\n\n[Java의 날짜와 시간 API](https://d2.naver.com/helloworld/645609)<br>\n[Class LocalDate](https://docs.oracle.com/javase/8/docs/api/java/time/LocalDate.html)<br>\n[Class LocalTime](https://docs.oracle.com/javase/8/docs/api/java/time/LocalTime.html)<br>\n[Class LocalDateTime](https://docs.oracle.com/javase/8/docs/api/java/time/LocalDateTime.html)<br>\n[ISO 8601](https://ko.wikipedia.org/wiki/ISO_8601)\n"},{"excerpt":"목표  우아한테크코스에서 진행한 미션의 리뷰와 피드백에 대해 정리한다. 실제 리뷰는 [Spring 장바구니 - 2단계] 매트(최기현) 미션 제출합니다.에서 확인할 수 있다. 08. 2단계 - 장바구니/주문 API 변경하기 확인 드디어 레벨 2의 모든 미션이 마무리 되었다. 우테코에서 레벨 2에서 가져갈 공통적인 목표는 아래와 같다. Spring Frame…","fields":{"slug":"/jwp-shopping-cart-step2/"},"frontmatter":{"date":"June 23, 2022","title":"[레벨 2] 08. 2단계 - 장바구니/주문 API 변경하기","tags":["우아한테크코스","레벨2","미션"]},"rawMarkdownBody":"\n## 목표\n\n![](https://user-images.githubusercontent.com/59357153/152970395-a31c8134-fc89-449f-b4dc-441e03df929c.png)\n\n우아한테크코스에서 진행한 미션의 리뷰와 피드백에 대해 정리한다. 실제 리뷰는 [[Spring 장바구니 - 2단계] 매트(최기현) 미션 제출합니다.](https://github.com/woowacourse/jwp-shopping-cart/pull/93)에서 확인할 수 있다.\n\n## 08. 2단계 - 장바구니/주문 API 변경하기 확인\n\n드디어 레벨 2의 모든 미션이 마무리 되었다. 우테코에서 레벨 2에서 가져갈 공통적인 목표는 아래와 같다.\n\n * Spring Framework를 이용해 웹 애플리케이션을 개발한다.\n * 학습 테스트를 통해 새로운 기술을 익히고 미션에 적용한다.\n * 클라우드 환경에 애플리케이션을 배포하고 운영한다.\n * 새로운 기술을 익히는 본인만의 학습 방법을 찾는다.\n\n그 중 내가 가장 많이 집중한 것은 어떤 기술에 대해 `왜 사용해야 하며 어떠한 근거로 도입이 되었는지 고민`하는 것이다. 의식적인 연습이나 다른 크루들과의 끊임없는 대화를 통해 이전에 혼자 학습하던 습관들을 개선하기 위해 노력하였다. 덕분에 혼자 해답을 찾기 위해 발버둥 치며 놓쳤던 지식들 사이에 온전한 나만의 근거를 채워갈 수 있는 시간이 되었다.\n\n다시 돌아가 위 공통 목표를 살펴보면 약간이지만 대부분 달성했다고 생각한다. 다만 이미 아는 기술에 대해 더 많은 의문을 품지 못한 것이 아쉬움으로 다가온다. 아무래도 Spring에 대한 학습 경험이 있었기 때문에 미션을 진행하는데 무리가 없었지만 딱 사용하는데 그쳤다. 결국 해당 기술에 대해 동작 방식까지는 고려하지 못하여 반쪽 짜리 지식을 만들었다는 생각이 들기도 한다. 이제 남은 기간 동안 부족한 부분을 인지하고 온전한 지식으로 만들기 위한 시간으로 활용해야 겠다.\n\n아래는 레벨 2 마지막 미션을 진행하며 리뷰어와 주고 받은 대화들과 느낀 것들을 정리한 것이다.\n\n## Presentation Layer\n\n`Presentation Layer`는 사용자의 요청과 응답에 대한 처리를 진행한다. 주로 Controller 및 View로 구성되며 사용자와 애플리케이션 사이의 상호작용의 위해 앞단에 위치하게 된다. 이러한 presentation layer의 역할로 아래와 같이 간략하게 정리할 수 있다.\n\n * 사용자의 요청을 변환한다.\n * 요청 내용에 대한 검증을 진행한다.\n * 수행 결과를 사용자에게 반환한다.\n\n이전 미션에서 `Presentation Layer`에서 핵심 비즈니스 로직을 해결하기 위한 `Service layer`를 의존하고 있는 형태로 구성하였다. 하지만 이전에 공통적인 토큰의 인증 및 인가를 위해 `ArgumentResolver`를 등록한 뒤 활용하였다. 결국 이러한 ArgumentResolver를 Presentation Layer로 봐도 되는가에 대한 의문을 가지고 있었다. 결국 이러한 `ArgumentResolver`의 목적은 `parameter가 원하는 형태의 객체로 바인딩`하는 것이다. 즉 컨트롤러의 호출 이전에 활용되며 종속적인 개념으로 사용되기 때문에 Presentation Layer에 가깝다고 정리하였다.\n\n## CORS의 preflight\n\n프론트와 API가 적절한지 테스트하던 중 cors 관련 에러를 마주하게 되었다. 분명 WebConfig에 관련 설정을 추가해두었지만 어째서인지 Options 메서드를 통한 `preflight 요청`에서 `Authorization 헤더`의 부재로 `401` 예외를 마주하게 되었다. 결국 Interceptor에서 `Option 메서드`가 올 경우 아래 로직을 무시할 수 있도록 작성했지만 약간의 찝찝한 부분이 있다.\n\n```java\npublic class AuthenticationInterceptor implements HandlerInterceptor {\n    ...\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {\n        if (HttpMethod.OPTIONS.matches(request.getMethod())) {\n            return true;\n        }\n\n        String accessToken = AuthorizationExtractor.extract(request);\n        jwtTokenProvider.validateToken(accessToken);\n\n        String payload = jwtTokenProvider.getPayload(accessToken);\n        request.setAttribute(ATTRIBUTE_PAYLOAD_KEY, payload);\n        return true;\n    }\n}\n```\n\n결국 `preflight`를 보내는 이유가 이러한 예비 요청을 통해 해당 요청이 안전한지 확인하는 용도로 알고 있다. 하지만 이러한 요청을 무조건적으로 `true`처리하는 것이 적절한지 궁금증이 생겨 질문을 남겼다.\n\n#### 리뷰 중 일부\n\n```markdown\n`매트`: 이러한 요청을 무조건적으로 true 처리하는 것이 적절한지, `리뷰어님`은 동일한 상황에서 어떠한 방식으로 처리하는지 궁금합니다!\n\n`리뷰어`: cors 관련해서 질문주신게 있네요. 사전 요청에 대해서 무조건 true를 주는게 적절한지를 질문주셨는데요. 어쩔수 없이 Interceptor 로직이 태워지기 때문에 OPTIONS에 대해서는 true를 반환하도록 해야하지 않나 싶네요..\n\n`매트`: 별 다른 방법이 없는 것 같네요 ㅜㅠ 그렇다면 서블릿 이전에 거쳐가는 filter에서 CorsFilter를 등록하는 방식은 어떻게 생각하시나요?? 인터셉터를 거치지 않기 때문에 로직 상 더욱 적합하다고 느껴지는데 이에 대해 철시에 대한 의견이 궁금합니다!!\n\n`리뷰어`: CorsFilter를 등록하더라도 Filter -> Interceptor -> 핸들러 메서드 -> Interceptor -> Filter 순으로 동작하기 때문에 인터셉터를 거치지 않도록 만든다는 방법이 잘 이해가 가지 않네요 ㅠ 필터 구현에 대해 생각하신게 있는걸까요?\n\n`매트`: 아래와 같이 preflight request 처리를 위한 헤더(Access-Control-Allow-Origin, Access-Control-Allow-Methods)를 세팅한 뒤 filter 체이닝을 진행하지 않고 200 상태 코드를 반환하는 형식을 생각하고 있었습니다!\n```\n\n```java\n@Component\n@Order(Ordered.HIGHEST_PRECEDENCE)\npublic class CorsFilter implements Filter {\n    ...\n    @Override\n    public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException {\n        HttpServletRequest request = (HttpServletRequest) req;\n        HttpServletResponse response = (HttpServletResponse) res;\n\n        response.setHeader(\"Access-Control-Allow-Origin\", \"*\");\n        response.setHeader(\"Access-Control-Allow-Methods\", \"GET, POST, PUT, DELETE, OPTIONS\");\n        response.setHeader(\"Access-Control-Max-Age\", \"3600\");\n        response.setHeader(\"Access-Control-Allow-Headers\", \"authorization, content-type, xsrf-token\");\n        response.addHeader(\"Access-Control-Expose-Headers\", \"xsrf-token\");\n\n        if(\"OPTIONS\".equalsIgnoreCase(request.getMethod())) {\n            response.setStatus(HttpServletResponse.SC_OK);\n            return;\n        }\n        \n        chain.doFilter(req, res);\n    }\n    ...\n}\n```\n\n```markdown\n서블릿 앞단에 해당 필터를 등록한 뒤 preflight request 요청이 오게 되면 http 메서드를 확인하여 서블릿 및 인터셉터를 타지 않도록 고민하고 있습니다! 결국 Cors의 preflight 관련 처리를 CorsFilter에서 모두 처리하게 되어 책임을 분리할 수 있다고 생각했습니다!\n\n`리뷰어`: 음 결국 모든 도메인과 url에 대해서 사전 요청 OPTIONS에 대해서는 요청을 허용한다는 의미인가보네요. 보안적인 측면에서는 허용해야할 부분만 열어주는게 제일 베스트라고는 생각하는데요. 그렇다면 지금 현재 방식이 더 낫지 않을까 생각이 들기도 하네요 ㅎㅎ..\n```\n\n리뷰어님은 결국 인증이 필요한 부분에서만 해당 요청을 열어주는 것이 좋다고 남겨주었다. CorsFilter를 추가하게 되면 결국 관리해야 할 포인트가 늘어나게 되며 허용하는 `origin`과 `http method`가 변경될 경우 직접적인 수정을 통해 관련 처리를 진행해야 한다. \n\n결국 `CorsFilter`를 도입하지 않았지만 `preflight`와 해결 방법에 대해 공부할 수 있는 시간으로 활용할 수 있었다.\n\n## 객체 의존을 위한 복잡한 sql문\n\n기존에 도메인 객체들은 의존하는 객체의 식별자인 id만을 가지고 있었다. 보다 더 나은 객체지향적인 코드 작성을 위해 각 도메인 객체가 의존하는 객체 자체를 가질 수 있도록 개선하였다. 하지만 최초에 모든 객체를 온전한 상태로 세팅하기 위해 복잡한 sql문을 동반하게 되었다.\n\n```java\n@Repository\npublic class OrdersDetailDao {\n    ...\n    public List<OrdersDetail> findByOrdersId(Long ordersId) {\n        String sql = \"SELECT od.id as id, od.quantity as quantity, \"\n                + \"o.id as orderId, \"\n                + \"c.id as customerId, c.username as customerUsername, c.email as customerEmail, \"\n                + \"c.password as customerPassword, c.address as customerAddress, \"\n                + \"c.phone_number as customerPhoneNumber, \"\n                + \"p.id as productId, p.name as productName, p.price as productPrice, \"\n                + \"p.image_url as productImageUrl, p.description as productDescription, p.deleted as productDeleted \"\n                + \"FROM orders_detail od \"\n                + \"JOIN orders o ON od.orders_id = o.id \"\n                + \"JOIN product p ON od.product_id = p.id \"\n                + \"JOIN customer c ON o.customer_id = c.id \"\n                + \"WHERE orders_id = :ordersId\";\n\n        SqlParameterSource parameterSource = new MapSqlParameterSource(\"ordersId\", ordersId);\n        return jdbcTemplate.query(sql, parameterSource, generateOrderDetailMapper());\n    }\n    ...\n}\n```\n\n현재 도메인에서는 객체간의 의존의 깊이가 낮아서 구현이 가능했지만 만약 깊이가 깊어질 경우 sql문은 더욱 복잡해질 것으로 판단한다. 이것을 작성하며 가장 궁금했던 것은 온전한 객체 생성을 위해 위와 같은 방법을 진행하는 것이 적절한지의 여부이다. 만약 dao와 service 계층 사이 도메인 객체 관리를 위한 repository를 두게 되면 단일 엔티티를 조회하여 조합할 수 있을 것으로 판단한다. 하지만 이 방법은 필요한 각각의 엔티티를 조회하기 위해 추가적인 sql문을 여러번 활용해야 하는 단점이 있다. \n\n#### 리뷰 중 일부\n```markdown\n`리뷰어`: 복잡한 쿼리문에 대해서도 질문주셨는데요. 저도 가능하면 한방쿼리를 통해서 조회하는 쿼리를 많이 사용하기는 한거 같아요. 다만, 반드시 `EXPLAIN`으로 해당 쿼리의 `실행계획`이 어떻게 되는지 확인이 필요하구요. 적절한 인덱스를 타지 않아 부하가 심하다고 생각되면 각각 따로 조회해서 조합해줬던거 같네요. \n\n`매트`: 아직 DB에 대한 개념이 부족하여 주신 리뷰를 완벽하게 이해 하진 못했네요 🥲 `EXPLAIN`과 `인덱스` 키워드를 통해 관련 학습 진행해보겠습니다!!\n```\n\n리뷰어와의 대화를 통해 DB 최적화를 위한 `EXPLAIN`과 `인덱스`에 대한 키워드를 확인할 수 있었다. 방학 기간 동안 Real MySQL을 기반으로 스터디를 진행하는데 이것이 해당 키워드를 이해하는데 좋은 해답이 되지 않을까 생각된다.\n\n## 토큰 검증 및 객체 바인딩 로직 분리\n\n#### 리뷰 중 일부\n```markdown\n`리뷰어`: 기존에는 `AuthenticationPrincipalArgumentResolver`에서 `토큰 검증 및 전달`까지 해줬던걸로 보이는데요. `AuthenticationInterceptor`와 `AuthenticationPrincipalArgumentResolver`로 나눠진것 같네요. 위와 같이 다시 구성하신 이유가 있을까요?\n\n추가로 인터셉터에서 토큰 검증을 해서 attribute로 넘기기때문에 여기서는 getAttribute로 세팅하는 부분만 남은걸로 보이는데요. 만약 getAttribute(\"payload\")에 값이 없는 경우는 어떻게 되나요?\n\n`매트`: ArgumentResolver의 사용 목적에 대해 고민해보았습나다. 그러던 중 ArgumentResolver을 만들기 위해 사용하는 HandlerMethodArgumentResolver의 설명을 확인하였습니다.\n\n> Strategy interface for resolving method parameters into argument values in the context of a given.\n\nSpring에서는 ArgumentResolver를 하나의 전략 인터페이스로 인식하고 있으며 목적은 parameter가 원하는 형태의 객체로 바인딩하는 것이라 생각합니다. 이러한 근거를 기반으로 인증 및 인가에 대한 로직들을 모두 interceptor로 이동하였습니다!\n\n또한 관련 attribute를 누락한 이유는 해당 `AuthenticationPrincipleArgumentResolver`는 항상 interceptor를 거칠 때만 사용해서 관련 검증을 누락시켰습니다! 철시가 언급하신 것 처럼 만약 interceptor를 거치지 않고 argument를 사용하게 되면 관련 atrribute가 존재하지 않게 되므로 관련 처리 진행하였습니다!\n\n`리뷰어`: 현재는 Interceptor로 검증하는 곳과 AuthenticationPrincipleArgumentResolver가 사용되는 곳이 동일하기 때문에 문제가 없지만 만약 추후에 기능이 추가된다고 가정했을때 두 사용하는 곳이 달라질 수 있어서 질문드린거이긴해요. Interceptor의 사용처와 AuthenticationPrincipleArgumentResolver의 사용처를 같게 만드는 것은 사람(개발자)이 하게되는 것이니 휴먼에러의 여지도 있어서요.\n\n값을 바인딩한다는 것에 초점을 맞추신걸로 보이는데 AuthenticationPrincipleArgumentResolver에서도 Authorization 헤더를 가지고 바인딩이 가능한만큼 AuthenticationPrincipleArgumentResolver이 검증부분을 가져가도 괜찮지 않을까 의견드려요.\n\n`매트`: 리뷰어님의 의견에도 동의합니다! 언급해주신 것에 더 나아가 Token에 대한 검증은 필요하지만 LoginCustomer가 필요하지 않은 핸들러가 존재할 때를 고민해보았습니다. 예를들면 admin과 관련된 Role이 추가되어 id라는 식별자를 기반으로 URL(ex. /api/customers/1)에 접근하게 되면 이때 LoginCustomer는 사용되지 않기 때문에 AuthenticationPrincipleArgumentResolver의 검증 로직은 사용할 수 없으며 결국 추가적인 Interceptor를 통해 처리해야 하므로 중복된 코드를 야기하게 된다고 생각하여 현재 작성한 코드가 좀 더 확장에 유연할 수 있다고 판단합니다!\n```\n\n검증하기 위한 위치에 대한 고민이 많았는데 리뷰어와의 대화를 통해 어떠한 상황에서 어떻게 사용될지 조금은 머릿속에 그려질 수 있었다. 결국 ArgumentResolver를 사용하는 곳에서 모두 검증이 일어나기 때문에 추가적인 Interceptor를 활용하는 것은 관리할 포인트만 늘어날 수 있다. \n\n하지만 확장에 유연함과 객체의 책임이 적절한지의 입장에서 보면 각각의 클래스가 최소한의 역할만을 가지고 있기 때문에 변화에 대응하기 용이하다고 판단한다. 결국 단순한 인증 로직만 필요한 컨트롤러가 생길 수 있기 때문이다. \n\n위와 같은 문제는 정해진 정답이 없다고 판단한다. 리뷰어와 유의미한 대화를 통해 다른 시선에서 같은 문제를 더 고민해볼 수 있었고 그로 인해 다른 프로젝트를 진행할 때 내가 알고 있는 배경지식은 두배로 활용될 수 있다. \n\n## References.\n\n * [백엔드 서버 아키텍처 — Presentation Layer 1. 요청 방식에 따른 Variation](https://tech.junhabaek.net/%EB%B0%B1%EC%97%94%EB%93%9C-%EC%84%9C%EB%B2%84-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-presentation-layer-1-%EC%9A%94%EC%B2%AD-%EB%B0%A9%EC%8B%9D%EC%97%90-%EB%94%B0%EB%A5%B8-variation-353fe464bdb4)\n * [CORS는 왜 이렇게 우리를 힘들게 하는걸까?](https://evan-moon.github.io/2020/05/21/about-cors/)\n * [Spring ArgumentResolver와 Interceptor](https://tecoble.techcourse.co.kr/post/2021-05-24-spring-interceptor/)\n"},{"excerpt":"목표  우아한테크코스에서 진행한 미션의 리뷰와 피드백에 대해 정리한다. 실제 리뷰는 [Spring 장바구니 - 1단계] 매트(최기현) 미션 제출합니다.에서 확인할 수 있다. 07. 1단계 - 장바구니 - 협업 미션 확인 이번 미션에서는 실제 동작하는 서비스를 만들기 위한 백엔드, 프론트엔드의 협업을 경험하며 기존에 존재하는 레거시 코드를 기반으로 진행하게…","fields":{"slug":"/jwp-shopping-cart-step1/"},"frontmatter":{"date":"June 20, 2022","title":"[레벨 2] 07. 1단계 - 장바구니 - 협업 미션","tags":["우아한테크코스","레벨2","미션"]},"rawMarkdownBody":"\n## 목표\n\n![](https://user-images.githubusercontent.com/59357153/152970395-a31c8134-fc89-449f-b4dc-441e03df929c.png)\n\n우아한테크코스에서 진행한 미션의 리뷰와 피드백에 대해 정리한다. 실제 리뷰는 [[Spring 장바구니 - 1단계] 매트(최기현) 미션 제출합니다.](https://github.com/woowacourse/jwp-shopping-cart/pull/16)에서 확인할 수 있다.\n\n## 07. 1단계 - 장바구니 - 협업 미션 확인\n\n이번 미션에서는 실제 동작하는 서비스를 만들기 위한 백엔드, 프론트엔드의 협업을 경험하며 기존에 존재하는 레거시 코드를 기반으로 진행하게 되었다. 프론트와 원할한 협업을 위해 API 명세에 많은 시간을 투자했다. 또한 기존에 제공된 레거시 코드 위에서 기능을 추가하였기 때문에 기존에 작성된  테스트 코드가 최대한 망가지지 않도록 유지하며 새로운 기능을 추가하였다.\n\n## 적절한 문서화\n\n![](https://user-images.githubusercontent.com/59357153/174528907-86ec4770-87a8-4bb4-9400-a66d2ff8f4d8.png)\n\n처음으로 프론트와의 협업을 진행했기 때문에 어떠한 방식으로 의사소통 하는 것이 좋은지 고민하였다. 백엔드 팀원들과 상의 끝에 당장 쉽게 적용할 수 있는 노션을 기반으로 API 명세 및 프로젝트를 진행하였고 얻을 수 있는 인사이트들을 정리할 수 있도록 문서화를 진행하였다. 아래는 실제 미션을 진행하며 작성한 [짱바구니 wiki](https://www.notion.so/0f0d2f9b1c4b4f6cb02b0f7215f8cccc)이다. 부족한 부분이 많지만 의식적인 연습을 통해 레벨 3에 경험하게 될 프로젝트의 보탬이 될 수 있도록 노력하였다.\n\n## JWT\n\nJWT (JSON Web Token)은 유저를 인증하고 식별하기 위한 토큰 기반의 인증이다. 이러한 토큰은 기존에 많이 사용하던 세션 & 쿠키와 다르게 서버가 아닌 클라이언트 측에 저장되기 때문에 서버의 부담을 덜 수 있게 되었다. 이러한 JWT에는 토큰 내부에 유저의 식별 정보나 권한 정보를 가질 수 있다는 것이다. 그렇기 때문에 담겨있는 정보가 많은 경우 토큰의 크기가 커질 수 있다.\n\n이러한 JWT 방식 구현을 위해 `JJWT` 라이브러리를 활용하였다. 아래와 같이 `JwtTokenProvider`를 생성하는 시점에 `비밀키`와 `만료 시간`을 설정 파일에서 주입 받아 생성하여 토큰을 생성하고 검증하는 책임을 가지도록 만들었다.\n\n```java\n@Component\npublic class JwtTokenProvider {\n\n    private final SecretKey key;\n    private final long validityInMilliseconds;\n\n    public JwtTokenProvider(@Value(\"${security.jwt.token.secret-key}\") String secretKey,\n                            @Value(\"${security.jwt.token.expire-length}\") long validityInMilliseconds) {\n        this.key = Keys.hmacShaKeyFor(secretKey.getBytes(StandardCharsets.UTF_8));\n        this.validityInMilliseconds = validityInMilliseconds;\n    }\n\n    public String createToken(String payload) {\n        Date now = new Date();\n        Date validity = new Date(now.getTime() + validityInMilliseconds);\n\n        return Jwts.builder()\n                .setSubject(payload)\n                .setIssuedAt(now)\n                .setExpiration(validity)\n                .signWith(key, SignatureAlgorithm.HS256)\n                .compact();\n    }\n\n    public String getPayload(String token) {\n        return Jwts.parserBuilder()\n                .setSigningKey(key)\n                .build()\n                .parseClaimsJws(token)\n                .getBody()\n                .getSubject();\n    }\n\n    public void validateToken(String token) {\n        try {\n            Jws<Claims> claims = Jwts.parserBuilder()\n                    .setSigningKey(key)\n                    .build()\n                    .parseClaimsJws(token);\n\n            claims.getBody().getExpiration().before(new Date());\n        } catch (JwtException | IllegalArgumentException e) {\n            throw new InvalidTokenException();\n        }\n    }\n}\n```\n\n위 객체를 `@Component` 키워드를 통해 Spring이 관리할 수 있도록 설정하여 필요한 곳에서 적절히 활용할 수 있도록 작성하였다. 이제 인증이 필요한 요청 시 `Authorization header`를 통해 들어온 token 정보를 검증하기 위해 `HandlerMethodArgumentResolver`를 구현한 구현체를 만들어 등록시켜주었다.\n\n```java\npublic class AuthenticationPrincipalArgumentResolver implements HandlerMethodArgumentResolver {\n\n    private static final String AUTHORIZATION_HEADER_NAME = \"Authorization\";\n\n    private final JwtTokenProvider jwtTokenProvider;\n\n    public AuthenticationPrincipalArgumentResolver(JwtTokenProvider jwtTokenProvider) {\n        this.jwtTokenProvider = jwtTokenProvider;\n    }\n\n    @Override\n    public boolean supportsParameter(MethodParameter parameter) {\n        return parameter.hasParameterAnnotation(AuthenticationPrincipal.class);\n    }\n\n    @Override\n    public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer,\n                                  NativeWebRequest webRequest, WebDataBinderFactory binderFactory) {\n        String authorizationHeader = webRequest.getHeader(AUTHORIZATION_HEADER_NAME);\n        String accessToken = AuthorizationExtractor.extract(authorizationHeader);\n\n        if (!jwtTokenProvider.validateToken(accessToken)) {\n            throw new InvalidTokenException();\n        }\n\n        String username = jwtTokenProvider.getPayload(accessToken);\n        return new LoginCustomer(username);\n    }\n}\n```\n\n해당 객체는 `@RequestBody`나 `@RequestParam`처럼 `@AuthenticationPrincipal`을 명시하게 되면, `resolveArgument`가 실행된다. 간단한 예로 실제 작성한 컨트롤러의 일부를 가져온 것이다.\n\n```java\n@RestController\n@RequestMapping(\"/api/customers\")\npublic class CustomerController {\n    ...\n    @GetMapping(\"/me\")\n    public ResponseEntity<CustomerResponse> findCustomer(@AuthenticationPrincipal LoginCustomer loginCustomer) {\n        CustomerResponse customerResponse = customerService.find(loginCustomer);\n        return ResponseEntity.ok(customerResponse);\n    }\n    ...\n}\n```\n\n`AuthenticationPrincipalArgumentResolver` 또한 `WebMvcConfigurer`의 `addArgumentResolvers` 메서드를 오버라이딩 하여 추가로 등록하게 되면 기존에 존재하는 `ArgumentResolver`에 추가되어 로직이 수행된다.\n\n```java\n@Configuration\npublic class AuthenticationPrincipalConfig implements WebMvcConfigurer {\n\n    private final JwtTokenProvider jwtTokenProvider;\n\n    public AuthenticationPrincipalConfig(JwtTokenProvider jwtTokenProvider) {\n        this.jwtTokenProvider = jwtTokenProvider;\n    }\n\n    @Override\n    public void addArgumentResolvers(List<HandlerMethodArgumentResolver> argumentResolvers) {\n        argumentResolvers.add(createAuthenticationPrincipalArgumentResolver());\n    }\n\n    @Bean\n    public HandlerMethodArgumentResolver createAuthenticationPrincipalArgumentResolver() {\n        return new AuthenticationPrincipalArgumentResolver();\n    }\n    ...\n}\n```\n\nSpring에서 이미 제공되는 method arguments는 [Method arguments](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-arguments)에서 확인할 수 있다.\n\n결국 `AuthenticationPrincipalArgumentResolver` 통해 반복해서 진행되면 검증 로직들을 제거할 수 있었으며 컨트롤러는 요청과 응답에 대한 처리에 집중할 수 있도록 개선할 수 있게 되었다.\n\n## 제공된 상수 사용하기\n\n기존에 `Authorization` 헤더에서 토큰 값을 꺼내기 위해 해당 문자열을 상수로 추출하여 활용하였다.\n\n```java\npublic class AuthenticationPrincipalArgumentResolver implements HandlerMethodArgumentResolver {\n    ...\n    private static final String AUTHORIZATION_HEADER_NAME = \"Authorization\";\n    ...\n}\n```\n\n#### 리뷰 중 일부\n```markdown\n`리뷰어`: Http 명세에 정의된 헤더는 `org.springframework.http.HttpHeaders`에 상수로 정의되어있어요. 이걸 활용해도 좋을거 같네요 :)\n```\n\n이미 자주 사용하고 있는 HttpHeaders들의 경우 `org.springframework.http.HttpHeaders`에 정의되어 있었다. 아래는 HttpHeaders의 공식 문서 중 일부를 가져온 것이다.\n\n> A data structure representing HTTP request or response headers, mapping String header names to a list of String values, also offering accessors for common application-level data types. \n> **Http 요청 및 응답 헤더를 나타내는 데이터 구조이며, 문자열 헤더 이름을 값 목록에 매핑하고 일반적인 `application-level data`에 접근을 제공한다.**\n\n무작정 상수로 추출하기 보다 기존에 제공된 것이 있는지 확인해보는 습관을 들여야 겠다. 이렇게 프레임워크 차원에서 제공된다는 것은 그만큼 많이 사용되기도 하며 다른 개발자가 해당 코드를 봤을 때 통념적으로 사용되기 때문에 코드의 파악 또한 쉬워질 것이다.\n\n## 클라이언트가 확인하는 예외 메시지\n\n우리는 애플리케이션을 사용하는 사용자에게 예외가 발생할 경우 적절한 메시지를 통해 잘못된 부분들을 알려줘야 한다. 하지만 토큰에 대한 정보가 잘못된 경우 사용자가 과연 알아야 하는 정보인가 생각해볼 필요가 있다.\n\n```java\npublic class InvalidTokenFormatException extends RuntimeException {\n\n    public InvalidTokenFormatException() {\n        this(\"token 형식이 잘못 되었습니다. (형식: Bearer aaaaaaaa.bbbbbbbb.cccccccc)\");\n    }\n}\n```\n\n위 예시를 보면 사용자는 해당 토큰의 형식이 잘못 되었는지 알 필요가 없다. 프론트에서 해당 예외를 확인한 뒤 로그아웃 혹은 재로그인을 위한 로직으로 유도해야 한다. 즉 해당 정보는 오직 프론트 개발자에게 전달하기 위한 목적일 뿐이다.\n\n#### 리뷰 중 일부\n```markdown\n`리뷰어`: 위 메세지는 Advice를 통해서 클라이언트에 응답으로 내려가는 메세지로 보이네요. 혹시 화면에서 위 메세지가 보이는걸까요? 그렇다면 유저 친화적인 메세지로 변경해보면 어떨까요? 트레킹이 필요하다면 로깅을 활용해보면 좋을거 같아요.\n\n`매트`: 해당 예외는 고객에게 전달하기 위한 목적보다 프론트 개발자를 위해 전달하기 위한 목적이었습니다! 프론트 개발자에게 이러한 예외 상황을 전달하기 위해서는 로깅을 활용하는 방법이 선호되어 추천해주신 건가요?!\n\n`리뷰어`: 프론트 개발자에게 에러 상황을 알려주기 위함이군요. 매트가 위 Exception의 메세지를 가지고 트레킹 하는걸로 생각했어서 로깅을 말씀드린거긴해요. 지금 상황에서는 위 응답의 메세지를 프론트에서 사용하지 않도록 가이드가 되어야 할 것 같은데요. 서버에서 에러 상황에 대한 유저 메세지를 제어할 필요는 없을지도 고민해보면 좋을것 같습니다.\n```\n\n결국 이 또한 충분한 대화를 통해 결정해야 할 사안임을 알게 되었고 추가적으로 목적에 따른 로깅 처리에 대해서도 고민할 수 있게 되었다.\n\n## API 콜을 줄이기 위한 방법들\n\n이번 미션에서 API 명세를 진행할 때 수정 및 삭제의 경우 상태 코드를 `204 No Content`로 통일하였다. 관련하여 아래와 같은 리뷰를 확인할 수 있었다.\n\n#### 리뷰 중 일부\n```markdown\n`리뷰어`: 수정, 삭제시 200 응답도 고려해볼 수 있지 않을까 싶은데요. 204를 선택하신 이유가 있을까요?\n\n`매트`: 리소스를 변경하는 행위와 조회하는 행위를 분리하기 위한 목적입니다! 수정과 동시에 조회를 통해 body에 해당 데이터를 담을 수도 있겠지만 한 가지 요청에 너무 많은 책임을 가지고 있다고 생각하여 수정 및 삭제가 완료 되었다는 것을 명시적으로 표현하기 위해204를 활용하였습니다!\n\n`리뷰어`: 프론트 화면이 어떻게 되는지, 어떻게 협의가 되었는지 모르겠지만 수정시에 수정된 결과나 삭제시 삭제한 엔티티의 아이디를 내려주는 경우도 종종있어요. 수정시에 내려준 결과 id나 삭제 id로 프론트 단에서 처리하는 경우에 종종 그렇게 사용하는데요. 이렇게 하면 서버 단에서도 조회하는 API 콜 하나를 줄여줄 수도 있어서 필요하다면 고려해보셔도 괜찮을거 같습니다.\n```\n\n단순한 목적으로는 변경하는 행위와 조회하는 행위를 분리하기 위한 목적이었다. 하지만 리뷰어가 언급하신 것 처럼 서버 단에서 추가적인 조회 API 콜을 줄이기 위한 수단으로 수정 및 삭제 시 엔티티에 대한 정보나 식별자를 반환하는 방식도 고려해볼만 하다고 판단한다.\n\n## References.\n\n * [JWT](https://jwt.io/)\n * [HandlerMethodArgumentResolver](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/method/support/HandlerMethodArgumentResolver.html)\n * [HttpHeaders](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/HttpHeaders.html)\n"},{"excerpt":"목표  우아한테크코스에서 진행한 미션의 리뷰와 피드백에 대해 정리한다. 실제 리뷰는 [Spring 경로 조회 - 2단계] 매트(최기현) 미션 제출합니다.에서 확인할 수 있다. 06. 2단계 - 지하철 경로 조회 확인 2단계에서는 기존 로직에서 요금 정책에 대한 기능들이 추가되었다. 실제로 운영되고 있는 지하철 요금 정책을 대부분 적용했기 때문에 실제 존재…","fields":{"slug":"/atdd-subway-path-step2/"},"frontmatter":{"date":"June 17, 2022","title":"[레벨 2] 06. 2단계 - 지하철 경로 조회","tags":["우아한테크코스","레벨2","미션"]},"rawMarkdownBody":"\n## 목표\n\n![](https://user-images.githubusercontent.com/59357153/152970395-a31c8134-fc89-449f-b4dc-441e03df929c.png)\n\n우아한테크코스에서 진행한 미션의 리뷰와 피드백에 대해 정리한다. 실제 리뷰는 [[Spring 경로 조회 - 2단계] 매트(최기현) 미션 제출합니다.](https://github.com/woowacourse/atdd-subway-path/pull/272)에서 확인할 수 있다.\n\n## 06. 2단계 - 지하철 경로 조회 확인\n\n2단계에서는 기존 로직에서 요금 정책에 대한 기능들이 추가되었다. 실제로 운영되고 있는 지하철 요금 정책을 대부분 적용했기 때문에 실제 존재하는 서비스를 만드는 듯한 느낌도 가져갈 수 있었다.\n\n또한 1단계에서 `도메인에서 특정 라이브러리를 의존하는 문제`에 대한 리뷰가 있었다. 이것을 개선하기 위해 다양한 고민을 진행했으며 나름의 기준도 잡히게 되어 많은 것들을 얻을 수 있는 시간이 되었다.\n\n## 특정 라이브러리에 종속적인 도메인\n\n도메인이 외부 라이브러리에 강하게 의존하게 되면 외부 라이브러리의 변경에 도메인이 매우 취약한 구조가 된다고 생각한다. 많은 고민 끝에 `외부 라이브러리를 사용하는 행위` 자체를 추상화하여 `PathService에 주입`하는 형태로 개선하였다.\n\n```java\npublic interface PathFindable {\n\n    Path findPath(List<Section> sections, Station source, Station target);\n}\n```\n\n경로를 찾기 위해 `findPath`를 가진 `PathFindable` 인터페이스이다. 위 인터페이스를 구현한 구현체가 외부 라이브러리를 가질 수 있도록 작성했다.\n\n```java\n@Component\npublic class ShortestPathFindable implements PathFindable {\n\n    private final WeightedMultigraph<Station, DefaultWeightedEdge> graph;\n\n    public ShortestPathFindable() {\n        this.graph = new WeightedMultigraph<>(SectionEdge.class);\n    }\n    ...\n}\n```\n\n```java\n@Service\n@Transactional(readOnly = true)\npublic class PathService {\n    ...\n    private final PathFindable pathFindable;\n\n    public PathService(SectionDao sectionDao, StationService stationService, PathFindable pathFindable) {\n        this.pathFindable = pathFindable;\n    }\n    ...\n}\n```\n\n이제 도메인에서 더이상 외부 라이브러리를 의존하지 않고 있다. 또한 추후 경로 조회에 대한 요구사항이 변경되면 해당 인터페이스를 기반으로 추가적으로 구현하여 `Bean`으로 등록하면 손쉽게 `PathService`의 의존성을 변경할 수 있다.\n\n더 나아가 현재 패키지 구조는 서비스 패키지에서 해당 인터페이스와 구현체를 모두 가지고 있다. 구현체는 외부 라이브러리를 강하게 의존하고 있기 때문에 도메인의 핵심 비즈니스 로직을 담당하는 서비스 패키지 내부에 위치하는 것이 맞는지에 대한 고민이 있다. 구현체만 외부 패키지 (ex. support)에 두면 도메인 내에 외부 라이브러리의 강한 의존성을 끊어낼 수 있지 않을까 생각한다.\n\n## OCP를 지키자\n\n처음 요금 계산을 진행하기 위해 나이 조건 마다 분기 처리를 위한 if문을 작성하였다.\n\n```java\npublic class Fare {\n    ...\n    private int reduceFare(int fare) {\n        if (age >= 13 && age < 19) {\n            return (int) ((fare - DEDUCTION) * 0.8);\n        }\n\n        if (age >= 6 && age < 13) {\n            return (int) ((fare - DEDUCTION) * 0.5);\n        }\n\n        return fare;\n    }\n    ...\n}\n```\n\n해당 구조는 결국 나이에 대한 조건이 추가된다면 if문이 늘어날 수 밖에 없는 구조를 야기한다. 이것을 개선하기 위해 아래와 같이 enum을 활용하였다.\n\n아래는 거리 비례로 요금 계산을 위한 `DistanceProportionCalculator`이다.\n\n```java\npublic enum DistanceProportionCalculator {\n\n    DEFAULT_STANDARD(distance -> 0 <= distance && distance <= 10, ignored -> 1250),\n    FIRST_STANDARD(distance -> 10 < distance && distance <= 50,\n            distance -> 1250 + (int) ((Math.ceil((distance - 10 - 1) / 5) + 1) * 100)),\n    SECOND_STANDARD(distance -> distance > 50,\n            distance -> 2050 + (int) ((Math.ceil((distance - 50 - 1) / 8) + 1) * 100))\n    ;\n\n    private final Predicate<Integer> condition;\n    private final Function<Integer, Integer> function;\n\n    DistanceProportionCalculator(Predicate<Integer> condition, Function<Integer, Integer> function) {\n        this.condition = condition;\n        this.function = function;\n    }\n\n    public static DistanceProportionCalculator from(int distance) {\n        return Arrays.stream(values())\n                .filter(it -> it.condition.test(distance))\n                .findFirst()\n                .orElseThrow(() -> new IllegalArgumentException(distance + \"는 계산이 불가능한 거리입니다.\"));\n    }\n\n    public int calculateFare(int distance) {\n        return function.apply(distance);\n    }\n}\n```\n\n그 다음 나이별로 할인을 적용하기 위한 `AgeDiscounter`이다.\n\n```java\npublic enum AgeDiscounter {\n\n    INFANT(age -> 0 <= age && age < 6, fare -> 0),\n    CHILDREN(age -> 6 <= age && age < 13, fare -> (int) ((fare - 350) * 0.5)),\n    TEENAGER(age -> 13 <= age && age < 19, fare -> (int) ((fare - 350) * 0.8)),\n    ORDINAL(age -> age >= 19, fare -> fare)\n    ;\n\n    private final Predicate<Integer> condition;\n    private final Function<Integer, Integer> function;\n\n    AgeDiscounter(Predicate<Integer> condition, Function<Integer, Integer> function) {\n        this.condition = condition;\n        this.function = function;\n    }\n\n    public static AgeDiscounter from(int age) {\n        return Arrays.stream(values())\n                .filter(it -> it.condition.test(age))\n                .findFirst()\n                .orElseThrow(() -> new IllegalArgumentException(age + \"는 할인할 수 없는 나이입니다.\"));\n    }\n\n    public int discount(int fare) {\n        return function.apply(fare);\n    }\n}\n```\n\n이제 Fare는 제공된 distance, age, extraFare를 기반으로 필요한 부분을 적절히 호출하여 계산할 수 있다.\n\n```java\npublic class Fare {\n\n    private final int distance;\n    private final int age;\n    private final int extraFare;\n\n    public Fare(int distance, int age, int extraFare) {\n        this.distance = distance;\n        this.age = age;\n        this.extraFare = extraFare;\n    }\n\n    public int calculateFare() {\n        DistanceProportionCalculator distanceProportionCalculator = DistanceProportionCalculator.from(distance);\n        int fare = distanceProportionCalculator.calculateFare(distance);\n        AgeDiscounter ageDiscounter = AgeDiscounter.from(age);\n        return ageDiscounter.discount(fare + extraFare);\n    }\n}\n```\n\n## 비즈니스 로직은 도메인 내부로\n\n```java\n@Service\n@Transactional(readOnly = true)\npublic class PathService {\n    ...\n    private int getMaxExtraFare(Path shortestPath) {\n        List<Section> sections = shortestPath.getSections();\n        return sections.stream()\n                .map(Section::getLine)\n                .mapToInt(Line::getExtraFare)\n                .max()\n                .orElse(DEFAULT_EXTRA_FARE);\n    }\n    ...\n}\n```\n\n#### 리뷰 중 일부\n```markdown\n`리뷰어`: 해당 로직은 service보다 더 적절한 곳이 있을 것 같아요. 😎\n```\n\n### Transaction Script Pattern\n\nService 계층에서 절차지향에 가까운 코드로 비즈니스 로직을 작성하는 것을 마틴파울러는 `Transaction Script Pattern`이라 불렀다.\n\n위 방법은 객체지향 설계보다 단순히 표현 계층의 요청을 처리하기 위한 로직을 Service 계층 내부에 작성한다는 것이다. 결국 로직을 통해 도출된 객체의 경우 단순히 데이터를 표현하기 위한 용도로 사용되기 때문에 객체 내부에 행위를 가지지 않게 된다.\n\n### Domain Model Pattern\n\n`Transaction Script Pattern`은 매우 단순하여 빠르게 로직을 구현할 수 있지만 비즈니스 로직 자체가 복잡해지면 유지보수에 매우 취약한 구조를 야기한다.\n\n즉 객체지향 설계를 기반으로 비즈니스 로직을 도메인 객체 내부로 이동해야 한다. 객체 내부로 적절히 캡슐화하여 기능만 외부에 제공하는 방식으로 진행하면 데이터의 변경이 생겨도 핵심 비즈니스 로직에는 최소한의 영향을 끼치며 유지보수를 진행할 수 있게 된다.\n\n객체지향 설계는 다양한 도메인 모델을 표현하기 위해 추가적인 객체를 작성해야하며 관리해야할 포인트들이 늘어난다. 그럼에도 객체지향 설계를 진행해야 하는 이유는 무엇일까?\n\n * 설계에 대한 이해와 유지보수에 용이하다. 각각의 객체는 작은 책임을 가지기 때문에 각 객체의 역할을 쉽게 확인할 수 있으며 책임의 변화에도 쉽게 변경할 수 있다.\n * 테스트하기 쉬워진다. 각각의 객체들에 비즈니스 로직이 들어있기 때문에 순수한 Java 코드를 기반으로 독립된 테스트를 진행할 수 있다.\n * 확장하기 용이한 구조이다. 다양한 디자인 패턴이나 다형성을 활용하여 실제 코드를 수정하지 않고 내부 구현체를 바꾸는 행위만으로 확장에 용이한 구조를 만들 수 있다.\n\n이제 관련 리뷰를 다시 한번 살펴보자.\n\n#### 리뷰 중 일부\n```markdown\n`리뷰어`: 해당 로직은 service보다 더 적절한 곳이 있을 것 같아요. 😎\n```\n\n기존에 Service 계층에 작성된 `getMaxExtraFare`를 도메인 객체 내부로 이동하여 개선한다.\n\n#### 리뷰 중 일부\n\n```markdown\n`매트`: 언급하신 것 처럼 Lin 컬렉션을 관리하기 위한 Lines를 생성하여 가장 큰 추가 요금을 반환할 수 있도록 개선하였습니다!\n```\n\n```java\npublic class Lines {\n\n    private static final int DEFAULT_EXTRA_FARE = 0;\n\n    private final List<Line> value;\n\n    public Lines(List<Line> value) {\n        this.value = new ArrayList<>(value);\n    }\n\n    public int getMaxExtraFare() {\n        return value.stream()\n                .mapToInt(Line::getExtraFare)\n                .max()\n                .orElse(DEFAULT_EXTRA_FARE);\n    }\n}\n```\n\n## 정리\n\n우테코 이전에 작성한 웹 애플리케이션을 살펴보면 Service 계층에 온갖 중요한 비즈니스 로직을 모두 작성하였다. 당시에는 객체지향에 대한 개념 조차 잡히지 않았으며 왜 그렇게 해야 하는지 조차 인지하지 못했기 때문이다. \n\n또한 도메인이 외부 라이브러리에 의존하는 것이 문제인지 조차 인지하지 못했다. 단순히 주어진 과업을 해결하기 위해 동작만 하도록 만들었다. 하지만 해당 코드들은 내가 작성했지만 리팩토링하기 쉽지 않았다. \n\n객체지향 설계는 많은 이점을 가져온다. 테스트가 용이한 구조가 되며 확장에는 유연하게 대처할 수 있다. 우리는 더 이상 객체지향 설계를 고려하지 않고 작성할 이유가 없다고 생각한다.\n\n## References.\n\n * [Business Logic Organization Patterns](https://github.com/msbaek/memo/blob/master/Business-Logic-Organization-Patterns.md)\n"},{"excerpt":"목표  우아한테크코스에서 진행한 미션의 리뷰와 피드백에 대해 정리한다. 실제 리뷰는 [Spring 경로 조회 - 1단계] 매트(최기현) 미션 제출합니다.에서 확인할 수 있다. 05. 사전 준비, 1단계 - 지하철 경로 조회 확인 이번 지하철 경로 조회에서는 레거시 코드를 기반으로 추가되는 요구사항에 대응하며 변경에 유연한 구조로 설계하는 경험을 진행한다.…","fields":{"slug":"/atdd-subway-path-step1/"},"frontmatter":{"date":"May 31, 2022","title":"[레벨 2] 05. 사전 준비, 1단계 - 지하철 경로 조회","tags":["우아한테크코스","레벨2","미션"]},"rawMarkdownBody":"\n## 목표\n\n![](https://user-images.githubusercontent.com/59357153/152970395-a31c8134-fc89-449f-b4dc-441e03df929c.png)\n\n우아한테크코스에서 진행한 미션의 리뷰와 피드백에 대해 정리한다. 실제 리뷰는 [[Spring 경로 조회 - 1단계] 매트(최기현) 미션 제출합니다.](https://github.com/woowacourse/atdd-subway-path/pull/209)에서 확인할 수 있다.\n\n## 05. 사전 준비, 1단계 - 지하철 경로 조회 확인\n\n이번 지하철 경로 조회에서는 레거시 코드를 기반으로 추가되는 요구사항에 대응하며 변경에 유연한 구조로 설계하는 경험을 진행한다. 또한 다양한 웹 애플리케이션 아키텍처에 대해 알아보며 적절한 방안을 택해 적용한다. \n\n이번 미션에서는 기존 지하철 노선도 코드를 기반으로 최단 경로에 대한 기능을 추가한다. 최단 경로를 구하는 방법으로는 외부 라이브러리인 `jgrapht 라이브러리`를 활용하는 것이 요구 조건에 추가되었다.\n\n## 학습 테스트 \n\n앞서 언급한 것 처럼 외부 라이브러리인 jgrapht를 활용하여 최단 경로를 조회해야 한다. 처음 사용해보는 라이브러리이기 때문에 공식 문서와 예시들을 기반으로 간단한 학습 테스트를 진행하였다.\n\n```java\npublic class JgraphtTest {\n    ...\n    @DisplayName(\"지하철역을 기반으로 최단 경로를 확인한다.\")\n    @Test\n    void getDijkstraShortestPathWithStation() {\n        WeightedMultigraph<Station, DefaultWeightedEdge> graph = new WeightedMultigraph(DefaultWeightedEdge.class);\n        Station 낙성대역 = new Station(\"낙성대역\");\n        Station 신림역 = new Station(\"신림역\");\n        Station 신대방역 = new Station(\"신대방역\");\n        Station 신도림역 = new Station(\"신도림역\");\n        graph.addVertex(낙성대역);\n        graph.addVertex(신림역);\n        graph.addVertex(신대방역);\n        graph.addVertex(신도림역);\n        graph.setEdgeWeight(graph.addEdge(낙성대역, 신림역), 10);\n        graph.setEdgeWeight(graph.addEdge(신림역, 신대방역), 10);\n        graph.setEdgeWeight(graph.addEdge(신대방역, 신도림역), 10);\n        graph.setEdgeWeight(graph.addEdge(낙성대역, 신도림역), 50);\n\n        DijkstraShortestPath dijkstraShortestPath = new DijkstraShortestPath(graph);\n        GraphPath<Station, DefaultWeightedEdge> shortestPath = dijkstraShortestPath.getPath(낙성대역, 신도림역);\n        List<Station> vertexes = shortestPath.getVertexList();\n\n        assertAll(\n                () -> assertThat(vertexes.size()).isEqualTo(4),\n                () -> assertThat(shortestPath.getWeight()).isEqualTo(30)\n        );\n    }\n}\n```\n\n덕분에 페어와 함께 빠르게 사용법에 대해 익힐 수 있었다. 또한 라이브러리에서 다양한 기능들을 제공해주었기 때문에 요구사항 달성이 생각보다 어렵지 않게 느껴졌다. 역시 잘 만들어진 것을 사용하는 것도 좋은 해결책이 될 수 있다는 생각이 들었다.\n\n## 식별자를 가진 객체의 동등성 비교\n\n이번 미션을 해결하며 대부분의 도메인 객체 들이 식별자인 Id를 가지도록 작성하였다. 이러한 객체들의 동등성 비교를 위해서 Id를 포함한 모든 객체들을 비교하여 작성하였다. 아래는 실제 적용한 예시입니다.\n\n```java\npublic class Section {\n\n    private final Long id;\n    private final Line line;\n    private Station upStation;\n    private Station downStation;\n    private int distance;\n    ...\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || getClass() != o.getClass()) {\n            return false;\n        }\n        Section section = (Section) o;\n        return distance == section.distance && Objects.equals(id, section.id) && Objects.equals(line,\n                section.line) && Objects.equals(upStation, section.upStation) && Objects.equals(\n                downStation, section.downStation);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(id, line, upStation, downStation, distance);\n    }\n}\n```\n\n이러한 선택을 한 이유는 필드가 가변인 변수를 포함하기 때문이다. 즉 도메인 필드가 변할 우려가 있기 때문에 모든 필드가 동일해야 같은 객체를 보장한다고 생각했다. 하지만 이렇게 되면 유일한 식별자인 id의 특징이 모호 해질 것 같다고 생각된다.\n\n추가적으로 현재 해당 도메인을 실제 DB에 영속 시켜야만 id 값을 가져올 수 있다. 만약 영속되지 않은 객체와 비교해야 할 때 id는 null로 비교가 불가능할 것 같은데 이럴 땐 Id를 제외한 나머지로 동등성을 판단해야 할까? 관련하여 리뷰어에게 질문을 드렸다.\n\n#### 리뷰 중 일부\n```markdown\n`리뷰어`: 현재 도메인에서는 식별자가 없다면 동등성을 보장할 수 없을 것 같아요 😓\n```\n\n사실 이에 대한 생각은 이전 미션에서 어느정도 정리할 수 있었다. 다시 한번 언급하면 아래와 같다.\n\n> 대한민국에 사는 국민이라면 유일한 식별자 번호인 `주민번호`를 가지고 있을 것이다. 내 이름이 `매트`에서 `패트`로 변경되어도 `주민번호라는 식별자`는 변하지 않기 때문에 유일한 객체임을 보장한다. 이것은 단순히 유일함을 나타내는 필드일 뿐 DB에 의존하고 있다는 것을 내포하지 않는다. 즉 도메인에서 활용하는 식별자는 비즈니스 로직의 요구사항의 일부분 이기 때문에 충분히 활용될 수 있을 것이다.\n\n## 읽기 좋은 테스트\n\n이번에 인수 테스트를 작성할 때 좀 더 읽기 좋은 문서화를 위해 테스트에서 사용하는 변수명은 한글로 작성하였다. `인수 테스트`의 경우는 다른 의사소통 집단과의 시나리오를 기반으로 진행하기 때문에 좀 더 읽기 좋은 테스트 코드를 작성해야 한다. 한글로 작성하게 된다면 Java 언어를 모르는 사람도 쉽게 읽을 수 있을 것이다.\n\n```java\n@DisplayName(\"경로 관련 기능\")\npublic class PathAcceptanceTest extends AcceptanceTest {\n\n    @DisplayName(\"경로 조회\")\n    @TestFactory\n    Stream<DynamicTest> dynamicTestFromPath() {\n        Long 건대입구역 = generateStationId(\"건대입구역\");\n        Long 강남구청역 = generateStationId(\"강남구청역\");\n        Long 대림역 = generateStationId(\"대림역\");\n        Long 낙성대역 = generateStationId(\"낙성대역\");\n\n        Long line7 = generateLineId(\"7호선\", \"deep green\", 건대입구역, 강남구청역, 10);\n        addSection(line7, 강남구청역, 대림역, 10);\n\n        Long line2 = generateLineId(\"2호선\", \"green\", 건대입구역, 낙성대역, 5);\n        addSection(line2, 낙성대역, 대림역, 5);\n    }\n    ...\n}\n```\n\n#### 리뷰 중 일부\n```markdown\n`리뷰어`: 읽기 좋은 테스트 👍 Station이 아닌 Long 타입이니 변수명에 아이디임을 나타내도 좋겠네요!\n```\n\n## to be continue...\n\n#### 리뷰 중 일부\n```markdown\n`리뷰어`: 도메인에서 특정 라이브러리에 의존하게 된다면 어떤 문제가 있을까요? 또 문제를 해결하기 위해 어떤 방법이 있을지 고민해보면 좋을 것 같습니다 :)\n```\n\n언급하신 것 처럼 도메인이 특정 라이브러리에 의존하게 되면 외부 라이브러리의 변경에 도메인이 매우 취약한 구조가 된다고 생각한다. 이것은 다음 미션을 진행하며 개선된 사항들을 정리하려 한다.\n\n## References.\n\n * [jgrapht](https://jgrapht.org/)\n"},{"excerpt":"개요 란 데이터를 실시간으로 처리하는 것이 아니라 일괄적으로 모아 하는 것을 의미한다. 의  메서드와 를 비교하여 배치로 진행한 것과 일반적으로 처리한 것에 어떠한 차이가 있는지 알아보려 한다. 프로젝트 세팅 github repository 바로가기 우선 Spirng 환경에서 jdbc와 h2 DB를 활용하기 위해 아래와 같이 에 의존성을 추가하였다. 단순…","fields":{"slug":"/spring-jdbc-batch/"},"frontmatter":{"date":"May 24, 2022","title":"Spring JDBC로 batch 활용하기","tags":["우아한테크코스","JDBC","spring-jdbc","batch"]},"rawMarkdownBody":"\n![](https://user-images.githubusercontent.com/59357153/152970395-a31c8134-fc89-449f-b4dc-441e03df929c.png)\n\n## 개요\n\n`batch`란 데이터를 실시간으로 처리하는 것이 아니라 일괄적으로 모아 `한번에 처리`하는 것을 의미한다. `JdbcTemplate`의 `update` 메서드와 `batchUpdate`를 비교하여 배치로 진행한 것과 일반적으로 처리한 것에 어떠한 차이가 있는지 알아보려 한다.\n\n## 프로젝트 세팅\n\n[github repository 바로가기](https://github.com/hyeonic/blog-code/tree/main/spring-jdbc-batch)\n\n우선 Spirng 환경에서 jdbc와 h2 DB를 활용하기 위해 아래와 같이 `build.gradle`에 의존성을 추가하였다.\n\n```groovy\nplugins {\n    id 'org.springframework.boot' version '2.7.0'\n    id 'io.spring.dependency-management' version '1.0.11.RELEASE'\n    id 'java'\n}\n\ngroup = 'me.hyeonic'\nversion = '0.0.1-SNAPSHOT'\nsourceCompatibility = '11'\n\nrepositories {\n    mavenCentral()\n}\n\ndependencies {\n    implementation 'org.springframework.boot:spring-boot-starter-jdbc'\n\n    runtimeOnly 'com.h2database:h2'\n\n    testImplementation 'org.springframework.boot:spring-boot-starter-test'\n}\n\ntasks.named('test') {\n    useJUnitPlatform()\n}\n```\n\n단순한 예제를 작성하기 위해 domain 패키지 하위에 지하철역을 나타내는 `Station` 객체를 추가한다.\n\n```java\npublic class Station {\n\n    private final Long id;\n    private final String name;\n\n    public Station(Long id, String name) {\n        this.id = id;\n        this.name = name;\n    }\n\n    public Station(String name) {\n        this(null, name);\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public String getName() {\n        return name;\n    }\n}\n```\n\n## JdbcTemplate의 update 메서드\n\n보통 `JdbcTemplate`의 `update`의 메서드를 활용하여 데이터를 `insert`하기 위해 아래와 같이 작성할 수 있다.\n\n```java\n@Repository\npublic class JdbcTemplateStationDao {\n\n    private final JdbcTemplate jdbcTemplate;\n\n    public JdbcTemplateStationDao(JdbcTemplate jdbcTemplate) {\n        this.jdbcTemplate = jdbcTemplate;\n    }\n\n    public void save(Station station) {\n        String sql = \"insert into STATION (name) values (?)\";\n        jdbcTemplate.update(sql, station.getName());\n    }\n}\n```\n\n여러번의 `insert`를 테스트하기 위해 아래와 같이 테스트 코드를 작성한 뒤 실행해보았다.\n\n```java\n@JdbcTest\nclass JdbcTemplateStationDaoTest {\n\n    private final JdbcTemplateStationDao jdbcTemplateStationDao;\n\n    @Autowired\n    public JdbcTemplateStationDaoTest(JdbcTemplate jdbcTemplate) {\n        this.jdbcTemplateStationDao = new JdbcTemplateStationDao(jdbcTemplate);\n    }\n\n    @DisplayName(\"batch 사용하지 않고 저장한다.\")\n    @Test\n    void batch_사용하지_않고_저장한다() {\n        long start = System.currentTimeMillis();\n\n        for (int i = 0; i < 10000; i++) {\n            String name = String.valueOf(i);\n            jdbcTemplateStationDao.save(new Station(name));\n        }\n\n        long end = System.currentTimeMillis();\n        System.out.println(\"수행시간: \" + (end - start) + \" ms\");\n    }\n}\n```\n\n```\n수행시간: 402 ms\n```\n\n여러번의 `insert`를 진행할 때 아래와 같은 형태로 쿼리가 요청될 것이다.\n\n```sql\ninsert into STATION (name) values (?)\ninsert into STATION (name) values (?)\ninsert into STATION (name) values (?)\ninsert into STATION (name) values (?)\ninsert into STATION (name) values (?)\ninsert into STATION (name) values (?)\ninsert into STATION (name) values (?)\n...\n```\n\n## JdbcTemplate의 batchUpdate 메서드\n\n`JdbcTemplate` `batchUpdate`를 활용하면 아래와 같이 일괄적으로 한 번에 처리가 가능하다.\n\n```sql\ninsert into STATION (name) \nvalues (?),\n       (?),\n       (?),\n       (?),\n       (?),\n       (?),\n       ...\n```\n\n이것을 달성하기 위해서는 아래와 같이 코드를 작성해야 한다.\n\n```java\n@Repository\npublic class JdbcTemplateStationDao {\n\n    private final JdbcTemplate jdbcTemplate;\n\n    public JdbcTemplateStationDao(JdbcTemplate jdbcTemplate) {\n        this.jdbcTemplate = jdbcTemplate;\n    }\n\n    public void saveAll(List<Station> stations) {\n        String sql = \"insert into STATION (name) values (?)\";\n\n        jdbcTemplate.batchUpdate(sql, new BatchPreparedStatementSetter() {\n            @Override\n            public void setValues(PreparedStatement ps, int i) throws SQLException {\n                Station station = stations.get(i);\n                ps.setString(1, station.getName());\n            }\n\n            @Override\n            public int getBatchSize() {\n                return stations.size();\n            }\n        });\n    }\n}\n```\n\n`batchUpdate`의 첫 번째 매개변수로 배치 처리하기 위한 쿼리문이 들어가고 두 번째 매개 변수에는 `BatchPreparedStatementSetter`의 구현체가 들어간다.\n\n * `setValues`: 준비된 쿼리의 매개 변수 값을 설정할 수 있다. `getBatchSize`에서 명시한 횟수 만큼 호출한다.\n * `getBatchSize` 현재 배치의 크기를 제공한다.\n\n이제 배치를 활용하여 앞서 진행한 테스트와 동일한 데이터를 기반으로 테스트를 진행한다.\n\n```java\n@JdbcTest\nclass JdbcTemplateStationDaoTest {\n\n    private final JdbcTemplateStationDao jdbcTemplateStationDao;\n\n    @Autowired\n    public JdbcTemplateStationDaoTest(JdbcTemplate jdbcTemplate) {\n        this.jdbcTemplateStationDao = new JdbcTemplateStationDao(jdbcTemplate);\n    }\n\n    @DisplayName(\"batch 사용하고 저장한다.\")\n    @Test\n    void batch_사용하여_저장한다() {\n        List<Station> stations = IntStream.range(0, 10000)\n                .mapToObj(String::valueOf)\n                .map(Station::new)\n                .collect(toList());\n\n        jdbcTemplateStationDao.saveAll(stations);\n    }\n}\n```\n\n위 테스트의 수행 시간은 아래와 같다.\n\n```\n수행시간: 221 ms\n```\n\n정리하면 배치를 이용한 insert가 일반적으로 빠른 것을 확인 할 수 있다.\n\n## NamedParameterJdbcTemplate을 활용한 batch\n\n`NamedParameterJdbcTemplate`을 활용한 배치 처리도 가능하다.\n\n```java\n@Repository\npublic class NamedParameterJdbcTemplateStationDao {\n\n    private final NamedParameterJdbcTemplate namedParameterJdbcTemplate;\n\n    public NamedParameterJdbcTemplateStationDao(JdbcTemplate jdbcTemplate) {\n        this.namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(jdbcTemplate);\n    }\n\n    public void save(Station station) {\n        String sql = \"insert into STATION (name) values (:name)\";\n        SqlParameterSource params = new MapSqlParameterSource(\"name\", station.getName());\n        namedParameterJdbcTemplate.update(sql, params);\n    }\n\n    public void saveAll(List<Station> stations) {\n        String sql = \"insert into STATION (name) values (:name)\";\n        SqlParameterSource[] batch = generateParameters(stations);\n        namedParameterJdbcTemplate.batchUpdate(sql, batch);\n    }\n\n    private SqlParameterSource[] generateParameters(List<Station> stations) {\n        return stations.stream()\n                .map(this::generateParameter)\n                .toArray(SqlParameterSource[]::new);\n    }\n\n    private SqlParameterSource generateParameter(Station station) {\n        return new MapSqlParameterSource(\"name\", station.getName());\n    }\n}\n```\n\n대부분 사용법은 유사하지만 `NamedParameterJdbcTemplate`의 `batchUpdate`의 두번째 매개 변수로 추가적인 인터페이스를 구현하지 않고 단순히 `SqlParameterSource[]`가 들어간다. \n\n또한 `SqlParameterSourceUtils`를 활용하면 리스트를 활용하여 간편하게 `SqlParameterSource[]`을 만들 수 있다.\n\n```java\n@Repository\npublic class NamedParameterJdbcTemplateStationDao {\n    ...\n    public void saveAll(List<Station> stations) {\n        String sql = \"insert into STATION (name) values (:name)\";\n        namedParameterJdbcTemplate.batchUpdate(sql, SqlParameterSourceUtils.createBatch(stations));\n    }\n}\n```\n\n이 또한 테스트를 진행해보면 아래와 같이 유의미한 차이를 확인할 수 있었다.\n\n```java\n@JdbcTest\nclass NamedParameterJdbcTemplateStationDaoTest {\n\n    private final NamedParameterJdbcTemplateStationDao namedParameterJdbcTemplateStationDao;\n\n    @Autowired\n    public NamedParameterJdbcTemplateStationDaoTest(JdbcTemplate jdbcTemplate) {\n        this.namedParameterJdbcTemplateStationDao = new NamedParameterJdbcTemplateStationDao(jdbcTemplate);\n    }\n\n    @DisplayName(\"batch 사용하지 않고 저장한다.\")\n    @Test\n    void batch_사용하지_않고_저장한다() {\n        long start = System.currentTimeMillis();\n\n        for (int i = 0; i < 10000; i++) {\n            String name = String.valueOf(i);\n            namedParameterJdbcTemplateStationDao.save(new Station(name));\n        }\n\n        long end = System.currentTimeMillis();\n        System.out.println(\"수행시간: \" + (end - start) + \" ms\");\n    }\n\n    @DisplayName(\"batch 사용하고 저장한다.\")\n    @Test\n    void batch_사용하여_저장한다() {\n        long start = System.currentTimeMillis();\n\n        List<Station> stations = IntStream.range(0, 10000)\n                .mapToObj(String::valueOf)\n                .map(Station::new)\n                .collect(toList());\n\n        namedParameterJdbcTemplateStationDao.saveAll(stations);\n\n        long end = System.currentTimeMillis();\n        System.out.println(\"수행시간: \" + (end - start) + \" ms\");\n    }\n}\n```\n\n```\n수행시간: 531 ms\n수행시간: 236 ms\n```\n\n## References.\n\n[3.5. JDBC Batch Operations](https://docs.spring.io/spring-framework/docs/current/reference/html/data-access.html#jdbc-advanced-jdbc)\n"},{"excerpt":"목표  우아한테크코스에서 진행한 미션의 리뷰와 피드백에 대해 정리한다. 실제 리뷰는 [Spring 지하철 노선도 - 3단계] 매트(최기현) 미션 제출합니다.에서 확인할 수 있다. 04. 3단계 - 지하철 노선도 확인 이번 미션에서는 지하철역과 노선을 기반으로 지하철 구간을 추가하기 위한 API가 추가되었다. 구간 추가를 위한 복잡한 요구사항이 추가되어 그…","fields":{"slug":"/atdd-subway-map-step2/"},"frontmatter":{"date":"May 19, 2022","title":"[레벨 2] 04. 3단계 - 지하철 노선도","tags":["우아한테크코스","레벨2","미션"]},"rawMarkdownBody":"\n## 목표\n\n![](https://user-images.githubusercontent.com/59357153/152970395-a31c8134-fc89-449f-b4dc-441e03df929c.png)\n\n우아한테크코스에서 진행한 미션의 리뷰와 피드백에 대해 정리한다. 실제 리뷰는 [[Spring 지하철 노선도 - 3단계] 매트(최기현) 미션 제출합니다.](https://github.com/woowacourse/atdd-subway-map/pull/283)에서 확인할 수 있다.\n\n## 04. 3단계 - 지하철 노선도 확인\n\n이번 미션에서는 지하철역과 노선을 기반으로 지하철 구간을 추가하기 위한 API가 추가되었다. 구간 추가를 위한 복잡한 요구사항이 추가되어 그것을 적절히 검증하기 위한 테스트 코드 작성에 많은 시간을 투자하게 되었다. \n\n## 도메인?? 엔티티??\n\n보통 DB 테이블과 매핑 되는 객체를 Entity라고 알고 있다. 하지만 이번 미션에서 제공된 Line, Station, Section의 경우 Entity 처럼 생겼지만 도메인 패키지 내부에 위치하고 있었다. 또한 필드 들은 대부분 DB에 저장된 `Primary Key`를 가지고 있었다. \n\n레벨 1 미션을 진행할 때는 DB에 대해 전혀 고려하지 않았기 때문에 도메인 로직에 집중하여 객체를 설계할 수 있었다. 하지만 DB에서 조회한 데이터를 적절히 Mapping하며 도메인 객체로 변환하는 것은 생각보다 쉽지 않게 다가왔다. 결국 이번 미션을 접할 때도 아래와 같이 DB에 의존적인 코드를 작성하는 듯한 기분이 들었다.\n\n```java\npublic class Section {\n    \n    private Long id;\n    private Long lineId;\n    private Long upStationId;\n    private Long downStationId;\n    private int distance;\n    ...\n}\n```\n\n하지만 좀 더 객체지향에 가까운 코드를 작성하려면 아래와 같은 형태가 되어야 한다고 생각했다. 각각의 필드들은 객체의 식별자를 가지는 것이 아닌 객체 자체가 담겨야 한다는 것이다.\n\n```java\npublic class Section {\n\n    private Long id;\n    private Line line;\n    private Station upStation;\n    private Station downStation;\n    private Integer distance;\n    ...\n}\n```\n\n관련된 고민을 진행하던 중 리뷰어에게 질문을 던졌다. \n\n#### 리뷰 중 일부\n```markdown\n`매트`: 결국 이것을 해결하기 위해서는 도메인과 엔티티의 개념을 분리하여 관리해야 할까요??\n```\n\n#### 리뷰 중 일부\n```markdown\n`리뷰어`: 현재 도메인과 엔티티를 나누면 달라지는게 있을까요? 지금 문제는 도메인코드를 객체사이에 참조하게됐을 때, 쿼리를 작성하기가 어려운 부분이 문제 아닌가요?\n```\n\n그렇다. Dao를 통해 온전한 도메인 객체를 만들기 위해서는 연관된 테이블을 적절히 `join`하여 사용하기 때문에 복잡한 쿼리문을 동반하게 된다. \n\n`Section`의 경우 `Line`과 `Station` 객체를 가지고 있다. 조회 시 적절히 데이터를 Mapping 하기 위해서는 아래와 같은 `sql`이 필요하게 된다.\n\n```java\n@Repository\npublic class SectionDao {\n   ...\n   public List<Section> findByLineId(Long lineId) {\n        String sql = \"select s.id, \"\n                + \"s.line_id, l.name as line_name, l.color as line_color, \"\n                + \"s.up_station_id, up.name as up_station_name, \"\n                + \"s.down_station_id, down.name as down_station_name, \"\n                + \"s.distance \"\n                + \"from SECTION s \"\n                + \"join LINE l on s.line_id = l.id \"\n                + \"join STATION up on s.up_station_id = up.id \"\n                + \"join STATION down on s.down_station_id = down.id \"\n                + \"where s.line_id = :lineId\";\n\n        return jdbcTemplate.query(sql, Map.of(\"lineId\", lineId), generateRowMapper());\n    }\n    ...\n}\n```\n\n이러한 sql의 결과로 아래와 같은 `RowMapper`를 통해 객체를 생성하여 반환하게 된다.\n\n```java\n@Repository\npublic class SectionDao {\n   ...\n    private RowMapper<Section> generateRowMapper() {\n        return (resultSet, rowNum) -> {\n            Long sectionId = resultSet.getLong(\"id\");\n\n            Long lineId = resultSet.getLong(\"line_id\");\n            String lineName = resultSet.getString(\"line_name\");\n            String lineColor = resultSet.getString(\"line_color\");\n            Line line = new Line(lineId, lineName, lineColor);\n\n            Long upStationId = resultSet.getLong(\"up_station_id\");\n            String upStationName = resultSet.getString(\"up_station_name\");\n            Station upStation = new Station(upStationId, upStationName);\n\n            Long downStationId = resultSet.getLong(\"down_station_id\");\n            String downStationName = resultSet.getString(\"down_station_name\");\n            Station downStation = new Station(downStationId, downStationName);\n\n            int distance = resultSet.getInt(\"distance\");\n\n            return new Section(sectionId, line, upStation, downStation, distance);\n        };\n    }\n    ...\n}\n```\n\n이제 Section은 다른 객체의 식별자가 아닌 객체를 가지고 있기 때문에 객체 탐색으로 해당 객체의 정보를 획득할 수 있다. 복잡한 쿼리문을 작성해야 하지만 보다 더 객체지향 적인 코드를 작성할 수 있기 때문에 장점이 더큰 리팩토링이라고 생각한다.\n\n하지만 만약 도메인 객체의 참조가 깊은 경우는 어떻게 해야 할까? 결국 해당 객체를 온전히 생성하기 위해서는 더욱 더 복잡하고 이해하기 어려운 쿼리를 작성해야 할 것이다. 이것은 아직 직면한 상황은 아니지만 충분히 고려해야 할 부분이라고 생각한다. \n\n현재는 단순한 요구사항이기 때문에 비교적 적은 노력으로 온전한 도메인 객체를 만들 수 있었다. 만약 복잡한 테이블과 도메인 구조를 동반하게 된다면 매번 복잡한 쿼리를 작성하는 것은 쉽지 않을 것으로 판단한다. 결국 이것이 `SQL Mapper`의 한계일까?\n\n#### 리뷰 중 일부\n```markdown\n`리뷰어`: 말씀해주신대로 매번 쿼리를 만들어내기가 어려운 부분은 있는 것 같습니다. 나중에 배울 Spring Data를 활용하면 쉽게 가져올 수 있을 것 같습니다. 하지만 Spring Data도 만능은 아닙니다. 복잡한 쿼리는 SQL Mapper나 JDBC를 통해서 조회합니다. 즉 JPA만이 정답은 아니라고 말씀드리고싶네요.\n```\n\n언급해주신 것 처럼 ORM을 활용하게 되면 DB 테이블의 값들을 편리하게 객체로 생성하여 관리할 수 있다. 아직 JPA를 활용한 미션을 진행하진 않았지만 ORM이 만능 해결책은 될 수 없다는 것을 염두해 두어야 겠다.\n\n## 도메인 vs 엔티티\n\n위에 언급한 것 처럼 객체가 id와 같은 식별자를 가진 경우 Entity의 성격을 가진 객체라고 생각했다.\n\n#### 리뷰 중 일부\n```markdown\n`매트`: 이전에 미션을 진행할 때 핵심 비즈니스 로직을 가진 도메인 객체는 `dao와 같은 영속 계층에 의존하는 구조`는 DB에 의존적인 코드를 작성할 수 있기 때문에 를 좋지 않다는 것을 학습하였습니다. 이번에 제공된 코드를 확인했을 때 domain 패키지 내부에 평소에 생각했던 `Entity`와 비슷한 객체가 위치한 것을 확인했습니다. 물론 Entity도 내부 필드를 활용한 로직을 작성할 수 있지만 식별자를 가지기 때문에 영속 계층과 가까운 객체라고 생각했습니다.\n\n하지만 이번 개선을 통해 `Entity`라고 생각했던 Section은 단순히 DB와 매핑되는 것을 넘어 비즈니스의 핵심 로직 까지 가지게 되었습니다. 결국 `Entity`도 `domain의 일부분`처럼 사용될 수 있다고 이해해도 괜찮을까요?\n```\n\n위와 같은 질문에 아래와 같은 답변을 확인할 수 있었다.\n\n#### 리뷰 중 일부\n```markdown\n`리뷰어`: 개인적으로 도메인객체가 id를 갖고 있다고해서 영속성에 의존한다고 생각하지 않습니다. 도메인객체도 id를 갖을 수 있지 않을까요?\n사람의 식별자(주민번호), 차량의 식별자(차량번호) 등이 있을텐데, 이것도 데이터베이스에 의존하는걸까요?\n```\n\n대한민국에 사는 국민이라면 유일한 식별자 번호인 `주민번호`를 가지고 있을 것이다. 내 이름이 `매트`에서 `패트`로 변경되어도 `주민번호라는 식별자`는 변하지 않기 때문에 유일한 객체임을 보장한다. 이것은 단순히 유일함을 나타내는 필드일 뿐 DB에 의존하고 있다는 것을 내포하지 않는다. 즉 도메인에서 활용하는 식별자는 비즈니스 로직의 요구사항의 일부분 이기 때문에 충분히 활용될 수 있을 것이다.\n\n## service가 service를 의존하는 것\n\n`LineService`를 작성하던 중 노선은 많은 책임을 가지고 있기 때문에 다양한 `Dao를 의존`하도록 설계하였다. 하지만 `StationDao`의 경우 `StationService`도 존재하기 때문에 `LineService`가 `StationDao`를 의존할 경우 `검증을 위한 중복된 코드`를 야기하게 되었다.\n\nService가 Dao를 가지는 것은 Dao가 Service를 의존하지 않기 때문에 단방향 의존성을 보장한다고 생각한다. 만약 Service가 Service를 의존하게 될 경우 잘못된 설계에 의해 상호 참조될 우려가 있다고 판단했다. \n\n#### 리뷰 중 일부\n```markdown\n`리뷰어`: 예를들어 LineService가 StationDao를 의존하게되면 어떤 문제가 발생할 수 있을까요? 또 Service를 의존했을 때 장단점을 정리해주시면 좋을 것 같습니다 🙂\n```\n\n#### 리뷰 중 일부\n```markdown\n`매트`: 현재 구조 처럼 StationService가 존재할 때 StationDao를 참조하는 것은 좋지 않다고 생각됩니다. 현재는 단순한 구조이지만 Service 계층에는 주요 비즈니스 로직의 검증과 트랜잭션을 통한 데이터 무결성을 지키고 있기 때문에 직접적으로 dao를 사용할 때 보다 안전하게 사용이 가능하고 중복 코드를 줄일 수 있습니다.\n\n하지만 한 가지 주의해야 할 점은 뚜렷한 상위 하위의 계층 구조를 가지고 있어야 한다는 것입니다. 만약 StationService에서도 LineService를 참조하게 되면 상호 참조로 인해 애플리케이션이 시작되지도 못할 것 입니다. 이것은 설계에 문제가 있다는 것을 암시하기 때문에 로직들을 적절한 책임을 가진 객체로 이전해야 합니다.\n```\n\n추가적으로 관련하여 크루들과 이야기를 나누던 중 굉장히 감명 깊게 들은 말이 있었다.\n\n#### 익명의 크루\n\n```markdown\n도메인에서도 다른 도메인을 가질 수 있는데 그게 왜 이상하냐?\n```\n\n## 노선도의 순서를 보장하기 위한 방법들\n\n노선에 적절히 추가할 수 있는 구간인지 검증 및 적절히 추가, 삭제를 위한 용도로 도메인 패키지에 `Section` 리스트를 관리하기 위한 일급 컬렉션 `Sections`를 생성하였다.\n\n초기에는 로직을 수행시키기 위해 순서를 중요하지 않았기 때문에 단순한 `ArrayList`를 활용하였다. 하지만 클라이언트에서 적절히 정렬된 구간 List가 필요했기 때문에 복잡한 재귀를 통해 구간을 조회하게 되었다.\n\n```java\npublic class Sections {\n    ...\n    private void addSection(List<Section> sections, Section prevSection) {\n        sections.add(prevSection);\n\n        for (Section currentSection : value) {\n            checkConnect(sections, prevSection, currentSection);\n        }\n    }\n\n    private void checkConnect(List<Section> sections, Section prevSection, Section currentSection) {\n        if (prevSection.isConnect(currentSection)) {\n            addSection(sections, currentSection);\n        }\n    }\n    ...\n}\n```\n\n#### 리뷰 중 일부\n```markdown\n`리뷰어`: 여기 메서드 흐름이 잘 이해가 가지않습니다 🥲\n어떤 역할인지 설명과 순환되는 구조를 풀어낼 수 있는 방법도 고려해보시면 좋겠습니다.\n\n`매트`: 기존코드에서는 로직 상에서 단순한 ArrayList를 활용해도 무관하다고 판단하여 조회를 진행할 때만 재귀를 통해 정렬할 수 있도록 하였습니다. 지속적인 고민 끝에 노선도와 유사한 컬렉션인 `LinkedList`를 활용하기로 결정하였습니다!\n\n이제 매번 Section을 추가하거나 삭제할 때 기존 노선의 순서를 유지한 채 관리 되므로 이전에 작성한 재귀를 통한 정렬 로직은 제거하였습니다!\n```\n\n위와 같이 이제 노선에 구간을 추가할 때 다양한 검증을 통해 `LinkedList`에 추가하도록 개선하였다.\n\n```java\npublic class Sections {\n    private final LinkedList<Section> value;\n    ...\n    public void append(Section section) {\n        validateSameSection(section);\n        validateContainsStation(section);\n        validateNotContainsStation(section);\n\n        if (isUpTerminus(section)) {\n            value.addFirst(section);\n            return;\n        }\n\n        if (isDownTerminus(section)) {\n            value.addLast(section);\n            return;\n        }\n\n        decideForkedLoad(section);\n    }\n    ...\n}\n```\n\n덕분에 조회를 진행할 때 그대로 반환하도록 개선할 수 있게 되었다.\n\n```java\npublic class Sections {\n    ...\n    public List<Section> getValue() {\n        return Collections.unmodifiableList(value);\n    }\n}\n```\n\n## 생각 정리\n\n이번 미션을 통해 이전에 혼자 학습했던 Java, Spring과 관련된 지식들의 빈 공간들이 조금씩 채워져 가는 기분을 느꼈다. 특히 Service 계층에서 대부분을 차지하던 비즈니스 로직들이 적절한 책임을 가진 도메인 로직으로 이동하면서 앞서 배운 객체지향적인 코드, 변경에 유연한 코드를 만들었고 테스트 하기 용이한 구조를 만들었다.\n\n기술적인 지식 습득도 중요하지만 못지 않게 전반적인 애플리케이션 구조에 대해서도 많은 고민을 하게 된다. 특정 계층이 왜 존재해야 하는지에 대한 의문을 가지게 됬으며 실제 적용한 사례를 통해 필요한 근거들을 채워가는 좋은 시간이 되었다.\n"},{"excerpt":"목표  우아한테크코스에서 진행한 미션의 리뷰와 피드백에 대해 정리한다. 실제 리뷰는 [Spring 지하철 노선도 - 1,2단계] 매트(최기현) 미션 제출합니다.에서 확인할 수 있다. 03. 1, 2단계 - 지하철 노선도 확인 이번 미션에서는 와 하는 연습을 위한 미션인 지하철 노선도를 진행하였다. 다행히 이번에는 view에 대한 구현 없이 제공된 API …","fields":{"slug":"/atdd-subway-map-step1/"},"frontmatter":{"date":"May 18, 2022","title":"[레벨 2] 03. 1, 2단계 - 지하철 노선도","tags":["우아한테크코스","레벨2","미션"]},"rawMarkdownBody":"\n## 목표\n\n![](https://user-images.githubusercontent.com/59357153/152970395-a31c8134-fc89-449f-b4dc-441e03df929c.png)\n\n우아한테크코스에서 진행한 미션의 리뷰와 피드백에 대해 정리한다. 실제 리뷰는 [[Spring 지하철 노선도 - 1,2단계] 매트(최기현) 미션 제출합니다.](https://github.com/woowacourse/atdd-subway-map/pull/218)에서 확인할 수 있다.\n\n## 03. 1, 2단계 - 지하철 노선도 확인\n\n이번 미션에서는 `API 요청에 대한 처리`와 `Dao 객체를 활용하여 데이터를 관리`하는 연습을 위한 미션인 지하철 노선도를 진행하였다. 다행히 이번에는 view에 대한 구현 없이 제공된 [API 문서v1](https://techcourse-storage.s3.ap-northeast-2.amazonaws.com/d5c93e187919493da3280be44de0f17f#Line)을 통해 필요한 기능을 구현하는 것이다.\n\n이번 미션에서 새롭게 추가된 것은 `End to End 테스트`를 작성하는 것이다. 즉 `인수 테스트(Acceptance Test)`를 작성하는 것이다. \n\n## 인수 테스트 (Acceptance Test)\n\n인수 테스트는 사용자의 시나리오에 따라 수행하는 테스트이다. 지금까지 진행했던 단위 테스트, 통합 테스트와는 다르게 실제 비즈니스에 초점을 두고 테스트를 진행한다. 이러한 인수 테스트는 소프트웨어의 내부 구조를 고려하지 않고 실제 사용자의 관점에서 테스트를 진행한다. 내부 코드에 관심을 가지지 않기 때문에 `블랙박스 테스트`이다. 인수 테스트 작성을 위해서는 E2E(End-to-End)의 형식을 활용한다. \n\n이번 미션에서는 `RestAssured`를 활용하여 인수 테스트를 작성하였다.\n\n```java\n@DisplayName(\"지하철역 관련 기능\")\npublic class StationAcceptanceTest extends AcceptanceTest {\n    ...\n    @DisplayName(\"지하철역을 조회한다.\")\n    @Test\n    void getStations() {\n        ExtractableResponse<Response> createdResponse1 = generateStation(\"강남역\");\n        ExtractableResponse<Response> createdResponse2 = generateStation(\"역삼역\");\n\n        ExtractableResponse<Response> response = RestAssured.given().log().all()\n                .when()\n                .get(\"/stations\")\n                .then().log().all()\n                .extract();\n\n        List<Long> expectedStationIds = List.of(createdResponse1, createdResponse2)\n                .stream()\n                .map(ExtractableResponse::response)\n                .map(ResponseBodyExtractionOptions::jsonPath)\n                .map(it -> it.getLong(\"id\"))\n                .collect(toList());\n        List<Long> resultStationIds = response.jsonPath()\n                .getList(\".\", StationResponse.class)\n                .stream()\n                .map(it -> it.getId())\n                .collect(toList());\n        assertAll(\n                () -> assertThat(response.statusCode()).isEqualTo(HttpStatus.OK.value()),\n                () -> assertThat(resultStationIds).containsAll(expectedStationIds)\n        );\n    }\n\n    private ExtractableResponse<Response> generateStation(String name) {\n        Map<String, String> params = new HashMap<>();\n        params.put(\"name\", name);\n\n        return RestAssured.given().log().all()\n                .body(params)\n                .contentType(MediaType.APPLICATION_JSON_VALUE)\n                .when()\n                .post(\"/stations\")\n                .then().log().all()\n                .extract();\n    }\n}\n```\n\n## 다이나믹 테스트\n\n#### 리뷰 중 일부\n\n```markdown\n`리뷰어`: 위가 많아지다보니 코드가 약간 복잡함을 느꼈는데요.\n각 테스트를 메서드로 분리하거나, junit의 다이나믹 테스트를 고려해볼 수 있을 것 같아요.\n\n[dynamic test](https://tecoble.techcourse.co.kr/post/2020-07-31-dynamic-test/)\n```\n\n다이나믹 테스트는 런타임 시점에 테스트가 생성되며 수행된다. 그렇기 때문에 테스트가 수행되는 도중에 동작을 변경할 수 있다. 이러한 다이나믹 테스트는 `@TestFactory`라는 애노테이션을 활용한다.\n\n다이나믹 테스트의 이점을 가장 먼저 확인할 수 있었던 대목은 바로 HTTP 메서드 중 delete에 대한 인수 테스트를 진행할 때 멱등성에 대한 것을 검증할 때 확인할 수 있었다.\n\n```java\n@DisplayName(\"노선 관련 기능\")\npublic class LineAcceptanceDynamicTest extends AcceptanceTest {\n    ...\n    @DisplayName(\"노선을 관리한다.\")\n    @TestFactory\n    Stream<DynamicTest> dynamicTestStream() {\n        ExtractableResponse<Response> createdResponse1 = generateLine(\"1호선\", \"bg-blue-600\");\n        ExtractableResponse<Response> createdResponse2 = generateLine(\"2호선\", \"bg-green-600\");\n\n        return Stream.of(\n                ...\n                dynamicTest(\"노선을 삭제한다.\", () -> {\n                    Long id = createdResponse1.body().jsonPath().getLong(\"id\");\n\n                    ExtractableResponse<Response> response = RestAssured.given().log().all()\n                            .when()\n                            .delete(\"/lines/\" + id)\n                            .then().log().all()\n                            .extract();\n\n                    assertThat(response.statusCode()).isEqualTo(HttpStatus.NO_CONTENT.value());\n                }),\n\n                dynamicTest(\"존재하지 않는 노선의 id를 삭제할 경우 잘못된 요청이므로 404를 반환한다.\", () -> {\n                    Long id = createdResponse1.body().jsonPath().getLong(\"id\");\n\n                    ExtractableResponse<Response> response = RestAssured.given().log().all()\n                            .when()\n                            .delete(\"/lines/\" + id)\n                            .then().log().all()\n                            .extract();\n\n                    assertThat(response.statusCode()).isEqualTo(HttpStatus.NOT_FOUND.value());\n                })\n        );\n    }\n    ...\n}\n```\n\n연속적인 테스트를 통해 기존에 삭제한 id로 동일하게 삭제를 진행할 경우 404 상태 코드를 반환하는 부분이다. 정적인 테스트와는 다르게 추가적인 데이터를 설정하지 않고 자연스러운 흐름으로 검증을 진행할 수 있었다.\n\n## 테스트 격리\n\n테스트를 진행할 때 각각의 테스트는 순서에 의존하지 않고 독립적으로 수행되어야 한다. 즉 같은 입력값에 대해서는 항상 같은 결과물을 출력해야 한다는 것이다. 이러한 테스트 격리를 방해하는 것은 하나의 자원을 공유할 때이다. 예를들면 DB와 같은 것들을 말한다. JUnit에서는 다양한 애노테이션(@BeforeEach, @Transactional 등)으로 격리할 수 있는 수단들을 제공한다. 아래는 이번 미션을 진행할 때 제공된 인수 테스트를 위한 테스트 설정 클래스이다.\n\n```java\n@DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD)\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\npublic class AcceptanceTest {\n\n    @LocalServerPort\n    int port;\n\n    @BeforeEach\n    public void setUp() {\n        RestAssured.port = port;\n    }\n}\n```\n\nSpring은 테스트를 진행할 때 같은 context를 사용하는 테스트가 여러 개 존재할 경우 각각의 테스트 마다 새로운 context를 사용하지 않고 기존의 context를 `재활용`한다. 우리는 재활용에 집중해야 한다. 결국 테스트 격리를 위해서는 공유하는 자원을 사용하지 말아야 하는데 이러한 context 재활용은 결국 자원을 공유해서 사용하는 것과 같다. 위 코드에서 `@DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD)` 덕분에 테스트 메서드를 수행하기 이전에 매번 context가 다시 생성되도록 할 수 있다.\n\n덕분에 각각의 테스트가 격리되어 적절히 진행될 수 있었다. 하지만 한 가지 치명적인 단점이 존재한다. 매번 context를 재생성 하기 때문에 테스트 시간이 매우 오래 걸리게 된다는 것이다.\n\n이러한 시간을 줄이기 위한 방법은 무엇이 있을까? 우선 공유되는 자원을 파악해야 한다. 그것은 앞서 언급한 것처럼 DB이다. 결국 매번 테스트 마다 DB의 테이블이 가진 데이터만 초기화 된다면 적절히 테스트 격리를 이룰 수 있을 것이다.\n\n### @Transactional\n\n보통 테스트에서 `@Transactional` 애노테이션을 사용하면 트랜잭션을 롤백한다. 하지만 위 코드에서 명시된 애노테이션에서 `@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)`와 같이 PORT를 명시하게 되면 트랜잭션이 롤백되지 않는다. 결국 테스트를 시작하기 전이나 후에 DB의 데이터를 직접 조작하여 삭제해야 한다.\n\n### @Sql을 활용한 TRUNCATE\n\n`TRUNCATE` 명령어는 테이블의 데이터가 모두 삭제하지만 테이블 자체는 그대로 유지된다. 테이블 자체가 지워지는 `DROP`은 테이블의 존재 자체가 사라지기 때문에 구조가 남지 않지만 TRUNCATE는 테이블의 구조를 유지할 수 있다. 이러한 `TRUNCATE`를 테스트 메서드 실행 이전에 수행된다면 손쉽게 테스트 격리를 이룰 수 있다.\n\n이러한 TRUNCATE를 테스트 실행 이전에 실행하기 위해서는 `@Sql`을 활용할 수 있다. 해당 애노테이션이 가리키는 경로에 존재하는 SQL을 우선 실행 시킨다. \n\n```sql\ntruncate table STATION;\ntruncate table LINE;\n```\n\n위와 같이 작성한 파일은 `test/resources` 아래에 위치 해두고 아래와 같이 명시한다.\n\n```java\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\n@Sql(\"/truncate.sql\")\npublic class AcceptanceTest {\n\n    @LocalServerPort\n    int port;\n\n    @BeforeEach\n    public void setUp() {\n        RestAssured.port = port;\n    }\n}\n```\n\n이제 매번 새롭게 context를 생성하지 않기 때문에 비교적 빠른 속도로 테스트 격리를 이룰 수 있게 되었다.\n\n## 서비스가 필요한가?\n\n처음 미션을 접할 때 비교적 단순한 요구사항과 구조로 서비스 계층에 대한 필요성을 느끼지 못했다. 결국 페어와 상의 끝에 생성하지 않도록 결정하였다. 하지만 관련해서 아래와 같은 리뷰를 확인할 수 있었다.\n\n#### 리뷰 중 일부\n```markdown\n`리뷰어`: 개인적으로 서비스가 있었으면 좋겠습니다. 제가 생각해본 단점인데요.\n\n * 컨트롤러가 무거워진다.\n * 트랜잭션이 보장되지 않는다.\n * 유스케이스기반으로 테스트하기가 어렵다 -> 유스케이스기반 테스트를하려면 mvc를 띄우고 테스트해야함\n\n물론 아직 해당되지 않을 수 있지만, 기본적으로 나누는게 좋을 것 같다고 생각해요. 업무를 하다보면 매번 베이스코드에 유지보수되고 변경이 일어나는데요. 변경이 일어나고 나서, 다시 새로운 레이어를 도입하기는 비용이 클 것 같아서요.\n```\n\n결국 단순한 위임의 행위일지라도 계층에게 적절한 책임을 부여해야 하며 후에 있을 확장에도 대비해야 하기 때문에 서비스 계층을 생성하기도 결정하였다.\n\n```java\n@Transactional(readOnly = true)\n@Service\npublic class StationService {\n\n    private final StationDao stationDao;\n\n    public StationService(StationDao stationDao) {\n        this.stationDao = stationDao;\n    }\n\n    @Transactional\n    public StationResponse save(StationRequest stationRequest) {\n        if (stationDao.existsByName(stationRequest.getName())) {\n            throw new IllegalArgumentException(stationRequest.getName() + \"은 이미 존재하는 지하철역 이름입니다.\");\n        }\n\n        Station station = stationDao.save(new Station(stationRequest.getName()));\n        return new StationResponse(station);\n    }\n\n    public List<StationResponse> findAll() {\n        return stationDao.findAll()\n                .stream()\n                .map(StationResponse::new)\n                .collect(toList());\n    }\n\n    @Transactional\n    public void deleteById(Long id) {\n        stationDao.deleteById(id);\n    }\n}\n```\n\n서비스 계층의 도입으로 또 다른 이점을 확인할 수 있었다. `@Repository`를 활용한 Dao에서 던지는 예외들을 `catch`하여 좀 더 도메인에 유의미한 예외들로 변경하여 전달할 수 있었다.\n\n## 멱등성을 보장하는 것\n\n#### 리뷰 중 일부\n```markdown\n`리뷰어`: HTTP에서 말하는 멱등성은 응답의 멱등성이 아닌, '리소스'의 대한 멱등성을 뜻합니다.\n\n식별자를 찾지못하면 404를 반환하는게 일반적인 것 같습니다.\n\n그럼 delete에서 리소스관점에서 멱등성을 어기는 예는 '마지막 노선삭제 API' 일 것 같아요. 매번 실행해도 다른 결과를 반환하고 있어서요.\n\n[멱등성](https://developer.mozilla.org/ko/docs/Glossary/Idempotent)\n```\n\n### 멱등성\n\n동일한 요청을 한 번 보내는 것과 여러 번 연속으로 보내는 것이 같은 효과를 지니고, 서버의 상태도 동일하게 남을 때, 해당 HTTP 메서드가 멱등성을 가졌다고 말한다. `GET`, `HEAD`, `PUT`, `DELETE` 메서드가 멱등성을 가진다. 이러한 멱등성은 일종의 규약이다. 만약 서버가 해당 규약을 지키지 않고 구현했다면 멱등성 제약을 어길 수 있다.\n\n아래는 리소스 관점에서 멱등성을 지키기 위한 update와 delete 관련 메서드이다.\n\n```java\n@Transactional(readOnly = true)\n@Service\npublic class LineService {\n    ...\n    @Transactional\n    public LineResponse update(Long id, LineRequest lineRequest) {\n        getLine(id);\n\n        try {\n            lineDao.update(id, new Line(lineRequest.getName(), lineRequest.getColor()));\n        } catch (DuplicateKeyException e) {\n            throw new IllegalArgumentException(lineRequest.getName() + \"은 이미 존재하는 노선 이름입니다.\");\n        }\n\n        return new LineResponse(getLine(id));\n    }\n\n    @Transactional\n    public void deleteById(Long id) {\n        getLine(id);\n        lineDao.deleteById(id);\n    }\n\n    private Line getLine(Long id) {\n        return lineDao.findById(id)\n                .orElseThrow(() -> new NotFoundException(id + \" 의 노선은 존재하지 않습니다.\"));\n    }\n}\n```\n\ngetLine을 통해 해당 식별자의 Line이 없는 경우 커스텀 예외인 `NotFoundException`을 통해 예외를 던지도록 작성하였다. 던져진 예외는 `ExceptionAdviser`를 통해 상태 코드 404를 반환하도록 한다.\n\n```java\n@RestControllerAdvice\npublic class ExceptionAdviser {\n    ...\n    @ExceptionHandler(NotFoundException.class)\n    public ResponseEntity<ErrorResponse> notFoundExceptionHandler(Exception e) {\n        return ResponseEntity.notFound().build();\n    }\n    ...\n}\n```\n\n## References.\n\n * [단위 테스트 vs 통합 테스트 vs 인수 테스트](https://tecoble.techcourse.co.kr/post/2021-05-25-unit-test-vs-integration-test-vs-acceptance-test/)\n * [인수테스트에서 테스트 격리하기](https://tecoble.techcourse.co.kr/post/2020-09-15-test-isolation/)\n * [Spring DirtiesContext](https://shortstories.gitbooks.io/studybook/content/dirtiescontext.html)\n * [멱등성](https://developer.mozilla.org/ko/docs/Glossary/Idempotent)\n"},{"excerpt":"enum 사계절을 뜻하는 봄, 여름, 가을, 겨울과 같이 한정된 값만을 가진 데이터 타입을이라고 한다. 이처럼 프로그래밍에서 을 나타내기 위해 사용된다.   Java 1.5 부터 enum을 으로 표시되었다. 특히 Java에서는 C/C++과 다르게 변수, 메소드, 생성자를 추가할 수 있다. 기존에 인터페이스나 클래스 내에서 상수를 선언하여 사용하였는데 상수…","fields":{"slug":"/enum/"},"frontmatter":{"date":"May 15, 2022","title":"enum","tags":["enum"]},"rawMarkdownBody":"\n## enum\n\n사계절을 뜻하는 봄, 여름, 가을, 겨울과 같이 한정된 값만을 가진 데이터 타입을` 열거 타입 (Enumuration type)`이라고 한다. 이처럼 프로그래밍에서 `상수의 그룹`을 나타내기 위해 사용된다. \n\n Java 1.5 부터 enum을 `enum 데이터 타입`으로 표시되었다. 특히 Java에서는 C/C++과 다르게 변수, 메소드, 생성자를 추가할 수 있다. 기존에 인터페이스나 클래스 내에서 상수를 선언하여 사용하였는데 상수를 관리하는데 있어서 나오는 단점들과 타입의 안정성, IDE의 지원을 받을 수 있도록 보완하여 나온 것이 Enum이다.\n\n## enum의 등장 배경\n\nenum 이전에 상수를 사용하던 때에는 몇 가지 문제점을 가지고 있었다.\n * 상수에 부여된 리터럴은 상수와 관련이 없다.\n * 이름의 충돌이 발생할 수 있다.\n\n```java\npublic class Season {\n\n    public static final int SPRING = 1;\n    public static final int SUMMBER = 2;\n    public static final int FALL = 3;\n    public static final int WINTER = 4;\n\n    public static void main(String[] args) {\n        int season = SPRING;\n\n        switch (season) {\n            case SPRING:\n                System.out.println(\"봄\");\n                break;\n            case SUMMBER:\n                System.out.println(\"여름\");\n                break;\n            case FALL:\n                System.out.println(\"가을\");\n                break;\n            case WINTER:\n                System.out.println(\"겨울\");\n                break;\n        }\n    }\n}    \n```\n\n```bash\n봄\n```\n\n첫 번째 문제를 확인하기 위해 간단하게 봄, 여름, 가을, 겨울을 1, 2, 3, 4라는 리터럴로 구분하여 부여하였다. 해당 리터럴은 단순히 상수를 구분하는 용도이고 논리적으로는 아무 의미가 없다. 즉 season 변수에 1이라는 값을 넣어도 SPRING을 넣었을 때랑 값을 결과가 나올 수 있다. 결국 `상수`와 `상수에 부여된 리터럴`들은 연관성이 없다는 것을 알 수 있었다.\n\n```java\npublic class Season {\n\n    public static final int SPRING = 1;\n    public static final int SUMMBER = 2;\n    public static final int FALL = 3;\n    public static final int WINTER = 4;\n\n    public static void main(String[] args) {\n        int season = 1;\n\n        switch (season) {\n            case SPRING:\n                System.out.println(\"봄\");\n                break;\n            case SUMMBER:\n                System.out.println(\"여름\");\n                break;\n            case FALL:\n                System.out.println(\"가을\");\n                break;\n            case WINTER:\n                System.out.println(\"겨울\");\n                break;\n        }\n    }\n}\n```\n\n```bash\n봄\n```\n\n또한 다른 클래스의 이름이 같은 상수도 비교해보았다.\n\n```java\npublic class Season {\n\n    // season\n    public static final int SPRING = 1;\n    public static final int SUMMBER = 2;\n    public static final int FALL = 3;\n    public static final int WINTER = 4;\n}\n```\n\n```java\npublic class Framework {\n\n    // framework\n    public static final int SPRING = 1;\n    public static final int DJANGO = 2;\n    public static final int RUBY_ON_RAILS = 3;\n    public static final int VUE_JS = 4;\n}\n```\n\n```java\npublic class Exam02 {\n    public static void main(String[] args) {\n        System.out.println(Season.SPRING == Framework.SPRING); // true\n    }\n}\n```\n\n서로 다른 SPRING을 의미하고 있지만, 1이라는 리터럴을 비교하기 때문에 true을 출력한다. \n\n두번째 문제는 `이름의 충돌`이 발생하는 것이다. Season의 SPRING과 Framework의 SPRING을 비교해보았다. 같은 클래스에 상수를 선언하면 Seanson의 SPRING과 Framework의 SPRING이 서로 같은 변수명으로 충돌하게 된다. 그렇기 때문에 추가적으로 앞에 구분하는 문자를 붙여줘야 한다.\n\n * SEANSON_SPRING\n * FRAMEWOKR_SPRING\n\nEnum은 위처럼 상수를 클래스로 정의하여 관리할 때 얻을 수 있는 이점을 모두 모아 간단하게 선언하여 사용할 수 있도록 하기 위해서 만들어졌다.\n\n## enum 정의\n\n가장 기본적 enum 선언이다.\n\n```java\npublic enum  Phone {\n\n    GALAXY_S21,\n    GALAXY_S21_PLUS,\n    GALAXY_S21_ULTRA,\n    GALAXY_Z_FLIP,\n    GALAXY_Z_FOLD2\n}\n```\n\n또한 생성자 및 메서드를 추가할 수 있다.\n\n```java\npublic enum Phone {\n    GALAXY_S21(999_900, \"SM-G991NZIEKOO\"),\n    GALAXY_S21_PLUS(1_119_900, \"SM-G996NZVEKOO\"),\n    GALAXY_S21_ULTRA(1_452_000, \"SM-G998NZKEKOO\"),\n    GALAXY_Z_FLIP(1_650_000, \"SM-F707NZNAKOO\"),\n    GALAXY_Z_FOLD2(2_398_000, \"SM-F916NZKAKOO\");\n\n    private final int price;\n    private final String modelName;\n\n    Phone(int price, String modelName) {\n        this.price = price;\n        this.modelName = modelName;\n    }\n\n    public int getPrice() {\n        return this.price;\n    }\n\n    public String getModelName() {\n        return this.modelName;\n    }\n}\n```\n\n> 생성자가 존재하지만 Default 생성자는 private로 되어 있다. public으로 변경하면 컴파일 에러가 발생한다. \n\n즉 다른 클래스나 인터페이스에서 상수 선언(static final)이 클래스 로드 시점에서 생성되는 것처럼 Enum 또한 생성자가 존재하지만 클래스가 로드되는 시점에 생성되기 때문에 임의로 생성하여 사용할 수 없다. Enum 클래스에 선언된 상수들은 클래스 로드 시점에서 모두 생성되고, signleton 형태로 애플리케이션 전체에서 사용할 수 있다.\n\n signleton으로 사용 가능하기 때문에 값을 유지하는 필드가 들어 있는 것은 매우 위험하기 때문에 조심해야 한다. \n\n```java\npublic enum Phone {\n    GALAXY_S21(999_900, \"SM-G991NZIEKOO\"),\n    GALAXY_S21_PLUS(1_119_900, \"SM-G996NZVEKOO\"),\n    GALAXY_S21_ULTRA(1_452_000, \"SM-G998NZKEKOO\"),\n    GALAXY_Z_FLIP(1_650_000, \"SM-F707NZNAKOO\"),\n    GALAXY_Z_FOLD2(2_398_000, \"SM-F916NZKAKOO\");\n\n    private final int price;\n    private final String modelName;\n    private int count;\n\n    Phone(int price, String modelName) {\n        this.price = price;\n        this.modelName = modelName;\n    }\n\n    public void addCount(int count) {\n        this.count += count;\n    }\n}\n```\n\ncount 변수는 멀티쓰레드 환경에서 공유되고 있기 때문에 값을 유지하는 인스턴스 변수의 사용을 막거나 `thread safe`하게 유지해야 한다.\n\n또한 상속을 지원하지 않는다. 모든 enum은 내부적으로 `java.lang.Enum` 클래스에 의해 상속된다. Java에서는 다중 상속을 지원하지 않기 때문에 enum 클래스는 다른 클래스를 상속 받을 수 없다. 상속을 지원하지 않지만 다양한 `인터페이스들은 구현`할 수 있다.\n\n`바이트코드`를 살펴보면 `java.lang.Enum`을 `상속` 받을 것을 알 수 있다. 또한 각각 인스턴스들은 `public final static`으로 선언되어 있다. 각각 객체의 주소 값은 바뀌지 않기 때문에 \"==\" 비교가 가능해진다.\n\n```java\npublic final enum me/hyeonic/week11/Phone extends java/lang/Enum {\n\n  // compiled from: Phone.java\n\n  // access flags 0x4019\n  public final static enum Lme/hyeonic/week11/Phone; GALAXY_S21\n\n  // access flags 0x4019\n  public final static enum Lme/hyeonic/week11/Phone; GALAXY_S21_PLUS\n\n  // access flags 0x4019\n  public final static enum Lme/hyeonic/week11/Phone; GALAXY_S21_ULTRA\n\n  // access flags 0x4019\n  public final static enum Lme/hyeonic/week11/Phone; GALAXY_Z_FLIP\n\n  // access flags 0x4019\n  public final static enum Lme/hyeonic/week11/Phone; GALAXY_Z_FOLD2\n  \n  ...\n}\n```\n\n### enum 안에 인스턴스 생성 시점 \n\nenum 안에 선언한 인스턴스들의 생성 시점을 알아보기 위해 간단한 예시를 작성하였다. `enum Phone`이에 생성자와 간단한 생성 정보를 출력하는 출력문을 추가하였다.\n\n```java\npublic enum Phone {\n    GALAXY_S21(999_900, \"SM-G991NZIEKOO\"),\n    GALAXY_S21_PLUS(1_119_900, \"SM-G996NZVEKOO\"),\n    GALAXY_S21_ULTRA(1_452_000, \"SM-G998NZKEKOO\"),\n    GALAXY_Z_FLIP(1_650_000, \"SM-F707NZNAKOO\"),\n    GALAXY_Z_FOLD2(2_398_000, \"SM-F916NZKAKOO\");\n\n    private final int price;\n    private final String modelName;\n\n    Phone(int price, String modelName) {\n        System.out.println(this.name() + \" -> \" + price + \", \" + modelName);\n        this.name();\n        this.price = price;\n        this.modelName = modelName;\n    }\n\n    public int getPrice() {\n        return this.price;\n    }\n\n    public String getModelName() {\n        return this.modelName;\n    }\n\n    @Override\n    public String toString() {\n        return \"Phone{\" +\n                \"price=\" + price +\n                \", modelName='\" + modelName + '\\'' +\n                '}';\n    }\n}\n```\n\n다양한 상황을 출력한다.\n\n```java\npublic class Exam01 {       \n    public static void main(String[] args) {                                            \n        System.out.println(\"==================== main ====================\");           \n        System.out.println(\"================ enum 변수 선언 ================\");             \n        Phone phone;                                                                    \n        System.out.println(\"============== enum 변수에 값 할당 ==============\");              \n        phone = Phone.GALAXY_S21;                                                       \n        System.out.println(\"=============== enum 변수 값 사용 ===============\");             \n        System.out.println(phone.name() + \"의 가격은 \" + phone.getPrice() + \"이다.\");         \n        System.out.println(\"===================== end =====================\");          \n    }                                                                                   \n}        \n```\n\n```bash\n===================== main =====================\n================ enum 변수 선언 =================\n============== enum 변수에 값 할당 ==============\nGALAXY_S21 -> 999900, SM-G991NZIEKOO\nGALAXY_S21_PLUS -> 1119900, SM-G996NZVEKOO\nGALAXY_S21_ULTRA -> 1452000, SM-G998NZKEKOO\nGALAXY_Z_FLIP -> 1650000, SM-F707NZNAKOO\nGALAXY_Z_FOLD2 -> 2398000, SM-F916NZKAKOO\n=============== enum 변수 값 사용 ===============\nGALAXY_S21의 가격은 999900이다.\n====================== end =====================\n```\n\nenum 변수를 단순히 선언만 하면 내부의 상수들이 선언되지 않는다. `직접적으로 값을 할당`하거나 `사용할 때` 비로소 모든 값들이 생성되는 것을 알 수 있다.\n\n## enum이 제공하는 메서드 \n\n### values\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Phone[] phones = Phone.values();\n\n        for (Phone phone : phones) {\n            System.out.println(phone.ordinal() + \" \" + phone.name());\n            System.out.println(\"model name: \" + phone.getModelName() + \" price: \" + phone.getPrice());\n\n            System.out.println();\n        }\n    }\n}\n```\n\n```bash\n0 GALAXY_S21\nmodel name: SM-G991NZIEKOO price: 999900\n\n1 GALAXY_S21_PLUS\nmodel name: SM-G996NZVEKOO price: 1119900\n\n2 GALAXY_S21_ULTRA\nmodel name: SM-G998NZKEKOO price: 1452000\n\n3 GALAXY_Z_FLIP\nmodel name: SM-F707NZNAKOO price: 1650000\n\n4 GALAXY_Z_FOLD2\nmodel name: SM-F916NZKAKOO price: 2398000\n```\n\nEnum 클래스가 가지고 있는 상수 값을 `배열의 형태로 리턴`한다. String 형태의 name을 반환하는게 아니라 `enum phone이 가지고 있는 모든 상수의 인스턴스를 배열에 담아 반환`한다. 그렇기 때문에 상속 받은 Enum 클래스의 메소드 뿐만 아니라 Phone에 있는 get메소드 또한 사용이 가능하다.\n\n이러한 `values()`는 바이트코드를 살펴보면 컴파일 시점에 자동 생성한다.\n\n<p align=center>\n    <img src=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fq6XgM%2FbtqU93WOlFf%2FE57N7NIENtpciRrHNAe6KK%2Fimg.png\">\n</p>\n\n### valueOf\n\n`valueOf()` 메소드는 인자로 들어온 값과 일치하는 상수 인스턴스가 존재하면 해당 인스턴스를 반환한다. 단순히 문자열 반환이 아닌 인스턴스 자체를 반환한다.\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Phone galaxy21 = Phone.valueOf(\"GALAXY_S21\");\n\n        System.out.println(galaxy21.name());\n        System.out.println(galaxy21.ordinal());\n        System.out.println(galaxy21.getModelName());\n        System.out.println(galaxy21.getPrice());\n    }\n}\n```\n\n```bash\nGALAXY_S21\n0\nSM-G991NZIEKOO\n999900\n```\n\n존재하지 않는 상수인 경우 `IllegalArgumentException`을 던진다.\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Phone galaxy20 = Phone.valueOf(\"GALAXY_S20\");\n\n        System.out.println(galaxy20.name());\n        System.out.println(galaxy20.ordinal());\n        System.out.println(galaxy20.getModelName());\n        System.out.println(galaxy20.getPrice());\n    }\n}\n```\n\n```bash\nException in thread \"main\" java.lang.IllegalArgumentException: No enum constant me.hyeonic.week11.Phone.GALAXY_S20\n\tat java.base/java.lang.Enum.valueOf(Enum.java:240)\n\tat me.hyeonic.week11.Phone.valueOf(Phone.java:3)\n\tat me.hyeonic.week11.Main.main(Main.java:15)\n```\n\n## java.lang.Enum\n\n`java.lang.Enum` 클래스는 Java의  enum 타임의 기반이 되는 클래스이다. enum type은 내부적으로 모두 java.lang.Enum 클래스를 상속한다. 또한 Enum 클래스의 생성자는 유일한 생성자로, 개발자는 해당 생성자를 호출할 수 없다. \n\n`values()`와 `valueOf()`를 제외한 다른 메서드는 아래와 같다.\n\n### public final String name()\n열거형 선언에서 선언한 대로 `상수의 이름을 반환`한다. 대부분의 개발자는 `toString() 메소드` 사용을 추천한다. toString() 메소드를 오버라이딩 하여 사용하면 `사용자 친화적인 이름을 반환`할 수 있기 때문이다. name() 메소드는 릴리스마다 달라지지 않는 정확한 이름을 반환하기 때문에 `정확도가 중요한 특수한 상황`에서 사용한다.\n\n### public final int ordinal()\n\n열거형 상수의 `순서를 반환`한다. `선언된 위치를 기준으로 0부터 부여`된다. 개발자가 직접 사용하기 보다는, `EnumSet`과 `EnumMap`과 같은 정교한 `Enum 기반 데이터 구조`에서 사용할 수 있도록 설계되었다.\n\n> `ordinal()` 메소드를 기반으로 코드를 작성하는 것은 위험하다. 후에 enum에 상수 인스턴스가 추가되면, 해당 index가 유지되는 것을 보장하지 않는다.\n\n## References\n\n[Enum class](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Enum.html)<br>\n"},{"excerpt":"목표  우아한테크코스에서 진행한 미션의 리뷰와 피드백에 대해 정리한다. 실제 리뷰는 [Spring 체스 - 2단계] 매트(최기현) 미션 제출합니다.에서 확인할 수 있다. 02. 2단계 - 웹 체스 리뷰 확인 2단계에서는 기존의 1단계인 Spring 적용을 넘어 체스 게임이 동시에 여러 게임이 진행될 수 있도록 동작해야하는 요구사항이 추가되었다. 처음 이러…","fields":{"slug":"/jwp-chess-step2/"},"frontmatter":{"date":"May 02, 2022","title":"[레벨 2] 02. 2단계 - 웹 체스","tags":["우아한테크코스","레벨2","미션"]},"rawMarkdownBody":"\n## 목표\n\n![](https://user-images.githubusercontent.com/59357153/152970395-a31c8134-fc89-449f-b4dc-441e03df929c.png)\n\n우아한테크코스에서 진행한 미션의 리뷰와 피드백에 대해 정리한다. 실제 리뷰는 [[Spring 체스 - 2단계] 매트(최기현) 미션 제출합니다.](https://github.com/woowacourse/jwp-chess/pull/429)에서 확인할 수 있다.\n\n## 02. 2단계 - 웹 체스 리뷰 확인\n\n2단계에서는 기존의 1단계인 Spring 적용을 넘어 체스 게임이 동시에 여러 게임이 진행될 수 있도록 동작해야하는 요구사항이 추가되었다.\n\n처음 이러한 요구사항을 접했을 때 기존에 작성한 계층 구조를 전체적으로 개선해야 해서 막막한 기분이 들었다. 최대한 집중한 것은 이전과 동일하게 `도메인에 변경을 최소화` 하며 요구사항을 반영하는 것이다.\n\n## Service layer의 존재 이유\n\n1단계를 진행할 당시에는 릭이 기존에 service 계층을 구현하였기 때문에 별 다른 이유 없이 해당 계층을 유지하는 방향으로 진행하였다. 2단계는 페어가 아닌 혼자 진행하기 때문에 DB에 대한 구조를 전반적으로 개선하는 겸 기존 계층 구조를 전부 개편하기로 결심하였다.\n\n내가 바라본 이전의 service는 단순히 `도메인의 비즈니스 로직을 실행`하거나 `DAO를 활용하여 DB를 조작`하는 일련의 행위들의 묶음들을 모아둔 객체에 불과했다. controller는 단순히 service에게 해당 행위들을 위임할 뿐이었기 때문에 더더욱 `service layer에 대한 역할`이 애매하다고 생각했다. 즉 controller에서 처리해도 무관하다고 판단했다.\n\n그렇기 때문에 2단계를 반영할 때는 service 계층을 사용하지 않고 controller에서 바로 dao와 도메인에 접근하는 방식으로 진행하였다.\n\n그 결과 아래와 같은 controller를 확인할 수 있었다.\n\n```java\n@RestController\n@RequestMapping(value = \"/api/rooms\")\npublic class ChessApiController {\n\n    private static final int DEFAULT_ROOM_ID = 0;\n\n    private final JdbcRoomDao jdbcRoomDao;\n    private final JdbcChessPieceDao jdbcChessPieceDao;\n\n    public ChessApiController(final JdbcRoomDao jdbcRoomDao, final JdbcChessPieceDao jdbcChessPieceDao) {\n        this.jdbcRoomDao = jdbcRoomDao;\n        this.jdbcChessPieceDao = jdbcChessPieceDao;\n    }\n    ...\n    @GetMapping(\"/{id}\")\n    public ResponseEntity<RoomResponse> getRoom(@PathVariable final int id) {\n        RoomEntity roomEntity = getRoomEntity(id);\n\n        return ResponseEntity.ok(new RoomResponse(roomEntity));\n    }\n    ...\n    @PostMapping\n    public ResponseEntity<Integer> createRoom(@RequestBody final RoomSaveRequest request) {\n        final RoomEntity roomEntity = new RoomEntity(DEFAULT_ROOM_ID, request.getName(), request.getPassword(),\n                GameStatus.READY.getValue(), Color.WHITE.getValue());\n\n        final int id = jdbcRoomDao.save(roomEntity);\n\n        return ResponseEntity.created(URI.create(\"/api/rooms/\" + id)).body(id);\n    }\n    ...\n    @PatchMapping(\"/{id}/pieces\")\n    public ResponseEntity<MoveResult> movePiece(@PathVariable final int id,\n                                                @RequestBody final ChessPieceMoveRequest request) {\n        final RoomEntity roomEntity = getRoomEntity(id);\n        final ChessGame chessGame = getChessGame(roomEntity);\n\n        final Position from = Position.from(request.getFrom());\n        final Position to = Position.from(request.getTo());\n\n        final MoveResult moveResult = chessGame.move(from, to);\n\n        jdbcChessPieceDao.deleteByRoomIdAndPosition(roomEntity.getId(), request.getTo());\n        jdbcChessPieceDao.update(roomEntity.getId(), request.getFrom(), request.getTo());\n\n        jdbcRoomDao.update(new RoomEntity(roomEntity.getId(), roomEntity.getName(), roomEntity.getPassword(),\n                moveResult.getGameStatus().getValue(), moveResult.getCurrentTurn().getValue()));\n\n        return ResponseEntity.ok(moveResult);\n    }\n    ...\n}\n```\n\n예시를 위해 일부분만 가져온 것이다. 로직이 정상적으로 작동 하였지만 가독성이나 역할 측면에서 약간의 우려가 남았다. 리뷰어는 해당 controller를 보고 `service를 제거한 이유`에 대해 물었다.\n\n#### 리뷰 중 일부\n```markdown\n`리뷰어`: 서비스를 제거한 이유가 있을까요??\n\n`매트`: 이전 서비스는 단순히 controller가 위임을 하기 위한 목적 뿐이라고 판단하였습니다. 이번에 Dao와 Controller를 전면적으로 개편하며 Service layer에 대한 필요성을 잘 느끼지 못해서 해당 클래스는 제거하였습니다!\n\n이미 도메인 객체가 비즈니스 로직을 가지고 있기 때문에 추가적인 Service layer를 통한 계층 분리는 불필요 하다고 판단하였습니다. 로운이 생각했을 때 service layer를 분리하기 위한 목적은 무엇인가요? 저는 아직 계층 분리를 위한 근거의 기준이 잡히지 않아 질문드립니다!\n\n`리뷰어`: `Service의 역할`을 생각해보면 될텐데요.\n\n기존에는 controller만 있었고, 매트처럼 controller에서 request 검증, domain에 요청, dao에 요청, response 응답 생성 등을 다 맡아서 진행했을 겁니다. 이러다 보니 controller의 역할이 너무 커지게 되었고, 로직을 파악하는 어려움이 생겼을 거라고 생각해요.\n그래서 service에 비지니스 로직을 위임하고, controller에서는 비지니스 로직 이외의 request 검증, response 응답 생성 등만 맡아서 하는 형식으로 바뀌지 않았을까 생각합니다.\n\n현재 controller의 movePiece를 보면 체스가 작은 프로그램인데도 생각보다 코드량이 많다는 것을 알 수 있어요.\n그렇다면 체스보다 훨씬 큰 프로그램의 경우에는 어떻게 될 수 있을까요? 그리고 service는 큰의미의 도메인 service가 생기게 되는데 어느 도메인에서 에러가 발생했을 경우에 파악을 하는 데에도 더 빠르게 파악할 수 있지 않을까요?\n\n예를 들어 주문과 배달 도메인이 있는데 주문 프로세스로 a 도메인 로직이 돈 후 b 도메인 로직을 돌고 c에 요청해서 데이터를 가져와야 하고 배달도 비슷한 순서의 로직을 돈다고 한다면 orderService와 deliveryService로 나뉘어져 있어야 각각의 로직의 흐름을 파악하고 도메인에 에러가 났을 때 어디를 봐야할 지 명확하지 않을까요??\n저는 우리가 도메인의 역할과 책임을 생각하고 그에 따라 확인해야 하는 위치를 파악했던 것이 service에도 동일하게 적용된다고 생각합니다~\n\n개인적으로 현재의 수준에서는 저도 매트처럼 service가 없어도 괜찮다고 생각합니다~ service를 쓴다고 했을 때 response dto로의 변환을 controller에서 할지 service에서 할지에 대해서도 한번 고민해보시면 좋을 것 같아요~\n그리고 service를 쓴다고 하면 service가 주요 `비지니스 로직을 담당`하기 때문에 `테스트는 꼭 만들어 주는 것`이 좋습니다.\n```\n\n리뷰어에게 아주 양질의 답변을 확인할 수 있었다. 많은 부분에서 고민해볼 포인트들을 남겨주었다.\n\n### 그래서 필요한 이유는?\n\n가장 크게 공감한 것은 `controller의 역할`이 비대해져 로직을 파악하는데 어려움이 생긴다는 것이다. controller에는 비즈니스 로직 이외에 request와 response와 관련된 로직만 담당하고 service에서 주요 비즈니스 로직을 담당하게 되면 좀 더 역할에 맞춰 계층을 바라볼 수 있을 것이다.\n\n가장 큰 예시가 바로 내 코드 내부에 있었다. \n\n```java\n@RestController\n@RequestMapping(value = \"/api/rooms\")\npublic class ChessApiController {\n    ...\n    @PatchMapping(\"/{id}/pieces\")\n    public ResponseEntity<MoveResult> movePiece(@PathVariable final int id,\n                                                @RequestBody final ChessPieceMoveRequest request) {\n        final RoomEntity roomEntity = getRoomEntity(id);\n        final ChessGame chessGame = getChessGame(roomEntity);\n\n        final Position from = Position.from(request.getFrom());\n        final Position to = Position.from(request.getTo());\n\n        final MoveResult moveResult = chessGame.move(from, to);\n\n        jdbcChessPieceDao.deleteByRoomIdAndPosition(roomEntity.getId(), request.getTo());\n        jdbcChessPieceDao.update(roomEntity.getId(), request.getFrom(), request.getTo());\n\n        jdbcRoomDao.update(new RoomEntity(roomEntity.getId(), roomEntity.getName(), roomEntity.getPassword(),\n                moveResult.getGameStatus().getValue(), moveResult.getCurrentTurn().getValue()));\n\n        return ResponseEntity.ok(moveResult);\n    }\n    ...\n}\n```\n\n기물을 이동하기 위한 핸들러 메서드이다. 가독성을 위해 나름 줄바꿈을 작성했지만 도메인의 비즈니스 로직과 dao, 요청 응답 로직이 뒤섞여 다소 읽기 어려운 코드가 되었다. 만약 주요 비즈니스 로직과 dao를 service 계층으로 이전하게 되면 아래와 같이 수정될 것이다.\n\n```java\n@RestController\n@RequestMapping(value = \"/api/rooms\")\npublic class ChessApiController {\n    ...\n    @PatchMapping(\"/{id}/pieces\")\n    public ResponseEntity<MoveResult> movePiece(@PathVariable final int id,\n                                                @RequestBody final ChessPieceMoveRequest request) {\n\n        final MoveResult moveResult = chessService.move(id, request.getFrom(), request.getTo())\n        return ResponseEntity.ok(moveResult);\n    }\n    ...\n}\n```\n\ncontoller에는 요청과 응답을 제외하곤 신경 쓸 필요가 없어졌다. 또한 controller가 가지는 도메인에 대한 직접적인 의존성까지 제거할 수 있게 되었다.\n\n### @Transactional?\n\n이 밖에도 어떠한 장점이나 특징들이 있는지 고민해보았다.\n\n다른 크루들의 리뷰를 살펴보면 `@Transactional`에 대한 키워드를 심심치 않게 볼 수 있었다. 나는 해당 애노테이션의 역할을 정확히 인지하지 못했기 때문에 이번 미션에서는 사용하지 않았다.\n\n간단히 정리하면 아래와 같다.\n\n만약 내가 로또 머신에서 로또를 구매한다고 가정한다. 로또 5장을 자동으로 구매하기 위해 5000원을 입금했다. 로또 자동 발급 도중 머신의 오류로 나는 2장의 로또만 받게 되었다. 그렇다면 나머지 3장의 로또는 어떻게 되는 것일까?\n\n위 예시는 `로또 구매에 실패한 경우`이다. 즉 원하는 물건(로또 5장)을 받지 못했기 때문에 로또 구매라는 `일련의 과정`이 실패하게 된 것이다. 로또 구매자 입장에서는 2장의 로또를 받기 보다 자신의 돈인 5000원을 돌려받길 원할 것이다. 즉 일련의 과정 중 오류가 발생하면 없었던 일 처럼 완전히 되돌려야 한다.\n\nSpring에서 DB와 관련하여 일련의 과정 중 없었던 일 처럼 완전히 되돌려 놓기 위해서는 `@Transactional`이 사용된다. 좀 더 깊은 내용은 추가적인 학습이 필요할 것으로 판단하여 간단한 이론만 작성하였다.\n\n정리하면 service 계층을 활용하게 되면 일련의 과정을 나타내는 트랜잭션을 메서드 단위로 관리할 수 있다. 이것은 transcation의 특징(ACID)을 통해 클라이언트들에게 `신뢰성을 보장`할 수 있을 것이다.\n\n## 테스트 격리하기\n\n각각의 테스트는 서로의 순서에 상관 없이 독립적으로 수행되어야 한다. 즉 각각의 테스트는 서로 관여하지 않고 `격리`하여 진행되어야 한다.\n\n격리 시키기 위한 조건으로는 각각의 테스트는 자원을 공유해서는 안된다. 하지만 DB라는 자원을 공유하지 않고 Dao를 격리하여 테스트 하는 것은 매우 어려운 일이었다.\n\n### 매번 DB 삭제하기\n\n테스트 격리를 위해 많은 고민 끝에 매번 DB를 초기화하는 방식을 생각했다. 결국 Dao에 DB를 별도로 초기화 하기 위한 메서드인 `deleteAll`이 추가되었다.\n\n```java\n@Repository\npublic class JdbcRoomDao {\n    ...\n    public void deleteAll() {\n        final String sql = \"DELETE FROM room\";\n        jdbcTemplate.update(sql);\n    }\n}\n```\n\n```java\n@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)\nclass ChessApiControllerTest {\n    ...\n    @BeforeEach\n    void setUp() {\n        RestAssured.port = port;\n    }\n\n    @AfterEach\n    void tearDown() {\n        roomDao.deleteAll();\n    }\n    ...\n}\n```\n\n매번 테스트가 마무리 될 때 DB가 초기화 되기 때문에 간섭 없이 진행할 수 있다고 판단한다. 하지만 public으로 해당 행위가 열려 있기 때문에 의도하지 않게 사용될 경우 비즈니스에 큰 파급을 가져올 우려가 있다. 이에 대해 리뷰어는 아래와 같은 의견을 남겨주었다.\n\n#### 리뷰 중 일부\n```markdown\n`리뷰어`: jpa 같은 경우에 deleteAll은 기본적을 제공하는 메서드입니다.\n\n그래서 저는 개인적으로 괜찮다고 생각하는데요. 다만 테스트만을 위한 메서드를 운영 코드에 만드는 것은 좋지 않다는 것에는 저도 공감하고 있기 때문에 그 부분이 불편하다면 `test에서 jdbcTemplate를 사용해서 삭제`하도록 하는것도 방법일 것 같습니다!\n```\n\n해당 테스트는 `@SpringBootTest`를 활용하기 때문에 Bean이 모두 등록되어 있다. 즉 jdbcTemplate을 활용할 수 있다. 위 코드는 아래와 같이 개선할 수 있다.\n\n```java\n@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)\nclass ChessApiControllerTest {\n    ...\n    private final JdbcTemplate;\n\n    @Autowired\n    public ChessApiControllerTest(final JdbcTemplate jdbcTemplate) {\n        this.jdbcTemplate = jdbcTemplate;\n    }\n    ...\n    @AfterEach\n    void tearDown() {\n        final String sql = \"DELETE FROM room\";\n        jdbcTemplate.update(sql);\n    }\n    ...\n}\n```\n\n## @JdbcTest를 통한 슬라이스 테스트\n\n슬라이스 테스트란? 계층을 하나의 단위로 나눠 테스트 하는 것이다. 즉 Spring 환경에 모든 Bean들을 등록하지 않고 계층에서 사용하는 있는 특정 Bean 혹은 자원들만 함께 Spring 환경에서 테스트할 수 있도록 제공한다. 그중 `@JdbcTest`를 활용하였다.\n\n우선 `@JdbcTest`의 특징은 아래와 같다.\n\n * 오직 DataSource를 필요로 하는 테스트에서 사용한다.\n * in-memory embedded database가 설정되어 테스트를 위한 JdbcTemplate이 생성된다.\n * 일반적인 `@Component` Bean들은 스캔되지 않는다.\n\n정리하면 최소한의 Bean 정보를 활용하여 테스트를 진행할 수 있기 때문에 비교적 빠른 속도로 단위 테스트를 진행할 수 있다.\n\n## 생성자 주입을 통한 테스트\n\nJUnit5에서도 생성자 주입을 활용한 의존성 주입이 가능하다. 하지만 단순히 Spring에서 사용하는 것 처럼 생성자가 1개 일 때 `@Autowired를 생략할 경우` `No ParameterResolver registered for parameter`와 같은 에러를 마주할 수 있다.\n\n#### 리뷰 중 일부\n\n```markdown\n`리뷰어`: 저는 @BeforeAll을 생각했는데 생성자를 만들어서도 사용할 수 있군요! 👍\n@Autowired부분은 저도 그냥 자연스럽게 쓰고 있던 부분이랑 이번에 찾아보게 되었는데요. \n\n에러가 발생하는 이유는 Junit5가 DI를 스스로 지원하고, DI를 지원하는 타입이 정해져 있다고 하네요.\n\nJunit5에서 생성자나 lombok방식으로 DI가 안되는 이유는 Junit이 생성자에 다른 의존성을 주입하려고 먼저 개입하기 때문이라고 합니다.\n```\n\n리뷰어를 통해 위와 같은 해답을 얻을 수 있었다. 정리하면 JUnit5에서 Spring에서 제공하는 DI를 활용하기 위해서는 명시적으로 `@Autowired`를 작성해야 한다.\n\n## References.\n\n * [Transactional 어노테이션](https://tecoble.techcourse.co.kr/post/2021-05-25-transactional/)\n * [Business Logic Organization Patterns](https://github.com/msbaek/memo/blob/master/Business-Logic-Organization-Patterns.md)\n * [인수테스트에서 테스트 격리하기](https://tecoble.techcourse.co.kr/post/2020-09-15-test-isolation/)\n * [Spring Boot 슬라이스 테스트](https://tecoble.techcourse.co.kr/post/2021-05-18-slice-test/)\n * [JUnit5에서 의존성 주입은 @Autowired로 해야하는 이유](https://pinokio0702.tistory.com/189?category=414017)\n"},{"excerpt":"목표  우아한테크코스에서 진행한 미션의 리뷰와 피드백에 대해 정리한다. 실제 리뷰는 [Spring 체스 - 1단계] 매트(최기현) 미션 제출합니다.에서 확인할 수 있다. 01. 사전 준비, 1단계 - 웹 체스 리뷰 확인 드디어 레벨 2가 시작되었다. 레벨 2의 첫 미션은 레벨 1동안 많은 크루들을 괴롭힌 체스 미션의 연장선이다. 레벨 1에서 구현한 체스 …","fields":{"slug":"/jwp-chess-step1/"},"frontmatter":{"date":"April 30, 2022","title":"[레벨 2] 01. 사전 준비, 1단계 - 웹 체스","tags":["우아한테크코스","레벨2","미션"]},"rawMarkdownBody":"\n## 목표\n\n![](https://user-images.githubusercontent.com/59357153/152970395-a31c8134-fc89-449f-b4dc-441e03df929c.png)\n\n우아한테크코스에서 진행한 미션의 리뷰와 피드백에 대해 정리한다. 실제 리뷰는 [[Spring 체스 - 1단계] 매트(최기현) 미션 제출합니다.](https://github.com/woowacourse/jwp-chess/pull/342)에서 확인할 수 있다.\n\n## 01. 사전 준비, 1단계 - 웹 체스 리뷰 확인\n\n드디어 레벨 2가 시작되었다. 레벨 2의 첫 미션은 레벨 1동안 많은 크루들을 괴롭힌 체스 미션의 연장선이다. 레벨 1에서 구현한 체스 애플리케이션을 기반으로 Spring Framework를 활용하여 구현하는 경험을 진행한다. \n\n이번 미션의 목표는 아래와 같다.\n\n* 레벨 1에서 구현한 체스 애플리케이션을 토대로 스프링 프레임워크를 활용하여 구현하는 경험한다.\n* 핵심 로직은 프레임워크에 종속되지 않은게 중요하다는 점을 인지하고 이를 고려하여 개발을 하는 경험한다.\n* 학습 테스트를 통해 스프링 프레임워크를 익히고 미션을 통해 실제로 적용해보는 경험을 진행한다.\n\n## 페어 프로그래밍\n\n이번 미션에서는 운이 좋게 **엘리**와 **릭**과 함께 3인 페어로 진행하게 되었다. 덕분에 체스 도메인 코드를 선택할 때 다양한 선택지가 있어서 좋았다. 서로의 코드를 살펴본 뒤 투표를 통해 **릭**의 코드를 기반으로 진행하기로 결정하였다.\n\n페어들과 이야기를 나눈 뒤 가장 중점을 둔 것은 도메인을 최대한 훼손하지 않고 `Sprak 기반`에서 `Spring 기반`으로 변경하는 것이다.\n\n## @RestController\n\n기반 코드를 릭 코드로 진행하기로 하였기 때문에 어떻게 동작하는지 확인해볼 필요가 있었다.\n\n```java\npublic class ChessWebController {\n    ...\n    public void run() {\n\n        get(\"/\", (req, res) ->\n                render(new HashMap<>(), \"index.html\")\n        );\n\n        path(\"/rooms\", () -> {\n            get(\"/:name\", (req, res) -> {\n                final boolean roomExist = roomService.isExistRoom(extractRoomName(req));\n                if (!roomExist) {\n                    res.redirect(\"/\");\n                }\n                return render(new HashMap<>(), \"board.html\");\n            });\n\n            post(\"/:name\", (req, res) ->\n                    roomService.createRoom(extractRoomName(req))\n            );\n\n            delete(\"/:name\", (req, res) -> {\n                final String json = roomService.deleteRoom(extractRoomName(req));\n                handleError(json, res);\n                return json;\n            });\n\n            get(\"/:name/pieces\", (req, res) -> {\n                final String json = chessService.findAllPiece(extractRoomName(req));\n                handleError(json, res);\n                return json;\n            });\n\n            post(\"/:name/pieces\", (req, res) -> {\n                final String json = chessService.initPiece(extractRoomName(req));\n                handleError(json, res);\n                return json;\n            });\n\n            put(\"/:name/pieces\", (req, res) -> {\n                final String requestBody = req.body();\n                final MoveRequestDto requestDto = MoveRequestDto.from(requestBody);\n                final String json = chessService.move(extractRoomName(req), requestDto);\n                handleError(json, res);\n                return json;\n            });\n\n            get(\"/:name/scores\", (req, res) -> {\n                final String json = chessService.findScore(extractRoomName(req));\n                handleError(json, res);\n                return json;\n            });\n\n            get(\"/:name/turn\", (req, res) -> {\n                final String json = roomService.findCurrentTurn(extractRoomName(req));\n                handleError(json, res);\n                return json;\n            });\n\n            get(\"/:name/result\", (req, res) -> {\n                final String json = chessService.result(extractRoomName(req));\n                handleError(json, res);\n                return json;\n            });\n        });\n    }\n    ...\n}\n```\n\nSpark 기반 구조라 알아보기 쉽지 않지만 잘 살펴보면 `json` 데이터를 기반으로 값을 반환하고 있다. Spring 전환 시에도 해당 사항을 고려하여 변경해야 했다.\n\n### @Controller와 @ResponseBody \n\n기본적으로 `@Controller`를 사용하게 되면 `View`를 반환하기 위해 사용된다. Controller가 반환한 View의 이름으로 View를 랜더링하기 위해서 내부적으로 `ViewResolver`가 사용된다. ViewResolver 설정에 맞게 View를 찾아 랜더링을 진행한다.\n\nController는 데이터를 반환할 수도 있다. 이때 `@ResponseBody` 애노테이션을 활용해야 한다. 이때 객체 반환을 위해 ViewResolver를 사용하는 대신 `HttpMessageConverter`가 동작한다.\n\n`@RestController`는 `@Controller`에 `@ResponseBody`가 추가된 것이다. 즉 해당 Controller를 활용하여 데이터를 반환하도록 사용할 수 있다. 주로 REST API 개발을 위해 사용되며 해당 객체는 `ResponseEntity`로 감싸서 반환된다.\n\n자세한 설명은 [[Spring] @Controller와 @RestController 차이](https://mangkyu.tistory.com/49)에서 확인할 수 있다.\n\n### 변경된 Controller\n\n앞서 언급한 것처럼 json 데이터 반환을 위해 `@RestController`를 기반으로 작성한다.\n\n```java\n@RestController\n@RequestMapping(\"/rooms\")\npublic class ChessController {\n\n    private final RoomService roomService;\n    private final ChessService chessService;\n\n    public ChessController(final RoomService roomService, final ChessService chessService) {\n        this.roomService = roomService;\n        this.chessService = chessService;\n    }\n\n    @PostMapping(\"/{roomName}\")\n    public void createRoom(@PathVariable(\"roomName\") final String roomName) {\n        roomService.createRoom(roomName);\n    }\n\n    @DeleteMapping(\"/{roomName}\")\n    public void deleteRoom(@PathVariable(\"roomName\") final String roomName) {\n        roomService.deleteRoom(roomName);\n    }\n\n    @GetMapping(\"/{roomName}/pieces\")\n    public ResponseEntity<List<ChessPieceDto>> findPieces(@PathVariable(\"roomName\") final String roomName) {\n        final List<ChessPieceDto> chessPieces = chessService.findAllPiece(roomName);\n        return ResponseEntity.ok(chessPieces);\n    }\n\n    @PostMapping(\"/{roomName}/pieces\")\n    public void createPieces(@PathVariable(\"roomName\") final String roomName) {\n        chessService.initPiece(roomName);\n    }\n\n    @PutMapping(\"/{roomName}/pieces\")\n    public ResponseEntity<MoveResult> movePiece(@PathVariable(\"roomName\") final String roomName,\n                                                @RequestBody final MoveRequestDto moveRequestDto) {\n        final MoveResult moveResult = chessService.move(roomName, moveRequestDto);\n        return ResponseEntity.ok(moveResult);\n    }\n\n    @GetMapping(\"/{roomName}/scores\")\n    public ResponseEntity<Score> findScore(@PathVariable(\"roomName\") final String roomName) {\n        final Score score = chessService.findScore(roomName);\n        return ResponseEntity.ok(score);\n    }\n\n    @GetMapping(\"/{roomName}/turn\")\n    public ResponseEntity<CurrentTurnDto> findTurn(@PathVariable(\"roomName\") final String roomName) {\n        final CurrentTurnDto currentTurn = roomService.findCurrentTurn(roomName);\n        return ResponseEntity.ok(currentTurn);\n    }\n\n    @GetMapping(\"/{roomName}/result\")\n    public ResponseEntity<EndResult> findResult(@PathVariable(\"roomName\") final String roomName) {\n        final EndResult endResult = chessService.result(roomName);\n        return ResponseEntity.ok(endResult);\n    }\n    ...\n}\n```\n\n이전 보다 확실히 직관적인 구조로 변경되어 핸들러 메서드들의 역할을 뚜렷하게 확인할 수 있게 되었다.\n\n## JdbcTemplate은 어디에?\n\nSpring Boot의 자동 구성은 애플리케이션에 적용할 수 있는 여러 구성 클래스로 작동한다. 이런 모든 구성은 Spring 4.0의 조건부 구성 지원 기능을 이용하여 `런타임 시점`에 구성을 사용할지 여부를 결정한다.\n\n아래는 `org.springframework.boot.autoconfigure.jdbc` 패키지에 위치한 `JdbcTemplateConfiguration` 클래스이다.\n\n```java\npackage org.springframework.boot.autoconfigure.jdbc;\n\n...\n\n@Configuration(proxyBeanMethods = false)\n@ConditionalOnMissingBean(JdbcOperations.class)\nclass JdbcTemplateConfiguration {\n\n\t@Bean\n\t@Primary\n\tJdbcTemplate jdbcTemplate(DataSource dataSource, JdbcProperties properties) {\n\t\tJdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);\n\t\tJdbcProperties.Template template = properties.getTemplate();\n\t\tjdbcTemplate.setFetchSize(template.getFetchSize());\n\t\tjdbcTemplate.setMaxRows(template.getMaxRows());\n\t\tif (template.getQueryTimeout() != null) {\n\t\t\tjdbcTemplate.setQueryTimeout((int) template.getQueryTimeout().getSeconds());\n\t\t}\n\t\treturn jdbcTemplate;\n\t}\n}\n```\n\n`jdbcTemplate(DataSource dataSource, JdbcProperties properties)` 메서드는 `@Bean` 애너테이션 덕분에 `JdbcTemplate Bean`을 구성해준다. 하지만 주목해야 할 것은 `@ConditionalOnMissingBean(JdbcOperations.class)` 부분이다.\n\n### @ConditionalOnMissingBean(JdbcOperations.class)\n\n`@ConditionalOnMissingBean`은 속성으로 전달된 `JdbcOperations` 타임의 `Bean`이 없을 때만 동작한다. `JdbcTemplate`은 바로 `JdbcOperations`의 구현체이다.\n\n```java\npublic class JdbcTemplate extends JdbcAccessor implements JdbcOperations {\n    ...\n}\n```\n\n만약 개발자가 명시적으로 `JdbcOperations` 타입의 Bean을 구성했다면 `@ConditionalOnMissingBean` 애너테이션의 조건에 만족하지 못하므로 해당 메서드는 사용되지 않는다. \n\n정리하면 나는 명시적으로 `JdbcTempalate`를 등록하지 않았다. 그렇기 때문에 `@ConditionalOnMissingBean` 애너테이션의 조건에 만족하여 `자동 구성에서 제공하는 JdbcTemplate를 Bean`으로 등록하여 사용하고 있는 것이다.\n\n리뷰어에게 관련 답변을 확인할 수 있었다.\n\n#### 리뷰 중 일부\n```markdown\n`매트`: Spring은 기본적으로 좀 더 명시적인 것을 우선순위로 판단하여 Bean을 등록한다고 알고 있습니다! 제가 추가적인 `JdbcTemplate`을 `Bean`으로 등록하지 않아 기본적으로 등록된 `JdbcTemplate`을 사용한다고 판단했는데 이해한 바가 맞는지 질문드립니다!\n\n`리뷰어`: 매트가 bean을 명시적으로 등록하지 않았기 때문에 spring-jdbc에 등록된 bean을 사용한 것입니다.\n설정에 있는 `@ConditionalOnMissingBean(JdbcOperations.class)`어노테이션이 `JdbcOperation.class`의 Bean이 없는경우에 해당 설정을 사용한다는 의미입니다.\n```\n\n## 도메인 객체와 엔티티 사이의 간극\n\nDB를 도입하던 중 Entity라는 키워드를 알게 되었다. \n\n### Entity란?\n\n실제 DB 테이블과 매핑되는 핵심 클래스이다. 이를 기준으로 테이블이 생성되고 스키마가 변경된다. 또한 Entity는 id로 구분된다. 그리고 비즈니스 로직을 포함할 수 있다.\n\n이전 미션을 진행하며 도메인에서 DB에 대한 의존성을 가지는 것은 좋지 않다고 판단했다. 그렇기 때문에 위와 같이 이해한 Entity와 같은 성격을 가진 객체를 전혀 사용하지 않고 있었다. 결국 Entity는 비즈니스 로직을 포함하기 때문에 도메인에 강한 의존성을 가진다고 판단했다.\n\n결국 이러한 고민을 진행한느 것은 도메인 객체와 DB 사이의 `패러다임의 차이`에서 오는 간극이라고 생각한다. 현재 구조에서 DB와 도메인 사이의 의존성을 최소화하며 간극을 줄일 수 있는 방법은 무엇이 있는지 궁금했다.\n\n#### 리뷰 중 일부\n```markdown\n`리뷰어`: 매트가 entity를 사용하지 않은 이유가 entity를 사용하면 domain이 entity로 대체될 거라고 생각했기 때문일까요??\n설명에 entity가 비지니스 로직을 포함할 수 있다고 하지만 이 말이 `entity=domain`이라는 의미는 아니라고 생각합니다.\nentity가 가진 데이터만으로 비지니스 로직이 진행될 수 있으면 바로 entity의 메서드를 사용할 수 있겠지만 여러 테이블의 데이터가 필요한 경우에는 entity를 가져온 이후에 entity를 domain으로 변환하여 비지니스 로직을 진행하도록 하거든요.\nentity는 db table의 저장된 데이터를 객체로 변환하지만 하나의 table에 필요한 모든 데이터가 있지 않을 수 있으니까요.\n개인적으로 entity를 db table의 데이터를 가지고 오기만 하고 이 entity를 domain으로 변환하여 로직이 진행되도록 통일해도 괜찮다고 생각합니다. 이 부분은 개발자의 선택일 테니까요 (아래의 의견은 이렇게 생각할 수 있다라는 개인적인 의견입니다.)\n\n* 모든 비지니스 로직은 domain에 정의된 객체에서 진행되도록 정한다. 즉, entity를 가져온 후 domain으로 변환한다. (통일성)\n* entity에서 자체적으로 비지니스 로직을 진행할 수 있다면 추가적으로 domain 객체를 만들지 않는다. (불필요한 객체 생성 자제)\n```\n\n위와 같은 리뷰를 확인할 수 있었다. Entity가 유의미한 비즈니스 로직을 가지고 있다고 해도 domain과 같다고 판단하지 말아야 한다는 것이다. 중요한 것은 `통일성`이다. Entity를 조합하여 domain으로 변환하기로 결정했다면 해당 로직들을 비슷한 구성으로 통일해야 한다.\n\n## References.\n\n * [3.1.3 자동 구성에 숨은 기능 엿보기](https://thebook.io/006859/ch03/01/03/)\n * [DTO vs VO vs Entity](https://tecoble.techcourse.co.kr/post/2021-05-16-dto-vs-vo-vs-entity/)\n"},{"excerpt":"개요 웹 체스 미션을 진행하던 중 Spring Jdbc를 도입하기 위해 이전에 연결된 JDBC에 대한 의존성을 제거한 뒤 에서 제공하는 을 활용하여 SQL 쿼리를 사용하였다. 하지만 나는 에 대한  등록을 진행하지 않았다. 그렇다면 누가 자동으로 등록한 것일까?  JDBC (Java DataBase Connectivity) 우선 이전에 사용하던 JDBC에…","fields":{"slug":"/why-jdbc-template/"},"frontmatter":{"date":"April 28, 2022","title":"JdbcTemplate는 어디에?","tags":["우아한테크코스","JDBC","spring-jdbc"]},"rawMarkdownBody":"\n![](https://user-images.githubusercontent.com/59357153/152970395-a31c8134-fc89-449f-b4dc-441e03df929c.png)\n\n## 개요\n\n웹 체스 미션을 진행하던 중 Spring Jdbc를 도입하기 위해 이전에 연결된 JDBC에 대한 의존성을 제거한 뒤 `Spring-jdbc`에서 제공하는 `JdbcTemplate`을 활용하여 SQL 쿼리를 사용하였다. 하지만 나는 `JdbcTemplate`에 대한 `Bean` 등록을 진행하지 않았다. 그렇다면 누가 자동으로 등록한 것일까?\n\n![](https://user-images.githubusercontent.com/59357153/165691946-6761593a-9ea0-4a4e-aa45-72674eebc92f.png)\n\n## JDBC (Java DataBase Connectivity)\n\n우선 이전에 사용하던 JDBC에 대해 간단히 알아본다. JDBC는 Java와 데이터베이스를 연결하기 위한 Java 표준 인터페이스이다. 아래 그림과 같이 MySql, oracle 등 다양한 DB의 미들웨어의 드라이버를 제공하고 있다. 덕분에 어떤 DB에 연결되는지에 따라 드라이버를 선택하여 적용할 수 있다. 또한 어떤 DB의 드라이버인지 상관없이 일관적인 방식으로 사용할 수 있도록 도와준다.\n\n![](https://user-images.githubusercontent.com/59357153/165686797-ec8e6f35-dbd1-4f7e-a2d3-dedf2bb50482.png)\n\n일반적인 JDBC를 그대로 사용하게 되면 아래와 같은 흐름으로 사용하게 된다.\n\n* JDBC 드라이버를 로드\n* DB를 연결\n* DB의 데이터 조회 및 쓰기\n* DB 연결 종료\n\n덕분에 DB에 접근하여 SQL 쿼리를 실행하기 위해 복잡한 코드를 동반하게 된다.\n\n```java\npublic class JdbcPieceDao implements PieceDao {\n\n    private static final String URL = \"jdbc:mysql://localhost:3306/chess\";\n    private static final String USER = \"user\";\n    private static final String PASSWORD = \"password\";\n\n    @Override\n    public void save(PieceDto pieceDto) {\n        String sql = \"INSERT INTO piece (id, piece_type) VALUES (?, ?)\";\n\n        try (Connection connection = getConnection();\n             PreparedStatement statement = connection.prepareStatement(sql)) {\n\n            statement.setString(1, pieceDto.getId());\n            PieceType pieceType = pieceDto.getPieceType();\n            statement.setString(2, pieceType.getType());\n\n            statement.executeUpdate();\n        } catch (SQLException e) {\n            throw new IllegalArgumentException(\"기물의 위치는 중복될 수 없습니다.\");\n        }\n    }\n    ...\n        private Connection getConnection() {\n        Connection connection = null;\n        try {\n            connection = DriverManager.getConnection(URL, USER, PASSWORD);\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n        return connection;\n    }\n}\n```\n\n## Spring JDBC \n\n`Spring JDBC`는 Driver 및 DB 연결과 `Connection` 객체의 관리를 수행하는 `DataSource`를 설정을 통해 생성하며 위에서 사용한 것 처럼 JDBC API를 직접 사용했을 때 불편했던 것들을 쉽게 사용할 수 있도록 도와준다.\n\n정리하면 JDBC API의 모든 저수준 처리를 Spring Framework에 위임하기 때문에 위에서 작성한 반복되는 처리를 개발자가 직접 처리하지 않고 Database에 대한 작업을 수행할 수 있도록 도와준다.\n\n## Data Access with JDBC\n\nJBDC 데이터베이스 접근의 기초를 형성하기 위해 여러 접근 방식을 선택할 수 있다.\n\n* `JdbcTemplate`: 고전적이고 가장 인기 있는 Spring JDBC 방식이다. `lowest-level` 접근법과 다른 모든 것들은 `JdbcTemplate`를 사용한다.\n\n* `NamedParameterJdbcTemplate`: 기존 JDBC `?` 표시자 대신 `명명된 매개 변수를 제공`하기 위해 `JdbcTemplate을 랩핑`한다. 이러한 접근 방식은 SQL 문에 대한 매개 변수가 여러 개 일 때 더 나은 문서화와 사용 편의성을 제공한다.\n\n* `SimpleJdbcInsert`: 데이터베이스 메타데이터를 최적화하여 필요한 구성 양을 제한한다. 해당 방법을 사용하면 테이블 또는 프로시저의 이름만 제공하고 `column 이름과 일치하는 맵`을 제공해야 하므로 코딩이 매우 간소화된다. 하지만 이것은 데이터베이스가 적절한 메타데이터를 제공하는 경우에만 작동한다. 데이터베이스가 이 메타데이터를 제공하지 않는 경우 매개 변수의 명시적 구성을 제공해야 한다.\n\n## JdbcTemplate는 어디에?\n\n이제 JDBC와 Spring JDBC에 대한 간단한 개념 정리를 진행했다. 본론으로 넘어와 `JdbcTemplate`를 자동으로 등록한 곳을 찾아보려 한다.\n\nSpring Boot의 자동 구성은 애플리케이션에 적용할 수 있는 여러 구성 클래스로 작동한다. 이런 모든 구성은 Spring 4.0의 조건부 구성 지원 기능을 이용하여 `런타임 시점`에 구성을 사용할지 여부를 결정한다.\n\n아래는 `org.springframework.boot.autoconfigure.jdbc` 패키지에 위치한 `JdbcTemplateConfiguration` 클래스이다.\n\n```java\npackage org.springframework.boot.autoconfigure.jdbc;\n\n...\n\n@Configuration(proxyBeanMethods = false)\n@ConditionalOnMissingBean(JdbcOperations.class)\nclass JdbcTemplateConfiguration {\n\n\t@Bean\n\t@Primary\n\tJdbcTemplate jdbcTemplate(DataSource dataSource, JdbcProperties properties) {\n\t\tJdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);\n\t\tJdbcProperties.Template template = properties.getTemplate();\n\t\tjdbcTemplate.setFetchSize(template.getFetchSize());\n\t\tjdbcTemplate.setMaxRows(template.getMaxRows());\n\t\tif (template.getQueryTimeout() != null) {\n\t\t\tjdbcTemplate.setQueryTimeout((int) template.getQueryTimeout().getSeconds());\n\t\t}\n\t\treturn jdbcTemplate;\n\t}\n}\n```\n\n`jdbcTemplate(DataSource dataSource, JdbcProperties properties)` 메서드는 `@Bean` 애너테이션 덕분에 `JdbcTemplate Bean`을 구성해준다. 하지만 주목해야 할 것은 `@ConditionalOnMissingBean(JdbcOperations.class)` 부분이다.\n\n### @ConditionalOnMissingBean(JdbcOperations.class)\n\n`@ConditionalOnMissingBean`은 속성으로 전달된 `JdbcOperations` 타임의 `Bean`이 없을 때만 동작한다. `JdbcTemplate`은 바로 `JdbcOperations`의 구현체이다.\n\n```java\npublic class JdbcTemplate extends JdbcAccessor implements JdbcOperations {\n    ...\n}\n```\n\n만약 개발자가 명시적으로 `JdbcOperations` 타입의 Bean을 구성했다면 `@ConditionalOnMissingBean` 애너테이션의 조건에 만족하지 못하므로 해당 메서드는 사용되지 않는다. \n\n정리하면 나는 명시적으로 `JdbcTempalate`를 등록하지 않았다. 그렇기 때문에 `@ConditionalOnMissingBean` 애너테이션의 조건에 만족하여 `자동 구성에서 제공하는 JdbcTemplate를 Bean`으로 등록하여 사용하고 있는 것이다.\n\n관련 키워드를 검색하기 위해 구글링하던 중 `stackOverflow`에서 관련 된 글을 찾아볼 수 있었다.\n\n### Question\n\n[How does spring boot inject the instance of ApplicationContext and JdbcTemplate using @Autowired without @Component annotation and xml configuration?](https://stackoverflow.com/questions/61452371/how-does-spring-boot-inject-the-instance-of-applicationcontext-and-jdbctemplate)\n\n**Spring Boot에서 @Component 및 xml 구성 없이 @Autowired를 사용하여 JdbcTemplate 인스턴스를 주입하는 방법은 무엇인가?**\n\ni'm in a spring boot app building rest controller.i find that ApplicationContext and JdbcTemplate source code,these 2 classes do not have any annotation.But they can be correctly injected into constructor.i am not using any configuration file like 'applicationContext.xml'.When do these 2 classes get scanned by spring ioc container?\n\n**ApplicationContext 및 JdbcTemplate 소스 코드, 이 두 클래스에는 annotation이 없다. 그러나 constructor에 올바르게 삽입할 수 있다. 'applicationContext.xml'과 같은 구성 파일을 사용하지 않았다.이 두 클래스는 언제 spring ioc 컨테이너로 스캔되는가?**\n\n### Answer\n\nSpring Boot does a lot of auto configuration.\n\n**Sprign Boot는 많은 자동 구성을 수행한다.**\n\nI assume that you are using spring-data-jdbc or spring-data-jpa and there for the JdbcTemplate is auto configured.\n\n**spring-data-jdbc 또는 spring-data-jpa를 사용하고 있으며 JdbcTemplate에 대해 자동 구성되었다고 가정한다.**\n\nThe most interesting project is: spring-boot-autoconfigure where all the magic happens.\n\n**가장 흥미로운 프로젝트는 `spring-boot-autoconfigure`이다. 모든 마술이 일어나는 곳이다!**\n\nAnd there you will find `JdbcTemplateConfiguration.java`\n\n**또한 `JdbcTemplateConfiguration.java` 관련 설정을 찾아볼 수 있다.**\n\n## 정리\n\n정리하면 우린 `spring-boot-autoconfigure` 덕분에 명시적으로 JdbcTemplate을 Bean으로 등록하지 않아도 자동 설정되므로 사용가능하다.\n\n이러한 자동 구성 덕분에 우리는 편리하게 기능에만 집중할 수 있게 된다. 만약 추가적인 JdbcTempalate에 대한 설정이 필요하다면 명시적인 등록을 추가하여 Bean으로 작성하기만 하면 된다. \n\n## References.\n\n[Spring Data Access](https://docs.spring.io/spring-framework/docs/current/reference/html/data-access.html)<br>\n[Infra layer with Spring — Spring jdbc 개념과 예시 코드](https://tech.junhabaek.net/infra-layer-with-spring-spring-jdbc-%EA%B0%9C%EB%85%90%EA%B3%BC-%EC%98%88%EC%8B%9C-%EC%BD%94%EB%93%9C-1c3f4e3ccb63)<br>\n[Spring JDBC](https://velog.io/@koseungbin/Spring-JDBC)<br>\n[How does spring boot inject the instance of ApplicationContext and JdbcTemplate using @Autowired without @Component annotation and xml configuration?](https://stackoverflow.com/questions/61452371/how-does-spring-boot-inject-the-instance-of-applicationcontext-and-jdbctemplate)\n"},{"excerpt":"일급 컬렉션 이란 을 하며 그외 다른 인스턴스 변수가 없는 상태를 말한다. 이러한 Wrapping이 가져오는 은 아래와 같다. 로 사용이 가능하다. Collection의 할 수 있다. 해당 Collection에 대한 할 수 있다. 간단히 정리하면 이다. 간단한 예시를 들어보면 스터디 개설 및 운영을 위한 시스템 개발을 진행한다고 가정한다. 한 스터디에는 …","fields":{"slug":"/first-class-collection/"},"frontmatter":{"date":"April 15, 2022","title":"일급 컬렉션","tags":["java","일급 컬렉션"]},"rawMarkdownBody":"\n\n## 일급 컬렉션\n\n`일급 컬렉션(First Class Collection)`이란 `Collection`을 `Wrapping`하며 그외 다른 인스턴스 변수가 없는 상태를 말한다. 이러한 Wrapping이 가져오는 `이점`은 아래와 같다.\n\n 1. `비즈니스에 종속적인 자료구조`로 사용이 가능하다.\n 2. Collection의 `불변성을 보장하도록 구현`할 수 있다.\n 3. 해당 Collection에 대한 `행위 까지 한 곳에서 관리`할 수 있다.\n\n간단히 정리하면 `비즈니스에 맞는 이름을 가지는 Collection을 만드는 것`이다.\n\n간단한 예시를 들어보면 스터디 개설 및 운영을 위한 시스템 개발을 진행한다고 가정한다. 한 스터디에는 다수의 스터디원을 등록할 수 있다. \n\n스터디원을 나타내는 `Student`이다.\n\n```java\npublic class Student {\n    private String name;\n    private int age;\n    ...\n}\n```\n\n한 스터디에는 다수의 스터디원을 가질 수 있다. 간단히 표시하면 아래와 같이 단순히 `List`를 활용하여 표현할 수 있다.\n\n```java\npublic class Study {\n    private String name;\n    private List<Student> students;\n    ...\n}\n```\n\n일급 컬렉션은 이러한 `List<Student> students`를 Wrapping하여 구현한다. 앞서 언급한 것 처럼 인스턴스 변수는 students `오직 하나`이다.\n\n```java\npublic class Students {\n    private List<Student> students;\n\n    public Students(List<Student> students) {\n        this.students = students;\n    }\n}\n```\n\n일급 컬렉션으로 개선한 Study 이다.\n\n```java\npublic class Study {\n    private String name;\n    private Students students;\n    ...\n}\n```\n\n## 이점 살펴보기\n\n위에서 작성한 스터디 개설 및 운영 시스템 활용한다. 스터디 개설을 위해서는 아래와 같은 조건이 필요하다고 가정한다.\n\n * 스터디 개설을 위해서는 `적어도 5명`의 스터디원이 필요하다.\n\n```java\npublic class Students {\n    public static final int STUDENTS_MIN_SIZE = 5;\n    \n    private List<Student> students;\n\n    public Students(List<Student> students) {\n        validateSize(students);\n        this.students = students;\n    }\n\n    private void validateSize(List<Student> students) {\n        if (students.size() < STUDENS_MIN_SIZE) {\n            throw new IllegalArgumentException();\n        }\n    }\n}\n```\n\n스터디원의 수가 적절한지 `직접 검증`한다. 외부에 의존하여 검증을 진행하는 것이 아니라 상태와 행위를 일급 컬렉션 안에서 모두 진행할 수 있다.\n\n또한 `적어도 5명이 필요한 Student List`는 기존에 제공되는 자료구조가 아니다. 해당 비즈니스(스터디 개설 및 운영 시스템)에 `종속된 자료구조`로 `추가적인 요구사항`에 유연하게 대처할 수 있다.\n\n이제 Students에 대한 로직은 `자체적으로 처리`가 가능하다. Students는 오직 `스터디원에 대한 책임(검증 행위 등)`만 가질 수 있다.\n\n## References\n\n[일급 컬렉션 (First Class Collection)의 소개와 써야할 이유](https://jojoldu.tistory.com/412)<br>\n[일급 컬렉션을 사용하는 이유](https://tecoble.techcourse.co.kr/post/2020-05-08-First-Class-Collection/)"},{"excerpt":"목표  우아한테크코스에서 진행한 미션의 리뷰와 피드백에 대해 정리한다. 실제 리뷰는 [4, 5단계 - 체스] 매트(최기현) 미션 제출합니다.에서 확인할 수 있다. 08. 4, 5단계 - 체스 리뷰 확인 드디어 레벨 1의 마지막 미션이 마무리 되었다. 2달의 기간이 정말 순식간에 지나간 것 같다. 이번 미션의 요구사항은 기존 도메인 구조를 최대한 유지하며 …","fields":{"slug":"/java-chess-step2/"},"frontmatter":{"date":"April 14, 2022","title":"[레벨 1] 08. 4, 5단계 - 체스","tags":["우아한테크코스","레벨1","미션"]},"rawMarkdownBody":"\n## 목표\n\n![](https://user-images.githubusercontent.com/59357153/152970395-a31c8134-fc89-449f-b4dc-441e03df929c.png)\n\n우아한테크코스에서 진행한 미션의 리뷰와 피드백에 대해 정리한다. 실제 리뷰는 [[4, 5단계 - 체스] 매트(최기현) 미션 제출합니다.](https://github.com/woowacourse/java-chess/pull/375)에서 확인할 수 있다.\n\n## 08. 4, 5단계 - 체스 리뷰 확인\n\n드디어 레벨 1의 마지막 미션이 마무리 되었다. 2달의 기간이 정말 순식간에 지나간 것 같다. 이번 미션의 요구사항은 기존 도메인 구조를 최대한 유지하며 DB와 WEB 구조를 도입하는 것이다. 하지만 처음 부터 전환 과정이 순탄했던 것은 아니다. 아래는 이번 미션을 통해 고민한 내용들을 정리하였다.\n\n## 객체와 DB 사이의 간극\n\n5단계에서 웹 서버를 재시작하더라도 이전에 하던 체스 게임을 다시 시작할 수 있어야 하는 요구사항이 추가되었다. 그렇기 때문에 DB에 기물과 위치에 관련된 정보를 관리해야 한다고 판단하였다.\n\n하지만 이전에 작성한 기물에 대한 도메인 정보를 DB에 녹여내는 것은 쉽지 않았다. 정리하면 `DB 테이블의 엔티티`와 `도메인 객체` 사이의 `패러다임`의 차이에서 오는 간극을 줄일 수 있는 뚜렷한 방법이 떠오르지 않았다.\n\n아래는 나이트를 나타내기 위한 `Knight` 객체이다.\n\n```java\npublic class Knight extends Piece {\n\n    private static final MovingStrategy MOVING_STRATEGY = new LengthBasedMovingStrategy(number -> number == 5);\n    private static final String NOTATION = \"N\";\n    private static final double SCORE = 2.5;\n\n    public Knight(Color color) {\n        super(color);\n    }\n\n    @Override\n    public void validateMove(Board board, Position source, Position target) {\n        if (MOVING_STRATEGY.canMove(board, source, target)) {\n            return;\n        }\n\n        throw new IllegalArgumentException(\"기물을 이동할 수 없습니다.\");\n    }\n\n    @Override\n    public boolean isKing() {\n        return false;\n    }\n\n    @Override\n    public boolean isPawn() {\n        return false;\n    }\n\n    @Override\n    public String getNotation() {\n        return color.parse(NOTATION);\n    }\n\n    @Override\n    public double getScore() {\n        return SCORE;\n    }\n}\n```\n\nKnight는 진영에 대한 정보와 이동 전략에 대한 정보들을 담고 있다. 이러한 객체 정보를 DB에서 관리하는 것은 한계가 있다고 생각했다. 아래는 DB로 관리하기 위한 정보를 기반으로 만든 테이블이다. DB에는 현재 포지션과 해당 포지션의 기물을 저장해두기 위해 테이블을 설계하였다.\n\n```sql\ncreate table piece\n(\n    id         varchar(2)  not null,\n    piece_type varchar(20) not null,\n    primary key (id)\n);\n```\n\nDB에는 대부분의 것들이 문자열로 저장된다. 해당 정보를 기반으로 도메인 객체로 변환해 주기 위한 객체가 필요해졌다. 그 역할을 담당하는 것은 `PieceType`이다.\n\n```java\npublic enum PieceType {\n\n    KING_WHITE(\"king white\", new King(Color.WHITE)),\n    QUEEN_WHITE(\"queen white\", new Queen(Color.WHITE)),\n    ROOK_WHITE(\"rook white\", new Rook(Color.WHITE)),\n    KNIGHT_WHITE(\"knight white\", new Knight(Color.WHITE)),\n    BISHOP_WHITE(\"bishop white\", new Bishop(Color.WHITE)),\n    PAWN_WHITE(\"pawn white\", new Pawn(Color.WHITE)),\n    KING_BLACK(\"king black\", new King(Color.BLACK)),\n    QUEEN_BLACK(\"queen black\", new Queen(Color.BLACK)),\n    ROOK_BLACK(\"rook black\", new Rook(Color.BLACK)),\n    KNIGHT_BLACK(\"knight black\", new Knight(Color.BLACK)),\n    BISHOP_BLACK(\"bishop black\", new Bishop(Color.BLACK)),\n    PAWN_BLACK(\"pawn black\", new Pawn(Color.BLACK));\n\n    private final String type;\n    private final Piece piece;\n\n    PieceType(String value, Piece piece) {\n        this.type = value;\n        this.piece = piece;\n    }\n\n    public static PieceType of(String pieceType) {\n        return Arrays.stream(values())\n                .filter(value -> value.type.equals(pieceType))\n                .findFirst()\n                .orElseThrow(() -> new IllegalArgumentException(\"존재하지 않는 기물 유형입니다.\"));\n    }\n\n    public Piece getPiece() {\n        return piece;\n    }\n\n    public String getType() {\n        return type;\n    }\n}\n```\n\nDB에 저장된 type 정보를 기반으로 그에 맞는 객체를 생성해준다. 해당 객체는 DB에 대한 의존성을 강하게 가지고 있기 때문에 도메인 패키지 외부에 위치하였다.\n\n![](https://user-images.githubusercontent.com/59357153/163393987-482221b4-a5f9-4a33-a34f-0d2e7b4d169a.png)\n\n### 도메인 객체는 소중하다\n\n위 처럼 도메인 객체를 DB에 저장하기 위해 변환을 위한 `enum`들은 초기에 도메인 객체 내부에 위치하였다. 관련해서 아래와 같은 리뷰를 확인할 수 있었다.\n\n#### 리뷰 중 일부\n```markdown\n`루피`: 본문에 적어주신 의도라면 해당 enum 객체는 도메인으로 분류해도 괜찮을까요? 도메인 객체가 DB 의 영향을 받는 것이 문제가 없을지 한번 생각해봐주시면 좋을 것 같아요.\n```\n\n즉 해당 로직들이 도메인 패키지 내부에 위치한다는 것은 도메인 내부에 DB와 관련된 의존성을 강하게 가지는 것을 의미한다. 만약 DB가 변경된다면 이것은 도메인의 변경까지 영향이 닿게된다. \n\n도메인은 매우 중요한 요구사항을 해결하기 위한 `비즈니스 로직`들이 담겨 있다. 외부의 변경으로 인해 중요한 도메인 로직이 변경되면 해당 도메인을 사용하는 애플리케이션은 어떤식으로 영향이 갈지 가늠할 수 없다. \n\n### State 객체와 DB\n\n이번 미션에서 가장 많은 고민을 진행한 것이다. 기존 State 객체는 상태 패턴을 통해 복잡한 상속 구조를 동반한다. 결국 복잡한 패턴은 DB에 데이터를 저장할 때 발목을 잡게 되었다. 객체 정보를 DB에 저장하는 것은 매우 어렵게 다가왔기 때문이다.\n\n관련하여 아래와 같은 질문을 남겼다.\n\n#### 리뷰 중 일부\n```markdown\n`매트`: 추가적으로 도메인 내부 DB에 대한 의존성을 없애던 중 추가적인 고민이 생겨 질문드립니다! 아래는 ChessGame의 상태 조회를 위한 메서드입니다.\n```\n\n```java\npublic class ChessGame {\n    ...\n    public State getState() {\n        return state;\n    }\n    ...\n}\n```\n\n```\n현재 로직에서 상태 정보 조회가 필요한 이유는 move이후 변경된 턴 정보를 저장하기 위해 필요합니다. 한 가지 우려되는 것은 state 자체를 반환하게 될 경우 모든 행위가 public한 특성으로 인해 의도적인 변경에 대비할 수 없다는 것입니다.\n\n결국 이러한 고민들이 생겨나는 이유는 애초에 도메인 객체 자체를 DB에 저장하기 힘든 구조로 설계한 탓이라고 판단하는데 이에 대한 루피의 의견이 궁금합니다.\n```\n\n#### 리뷰 중 일부\n```markdown\n`루피`: 리뷰 요청시 남겨주신 코멘트처럼 `패러다임 의 차이`로 객체의 상태를 관계형 데이터베이스의 상태에 저장하는 것은 어렵고 많은 고민이 필요한 과정이 맞다고 생각하는데요.\n\n결국에 한 쪽에 타협을 해야하고 도메인 객체에 맞춰 테이블 구조를 만들거나 테이블 구조에 맞춰 도메인 객체를 만들거나 둘 중 하나가 될 것 같은데, 저는 도메인 객체에 맞춰 테이블 구조를 만드는 것을 선호합니다 ㅎㅎ\n```\n\n그렇다면 처음 부터 DB에 친화적인 도메인 객체를 설계해야 할까? 아직은 확신이 서지 않는다. web과 DB로 전환하며 이전에는 고민하지 못했던 많은 것들을 생각하게 되는 계기가 되었다. 뚜렷한 답을 찾은 것은 아니지만 의식적인 연습을 통해 나만의 해답을 만들어 가야 한다.\n\n## 도메인 객체의 view 의존\n\n앞서 언급한 것 처럼 도메인은 외부(ex. view, DB 등)에 의존하는 것은 지양하는 것이 좋다. 이것은 직접적인 사용을 통해 의존하는 것과 `간접적으로 view에 의존하는 행위`를 만드는 것을 모두 포함한다. 아래는 관련한 리뷰를 정리한 것이다.\n\n```java\npublic abstract class Piece {\n\n    protected final Color color;\n\n    protected Piece(Color color) {\n        this.color = color;\n    }\n\n    ...\n\n    public String getColor() {\n        return color.getValue();\n    }\n}\n```\n\n#### 리뷰 중 일부\n```markdown\n`루피`: `getColor()` 메서드는 view 를 알고 있어야 만들어질 수 있는 메서드가 아닐까요 ?\n```\n\n해당 메서드는 view에서 기물의 color정보가 필요할 때 사용하기 위한 메서드이다. 이것 또한 view를 알고 있어야 만들어질 수 있는 메서드이다. 즉 간접적으로 view에 대한 의존성을 가지고 있다는 것이다.\n\n결국 `getColor()` 메서드는 아래와 같이 개선되었다.\n\n```java\npublic abstract class Piece {\n\n    protected final Color color;\n\n    protected Piece(Color color) {\n        this.color = color;\n    }\n\n    ...\n\n    public Color getColor() {\n        return color;\n    }\n}\n```\n\n이제 Piece는 더 이상 view에 대한 간접적인 의존성을 가지고 있지 않다. 해당 메서드는 view에 의해 추가된 것이 아니기 때문이다.\n\n해당 리뷰를 통해서 직접적으로 view를 사용하는 것 뿐만아니라 외부에 의해서 생기는 행위 조차도 지양하는 것이 좋다는 것을 알게 되었다. 루피 또한 아래와 같이 의견을 남겨 주었다.\n\n#### 리뷰 중 일부\n```markdown\n`루피`: 도메인 객체는 view 와 db 에 대하여 직접 아는 것(의존하는 것)과 간접적으로 아는 것을 모두 지양할수록 좋습니다.\n\n이유는 `언급하신 것 처럼 도메인에서 데이터베이스를 의존하는 것은 좋지 않다고 생각합니다. 만약 요구사항의 변경으로 데이터베이스가 변경되면 가장 중요한 도메인도 영향을 끼칠 수 있기 때문이라고 판단합니다.`라고 남겨 주신 이유 때문입니다.\n```\n\n## fake 객체를 통한 테스트 더블\n\nDB 도입 이전에 fake DAO를 통해 개발을 진행했다. 덕분에 DB에 대한 의존성 없이 service 계층을 구현할 수 있었고 DB와 연동된 DAO가 개발이 완료된 후 의존성 주입을 통해 손쉽게 구현체를 변경할 수 있었다.\n\n#### 테스트 더블 중 fake\n```markdown\n* 복잡한 로직이나 객체 내부에서 필요로 하는 다른 외부 객체들의 동작을 단순화하여 구현한 객체이다.\n* 동작의 구현을 가지고 있지만 실제 프로덕션에는 적합하지 않은 객체이다.\n```\n\n아래는 이번 미션에서 작성한 `fake DAO` 이다.\n\n```java\npublic class MemoryPieceDao implements PieceDao {\n\n    private static Map<String, PieceDto> store = new HashMap<>();\n\n    @Override\n    public void save(PieceDto pieceDto) {\n        if (store.containsKey(pieceDto.getId())) {\n            throw new IllegalArgumentException(\"기물의 위치는 중복될 수 없습니다.\");\n        }\n\n        store.put(pieceDto.getId(), pieceDto);\n    }\n\n    @Override\n    public Optional<PieceDto> findById(String id) {\n        if (!store.containsKey(id)) {\n            return Optional.empty();\n        }\n\n        return Optional.of(store.get(id));\n    }\n\n    @Override\n    public void remove(String id) {\n        if (!store.containsKey(id)) {\n            throw new IllegalArgumentException(\"기물이 존재하지 않습니다.\");\n        }\n\n        store.remove(id);\n    }\n\n    @Override\n    public List<PieceDto> findAll() {\n        return store.entrySet()\n                .stream()\n                .map(Entry::getValue)\n                .collect(toList());\n    }\n\n    @Override\n    public void removeAll() {\n        store = new HashMap<>();\n    }\n}\n```\n\n```java\npublic class MemoryTurnDao implements TurnDao {\n\n    private static final List<TurnDto> store = new ArrayList<>();\n\n    @Override\n    public void save(TurnDto turnDto) {\n        store.add(turnDto);\n    }\n\n    @Override\n    public Optional<TurnDto> findLastTurn() {\n        return Optional.of(store.get(store.size() - 1));\n    }\n}\n```\n\n또한 테스트를 진행할 때 이러한 fake DAO를 통해 service가 가진 행위에 집중하여 `DB와 격리된 테스트`를 진행할 수 있다.\n\n```java\nclass ChessServiceTest {\n\n    private ChessService chessService;\n    private PieceDao pieceDao;\n    private TurnDao turnDao;\n\n    @BeforeEach\n    void setUp() {\n        pieceDao = new MemoryPieceDao();\n        turnDao = new MemoryTurnDao();\n        chessService = new ChessService(pieceDao, turnDao);\n    }\n\n    @DisplayName(\"ready를 할 경우 게임은 준비 상태가 된다.\")\n    @Test\n    void 레디_게임_준비한다() {\n        chessService.ready();\n\n        ChessGame chessGame = chessService.getChessGame();\n        StateType stateType = StateType.of(chessGame.getState());\n\n        assertThat(stateType).isEqualTo(StateType.READY);\n    }\n\n    @DisplayName(\"새 게임을 생성한다.\")\n    @Test\n    void 새_게임_생성한다() {\n        chessService.create();\n\n        ChessGame chessGame = chessService.getChessGame();\n        StateType stateType = StateType.of(chessGame.getState());\n\n        assertThat(stateType).isEqualTo(StateType.WHITE_TURN);\n    }\n\n    @DisplayName(\"체스의 기물을 움직인다.\")\n    @Test\n    void 기물_움직인다() {\n        chessService.create();\n\n        ChessGame chessGame = chessService.getChessGame();\n        chessGame.move(\"a2\", \"a4\");\n        StateType stateType = StateType.of(chessGame.getState());\n\n        assertThat(stateType).isEqualTo(StateType.BLACK_TURN);\n    }\n\n    @AfterEach\n    void tearDown() {\n        pieceDao.removeAll();\n    }\n}\n```\n\n`@BeforeEach`를 통해 setUp을 진행할 때 fake DAO를 생성하여 테스트를 진행한다.\n\n## 미션 회고\n\n이번 미션을 대하는 나의 마음가짐은 정말 최악이었다. 비교적 여유로운 기간이 더욱 나태하게 만들었다. 또한 미션이 마무리되고 방학이 진행되었기 때문에 의욕은 점점 떨어져 갔다. \n\n이것들은 결국 다 핑계일 뿐이다. 단지 크루들과 술을 마시며 노는 것이 더욱 즐거웠기에 미션을 등한시 했다. 결과적으로 퀄리티 떨어지는 질문을 남길 수 밖에 없었고 많은 실패를 경험하지 못했다. 즉 레벨 1에서만 얻을 수 있는 많은 인사이트들을 놓치고 지나가게 된 것이다. \n\n다가오는 레벨 2를 이번 미션 처럼 보낼 수 없다. 미션을 진행하며 느꼈던 감정을 들을 까먹지 않고 온전히 받아들이고 반성하며 부끄러워하자. \n\n## References\n\n[Test Double을 알아보자](https://tecoble.techcourse.co.kr/post/2020-09-19-what-is-test-double/)\n"},{"excerpt":"불변 객체 란, 생성 후 그 상태를 바꿀 수 없는 객체이다. 불변을 만들기 위해서는 과 에서 다른 방식으로 적용해야 한다. 기본형 타입의 불변 기본형 타입의 경우 참조 값이 아닌 실제 값이 저장되기 때문에 쉽게 적용이 가능하다. 내부 상태를 변경할 방법을 제한하면 불변을 보장한다. 즉  생성을 제한하거나  키워드를 사용하면 된다. 참조형 타입의 불변 참조…","fields":{"slug":"/immutable-object/"},"frontmatter":{"date":"April 01, 2022","title":"불변 객체","tags":["java","불변 객체","immutable object"]},"rawMarkdownBody":"\n## 불변 객체\n\n`불변 객체(Immutable Object)`란, 생성 후 그 상태를 바꿀 수 없는 객체이다. 불변을 만들기 위해서는 `기본형 타입`과 `참조형 타입`에서 다른 방식으로 적용해야 한다.\n\n## 기본형 타입의 불변\n\n기본형 타입의 경우 참조 값이 아닌 실제 값이 저장되기 때문에 쉽게 적용이 가능하다. 내부 상태를 변경할 방법을 제한하면 불변을 보장한다. 즉 `setter` 생성을 제한하거나 `final` 키워드를 사용하면 된다.\n\n```java\npublic class Student {\n    private final int age;\n\n    public Student(int age) {\n        this.age = age;\n    }\n\n    public int getAge() {\n        return age;\n    }\n}\n```\n\n## 참조형 타입의 불변\n\n참조형 변수를 불변으로 만들기 위해서는 고려해야 할 것이 많다. 단순히 `final` 키워드를 사용할 경우 단순히 해당 참조 변수의 재할당만 막을 뿐이다.\n\n아래는 간단한 예시 작성을 위한 `일급 컬렉션`이다.\n\n```java\npublic class Student {\n    private String name;\n    private int age;\n\n    public Student(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n}\n```\n\n```java\npublic class Students {\n    private final List<Student> students;\n\n    public Students(List<Student> students) {\n        this.students = students;\n    }\n\n    public List<Student> getStudents() {\n        return students;\n    }\n}\n```\n\n인스턴스 변수를 Student List 하나만 갖는 `일급 컬렉션`이다. 살펴보면 `setter`가 존재하지 않기 때문에 자칫 잘못하면 `불변 객체`로 오해하기 쉽다.\n\n만약 원본 리스트가 3명의 학생을 가진다고 가정한다. 해당 리스트를 기반으로 Students를 생성한다. 불변성을 보장하기 위해서는 원본인 studentList에 값을 추가하더라도 Students 안에 students는 그대로 3명의 학생을 가져야 한다.\n\n```java\nclass StudentsTest {\n\n    @DisplayName(\"원본 리스트에서 값을 추가하면 해당 내부 리스트 또한 변경된다. 즉 불변이 아니다.\")\n    @Test\n    void 원본리스트에서_추가하면_변경된다() {\n        // given\n        Student student1 = new Student(\"학생1\", 20);\n        Student student2 = new Student(\"학생2\", 20);\n        Student student3 = new Student(\"학생3\", 20);\n\n        List<Student> studentList = new ArrayList<>(Arrays.asList(student1, student2, student3));\n\n        Students students = new Students(studentList);\n\n        // when\n        studentList.add(new Student(\"학생4\", 20));\n\n        // then\n        assertThat(students.getStudents().size()).isEqualTo(3);\n    }\n}\n```\n\n하지만 위 테스트는 `실패`한다. 이유는 원본 리스트와 Students의 students는 같은 주소를 가지고 있기 때문에 `heap` 메모리 안에 데이터를 공유하고 있다. 즉 원본 리스트가 수정되면 불변을 보장할 수 없다.\n\n이것을 막기 위해서는 생성 시점에 `방어적 복사`를 진행해야 한다.\n\n### 방어적 복사\n\n방어적 복사란, 생성자의 인자로 받은 객체의 `복사본`을 만들어` 내부 변수를 초기화`하거나 `getter` 메서드가 내부 변수를 반환할 때 객체의 복사본을 만들어 반환하는 것이다. 즉 `내부 객체를 보호`하기 위해 방어적인 복사를 사용하는 것이다.\n\n이것을 적용한 `Students`는 아래와 같다.\n\n```java\npublic class Students {\n    private final List<Student> students;\n\n    public Students(List<Student> students) {\n        this.students = new ArrayList<>(students);\n    }\n\n    public List<Student> getStudents() {\n        return students;\n    }\n}\n```\n\n이제 원본 리스트와 주소를 공유하지 않는다.\n\n```java\nclass StudentsTest {\n\n    @DisplayName(\"원본 리스트에서 값을 추가하면 해당 내부 리스트는 변경되지 않는다. 불변일까?\")\n    @Test\n    void 원본리스트에서_추가하면_변경되지_않는다() {\n        // given\n        Student student1 = new Student(\"학생1\", 20);\n        Student student2 = new Student(\"학생2\", 20);\n        Student student3 = new Student(\"학생3\", 20);\n\n        List<Student> studentList = new ArrayList<>(Arrays.asList(student1, student2, student3));\n\n        Students students = new Students(studentList);\n\n        // when\n        studentList.add(new Student(\"학생4\", 20));\n\n        // then\n        assertThat(students.getStudents().size()).isEqualTo(3);\n    }\n}\n```\n\n한 가지 주의해야 할 점은 방어적 복사는 `깊은 복사가 아니다`. 즉 내부 요소들은 `여전히 공유`되고 있다. 즉 내부 요소가 불변성을 보장하지 않고 수정이 가능하면 해당 요소를 가지는 리스트도 불변성을 보장하지 못한다. 또한 getter를 통해 내부 List를 `그대로 반환`하는 것도 불변에 있어서 큰 문제를 야기한다.\n\n```java\nclass StudentsTest {\n\n    @DisplayName(\"요소들은 공유된다. 즉 불변이 아니다.\")\n    @Test\n    void 요소들은_공유된다() {\n        // given\n        Student student1 = new Student(\"학생1\", 20);\n        Student student2 = new Student(\"학생2\", 20);\n        Student student3 = new Student(\"학생3\", 20);\n\n        List<Student> studentList = new ArrayList<>(Arrays.asList(student1, student2, student3));\n\n        Students students = new Students(studentList);\n\n        // when\n        for (Student student : studentList) {\n            student.setAge(10); // 값 수정\n        }\n\n        // then\n        assertThat(students.getStudents().get(0).getAge()).isEqualTo(20); // 테스트 실패\n    }\n\n    @DisplayName(\"get으로 반환된 리스트를 통해 내부 리스트 변경이 가능하다. 즉 불변이 아닌다.\")\n    @Test\n    void get으로_내부리스트_변경이_가능하다() {\n\n        // given\n        Student student1 = new Student(\"학생1\", 20);\n        Student student2 = new Student(\"학생2\", 20);\n        Student student3 = new Student(\"학생3\", 20);\n\n        List<Student> studentList = new ArrayList<>(Arrays.asList(student1, student2, student3));\n\n        Students students = new Students(studentList);\n\n        // when\n        List<Student> studentsInStudentList = students.getStudents();\n        studentsInStudentList.add(new Student(\"학생4\", 20)); // 요소 추가\n\n        // then\n        assertThat(students.getStudents().size()).isEqualTo(3); // 테스트 실패\n    }\n}\n```\n\n위 두 테스트는 모두 `실패`한다. 즉 내부 상태를 보호하지 못한다. 이때 필요한 것은 Unmodifiable Collection이다.\n\n### Unmodifiable Collection\n\nUnmodifiable Collection을 이용하면 변경이 일어날 때 즉시 `UnsupportedOperationException` 예외를 던진다. 즉 해당 리스트를 `읽기 전용`으로 사용할 수 있다.\n\n```java\nclass StudentsTest {\n\n    @DisplayName(\"값을 추가하면 예외를 던진다.\")\n    @Test\n    void 값을_추가하면_예외를_던진다() {\n        // given\n        Student student1 = new Student(\"학생1\", 20);\n        Student student2 = new Student(\"학생2\", 20);\n        Student student3 = new Student(\"학생3\", 20);\n\n        List<Student> studentList = new ArrayList<>(Arrays.asList(student1, student2, student3));\n\n        Students students = new Students(studentList);\n\n        // when & then\n        assertThatThrownBy(() -> {\n            students.getStudents().add(new Student(\"학생4\", 20));\n        }).isInstanceOf(UnsupportedOperationException.class);\n    }\n    ...\n}\n```\n\n하지만 이것이 완벽한 불변성을 보장해주지 않는다. 최초 예제처럼 원본 리스트가 변경될 경우 읽기 전용으로 선언한 리스트도 똑같이 변경되기 때문에 주의해서 사용해야 한다.\n\n## 정리\n\n정리하면 결국 내부 객체를 완벽히 보호하기 위해서는 `방어적 복사`와 `unmodifiable collection`을 적절히 활용해야 한다. 또한 내부의 모든 요소들이 불변성을 보장해야만 불변 객체를 만들 수 있다.\n\n```java\npublic class Student {\n    private final String name;\n    private final int age;\n\n    public Student(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n}\n```\n\n```java\npublic class Students {\n    private final List<Student> students;\n\n    public Students(List<Student> students) {\n        this.students = new ArrayList<>(students);\n    }\n\n    public List<Student> getStudents() {\n        return Collections.unmodifiableList(students);\n    }\n}\n```\n\n## References\n\n[불변객체를 만드는 방법](https://tecoble.techcourse.co.kr/post/2020-05-18-immutable-object/)<br>\n[방어적 복사와 Unmodifiable Collection](https://tecoble.techcourse.co.kr/post/2021-04-26-defensive-copy-vs-unmodifiable/)<br>\n"},{"excerpt":"목표  우아한테크코스에서 진행한 미션의 리뷰와 피드백에 대해 정리한다. 실제 리뷰는 [1, 2, 3단계 - 체스] 매트(최기현) 미션 제출합니다.에서 확인할 수 있다. 07. 1, 2, 3단계 - 체스 리뷰 확인 드디어 레벨 1의 마지막 미션인 체스가 시작 되었다. 체스는 비교적 어려운 요구사항을 가지고 있기 때문에 구현 기능 목록을 정리하는 것도 쉽지 …","fields":{"slug":"/java-chess-step1/"},"frontmatter":{"date":"March 31, 2022","title":"[레벨 1] 07. 1, 2, 3단계 - 체스","tags":["우아한테크코스","레벨1","미션"]},"rawMarkdownBody":"\n## 목표\n\n![](https://user-images.githubusercontent.com/59357153/152970395-a31c8134-fc89-449f-b4dc-441e03df929c.png)\n\n우아한테크코스에서 진행한 미션의 리뷰와 피드백에 대해 정리한다. 실제 리뷰는 [[1, 2, 3단계 - 체스] 매트(최기현) 미션 제출합니다.](https://github.com/woowacourse/java-chess/pull/302)에서 확인할 수 있다.\n\n## 07. 1, 2, 3단계 - 체스 리뷰 확인\n\n드디어 레벨 1의 마지막 미션인 체스가 시작 되었다. 체스는 비교적 어려운 요구사항을 가지고 있기 때문에 구현 기능 목록을 정리하는 것도 쉽지 않았다. TDD, 객체의 책임 부여 등 지금까지 학습한 내용을 최대한 반영하여 진행하기 위해 노력했다.\n\n## 상태 패턴 도입\n\n블랙잭 미션 당시 상태 패턴에 대한 수업은 굉장히 재밌게 다가 왔다. 상태 조차도 객체라는 단위로 나눠서 추상화할 수 있다는 것이 큰 흥미를 이끌었다. 이번 미션에서도 처음 부터 상태 패턴을 고려하여 도입한 것은 아니지만 반복되는 if문 분기를 처리하기 위해서 떠올리게 되었다.\n\n체스는 여러 가지 상태를 가지고 있다. 게임이 시작되면 White 진영부터 기물을 옮길 수 있다. 측 white turn이 된다. 이제 white와 black으로 번갈아 가며 상태가 변경된다.\n\n### State\n\n필요한 공통 상태를 선언한 인터페이스이다.\n\n```java\npublic interface State {\n\n    State start();\n\n    State end();\n\n    State move(String source, String target);\n\n    boolean isFinished();\n\n    Result winner();\n\n    ChessBoard chessBoard();\n}\n```\n\n해당 인터페이스를 기반으로 적절한 상태를 하위 클래스로 만들어 구현하였다. \n\n### Ready\n\n모든 상태의 시작은 `Ready`로 부터 시작된다. 외부에서 사용할 때 `중간 상태에서 시작하는 것`을 의도적으로 막기 위해서이다. Ready에서는 오직 시작과 관련된 행위만 가능하다. 게임을 시작하게 되면 White 진영 부터 기물을 옮길 수 있다.\n\n```java\npublic class Ready extends Started {\n\n    public Ready() {\n        super(new ChessBoard(new InitBoardGenerator()));\n    }\n\n    @Override\n    public State start() {\n        return new WhiteTurn(chessBoard);\n    }\n\n    @Override\n    public State end() {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public State move(String source, String target) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public boolean isFinished() {\n        return false;\n    }\n\n    @Override\n    public Result winner() {\n        throw new UnsupportedOperationException();\n    }\n}\n```\n\n### WhiteTurn과 BlackTurn\n\n특정 진영의 턴을 나타내기 위한 상태이다. source 위치의 기물이 해당 진영의 기물인지 확인 한 뒤 이동하여 게임의 종료 여부를 확인 한다. 기물 이동이 정상적으로 진행되면 다른 진영의 턴으로 상태를 변환해준다.\n\n```java\npublic class WhiteTurn extends Running {\n\n    protected WhiteTurn(ChessBoard chessBoard) {\n        super(chessBoard);\n    }\n\n    @Override\n    public State move(String source, String target) {\n        if (chessBoard.isTurn(source, Color.WHITE)) {\n            throw new IllegalArgumentException(\"black 진영의 차례가 아닙니다.\");\n        }\n\n        chessBoard.move(source, target);\n\n        if (chessBoard.isFinished()) {\n            return new WhiteWin(chessBoard);\n        }\n\n        return new BlackTurn(chessBoard);\n    }\n}\n```\n\n```java\npublic class BlackTurn extends Running {\n\n    protected BlackTurn(ChessBoard chessBoard) {\n        super(chessBoard);\n    }\n\n    @Override\n    public State move(String source, String target) {\n        if (chessBoard.isTurn(source, Color.BLACK)) {\n            throw new IllegalArgumentException(\"white 진영의 차례가 아닙니다.\");\n        }\n\n        chessBoard.move(source, target);\n\n        if (chessBoard.isFinished()) {\n            return new BlackWin(chessBoard);\n        }\n\n        return new WhiteTurn(chessBoard);\n    }\n}\n```\n\n### WhiteWin, BlackWin 그리고 End \n\n게임이 끝난 것을 나타내기 위한 상태들이다. 기본적으로 `Finished`를 통해 공통적인 행위를 추상화하였다.\n\n```java\npublic abstract class Finished extends Started {\n\n    protected Finished(ChessBoard chessBoard) {\n        super(chessBoard);\n    }\n\n    @Override\n    public final State start() {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public final State end() {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public final State move(String source, String target) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public final boolean isFinished() {\n        return true;\n    }\n}\n```\n\n끝난 상태 이므로 오직 가능한 행위는 끝났는지 확인하는 것 뿐이다. 다른 행위들은 오작동하지 않도록 모두 예외를 던진다.\n\n또한 각 진영이 승리하게 되면 winner를 확인할 수 있다. \n\n```java\npublic class WhiteWin extends Finished {\n\n    protected WhiteWin(ChessBoard chessBoard) {\n        super(chessBoard);\n    }\n\n    @Override\n    public Result winner() {\n        return Result.WHITE;\n    }\n}\n```\n\n`End`의 경우 외부의 특수한 커맨드로 인해 동작한다. 현재 남아있는 기물들을 판단하여 승패를 결정한다.\n\n```java\npublic class End extends Finished {\n\n    protected End(ChessBoard chessBoard) {\n      super(chessBoard);\n    }\n\n    @Override\n    public Result winner() {\n        double whiteScore = chessBoard.calculateScore(Color.WHITE);\n        double blackScore = chessBoard.calculateScore(Color.BLACK);\n\n        return Result.of(whiteScore, blackScore);\n    }\n}\n```\n\n이제 작성한 상태는 외부에서 작성한 명령어로 인해 변경된다. 실제 상태를 가진 `ChessGame`이다.\n\n```java\npublic class ChessGame {\n\n    private State state;\n\n    public ChessGame() {\n        this.state = new Ready();\n    }\n\n    public void start() {\n        state = state.start();\n    }\n\n    public void end() {\n        state = state.end();\n    }\n\n    public void move(String source, String target) {\n        state = state.move(source, target);\n    }\n\n    public boolean isFinished() {\n        return state.isFinished();\n    }\n\n    public double score(Color color) {\n        ChessBoard chessBoard = state.chessBoard();\n        return chessBoard.calculateScore(color);\n    }\n\n    public Result result() {\n        return state.winner();\n    }\n\n    public List<List<Piece>> board() {\n        ChessBoard chessBoard = state.chessBoard();\n        Board board = chessBoard.getBoard();\n        return board.getValue();\n    }\n}\n```\n\n클라이언트는 약속된 명령어를 통해 상태를 변경시킬 수 있다. 실제 명령을 내리는 부분은 아래와 같다.\n\n```java\npublic enum Command {\n\n    START(\"start\", (chessGame, arguments) -> {\n        chessGame.start();\n        OutputView.printChessBoard(chessGame.board());\n    }),\n\n    END(\"end\", (chessGame, arguments) -> {\n        chessGame.end();\n    }),\n\n    MOVE(\"move\", (chessGame, arguments) -> {\n        chessGame.move(arguments.get(0), arguments.get(1));\n        OutputView.printChessBoard(chessGame.board());\n    }),\n\n    STATUS(\"status\", (chessGame, arguments) -> {\n        double whiteScore = chessGame.score(Color.WHITE);\n        double blackScore = chessGame.score(Color.BLACK);\n        OutputView.printStatusMessage(whiteScore, blackScore);\n    });\n\n    private final String type;\n    private final BiConsumer<ChessGame, List<String>> consumer;\n\n    Command(String type, BiConsumer<ChessGame, List<String>> consumer) {\n        this.type = type;\n        this.consumer = consumer;\n    }\n\n    public static Command of(String input) {\n        return Arrays.stream(values())\n                .filter(command -> input.equals(command.type))\n                .findFirst()\n                .orElseThrow(() -> new IllegalArgumentException(\"존재하지 않는 명령입니다.\"));\n    }\n\n    public void accept(ChessGame chessGame, String source, String target) {\n        consumer.accept(chessGame, List.of(source, target));\n    }\n}\n```\n\n특정 명령어를 입력하면 `BiConsumer`를 통해 상태를 변경하도록 메시지를 던진다.\n\n## 비어있는 Piece\n\n체스판에는 64칸 중 최대 32칸의 기물을 위치 시킬 수 있다. 체스판은 이차원 리스트를 활용하여 세팅해 두었다.\n\n그렇기 때문에 기물이 존재하지 않는 칸들을 적절히 처리해주어야 한다. 단순히 `null`을 사용할 수 있지만 특수한 객체를 활용하여 비어있는 칸을 나타내는 Piece를 활용하였다.\n\n```java\npublic class EmptyPiece extends Piece {\n\n    public EmptyPiece() {\n        super(PieceType.EMPTY, Color.NONE);\n    }\n\n    @Override\n    public void validateMove(Board board, Position source, Position target) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return true;\n    }\n}\n```\n\n`EmptyPiece`는 오직 비어있는지에 대한 유무를 확인할 수 있다.\n\n### 널(Null) 객체 패턴\n\n처음 의도는 단순히 null을 사용하는 것 보다 명시적이라고 판단하여 사용하였다. 스터디 중 우연히 널 객체 패턴에 대한 자료를 접한 뒤 EmptyPiece에 적용한 내용과 굉장히 유사하다고 판단하였다.\n\n* null 대신 사용할 클래스를 구현한다. 이 클래스는 `상위 타입을 상속 `받으며 아무 기능도 수행하지 않는다.\n* null을 리턴하는 대신 null을 대체할 클래스의 객체를 리턴한다.\n\n이러한 널 객체 패턴은 null 검증을 위한 코드를 없애주며 코드의 가독성을 높여 준다. 또한 null을 사용하지 않기 때문에 의도하지 않은 `NullPointerException`을 피할 수 있다.\n\n하지만 이러한 널 객체 패턴은 장점만 존재하는 것은 아니다. 널 객체는 실제 객체와 똑같은 모든 메시지에 응답하기 때문에 대부분의 시스템에서 정상적으로 작동할 것이다. 하지만 잘못되서 빠져나오는 부분이 없기 때문에 문제를 감지하거나 찾기 힘들어질 수 있다고 한다.\n\n## 큰 문제를 작은 문제로 나누어 적용하자\n\n이번 체스 미션은 유독 요구사항을 파악하고 정리하는 과정이 어렵게 다가 왔다. 특히 복잡한 검증 로직을 동반하기 때문에 특별한 가이드 라인 없이 무에서 유를 창조하는 과정이 가장 힘들었다.\n\n그 중 나를 가장 많이 괴롭힌 것은 `Pawn`이다. `Pawn`은 진영 별로 이동하기 위한 전략이 다르고 다른 기물을 `capture`하기 위한 조건도 까다롭다. 이것이 미션 내내 나의 발목을 붙잡았다.\n\n아래는 수정 이전의 Pawn 이동 전략이다.\n\n```java\npublic class BlackPawnMovingStrategy implements MovingStrategy {\n\n    private static final int RANK_INDEX_STARTING_POINT = 1;\n    private static final Direction MOVABLE_DIRECTION = Direction.BOTTOM;\n    private static final List<Direction> CAPTURABLE_DIRECTIONS = List.of(Direction.BOTTOM_LEFT, Direction.BOTTOM_RIGHT);\n\n    @Override\n    public void validateMove(List<List<Piece>> board, Position sourcePosition, Position targetPosition) {\n        int rankLength = Math.abs(sourcePosition.getRankIndex() - targetPosition.getRankIndex());\n        int fileLength = Math.abs(sourcePosition.getFileIndex() - targetPosition.getFileIndex());\n        Direction direction = Direction.of(sourcePosition, targetPosition);\n\n        if (direction == MOVABLE_DIRECTION && isMovableLengthAtMove(sourcePosition, rankLength)) {\n            validateMoveTop(sourcePosition, rankLength, findPiece(board, sourcePosition.add(direction)));\n            validateExistPiece(findPiece(board, targetPosition));\n            return;\n        }\n        if (CAPTURABLE_DIRECTIONS.contains(direction) && isMovableLengthAtCapture(rankLength, fileLength)) {\n            validateCapture(findPiece(board, targetPosition));\n            return;\n        }\n\n        throw new IllegalArgumentException(\"해당 기물이 갈 수 없는 경로입니다.\");\n    }\n\n    private boolean isMovableLengthAtMove(Position sourcePosition, int rankLength) {\n        return rankLength == 1\n                || (sourcePosition.getRankIndex() == RANK_INDEX_STARTING_POINT && rankLength == 2);\n    }\n\n    private void validateMoveTop(Position source, int rankLength, Piece piece) {\n        if (rankLength == 2 && source.getRankIndex() == RANK_INDEX_STARTING_POINT) {\n            validateExistPiece(piece);\n        }\n    }\n\n    private void validateExistPiece(Piece piece) {\n        if (!piece.isEmpty()) {\n            throw new IllegalArgumentException(\"경로에 기물이 존재하여 이동할 수 없습니다.\");\n        }\n    }\n\n    private boolean isMovableLengthAtCapture(int rankLength, int fileLength) {\n        return rankLength + fileLength == 2;\n    }\n\n    private void validateCapture(Piece targetPiece) {\n        validateEmptyPiece(targetPiece);\n        validateSameColor(targetPiece);\n    }\n\n    private void validateEmptyPiece(Piece piece) {\n        if (piece.isEmpty()) {\n            throw new IllegalArgumentException(\"target 위치에 기물이 존재하지 않아 공격할 수 없습니다.\");\n        }\n    }\n\n    private void validateSameColor(Piece targetPiece) {\n        if (targetPiece.isBlack()) {\n            throw new IllegalArgumentException(\"공격은 다른 진영만 가능합니다.\");\n        }\n    }\n\n    private Piece findPiece(List<List<Piece>> board, Position position) {\n        int rankIndex = position.getRankIndex();\n        int fileIndex = position.getFileIndex();\n\n        return board.get(rankIndex).get(fileIndex);\n    }\n}\n```\n\n이동 전략을 분석하기도 어렵고 가독성 또한 떨어진다. 해당 로직은 수정이 필요하다고 판단했다.\n\n우선 `큰 문제`를 `작은 문제`로 나눠서 접근하였다. Pawn은 크게 3개의 이동 전략을 가지고 있다.\n\n* Pawn은 시작점에서 1칸 혹은 2칸 이동이 가능하다.\n* Pawn은 기본적으로 1칸 이동이 가능하다.\n* Pawn은 캡처할 때 대각선 방향이어야 한다.\n\n### Pawn은 시작점에서 1칸 혹은 2칸 이동이 가능하다.\n\n```java\npublic class PawnStartingPointMovingStrategy implements MovingStrategy {\n\n    private final int startIndex;\n    private final Direction direction;\n\n    public PawnStartingPointMovingStrategy(int startIndex, Direction direction) {\n        this.startIndex = startIndex;\n        this.direction = direction;\n    }\n\n    @Override\n    public boolean canMove(Board board, Position source, Position target) {\n        Direction direction = Direction.of(source, target);\n        double distance = source.calculateDistance(target);\n\n        return this.direction == direction\n                && (canMoveTwoPosition(board, distance, source) || canMoveOnePosition(board, distance, source));\n    }\n\n    private boolean canMoveTwoPosition(Board board, double distance, Position source) {\n        Position currentPosition = source.add(direction);\n        Piece currentPiece = board.findPiece(currentPosition);\n\n        currentPosition = currentPosition.add(direction);\n        Piece targetPiece = board.findPiece(currentPosition);\n\n        return source.getRankIndex() == startIndex\n                && distance == 4\n                && currentPiece.isEmpty()\n                && targetPiece.isEmpty();\n    }\n\n    private boolean canMoveOnePosition(Board board, double distance, Position source) {\n        Piece targetPosition = board.findPiece(source.add(direction));\n\n        return source.getRankIndex() == startIndex\n                && distance == 1\n                && targetPosition.isEmpty();\n    }\n}\n```\n\n### Pawn은 기본적으로 1칸 이동이 가능하다.\n\n```java\npublic class PawnDefaultMovingStrategy implements MovingStrategy {\n\n    private final Direction direction;\n\n    public PawnDefaultMovingStrategy(Direction direction) {\n        this.direction = direction;\n    }\n\n    @Override\n    public boolean canMove(Board board, Position source, Position target) {\n        Direction direction = Direction.of(source, target);\n        double distance = Math.sqrt(source.calculateDistance(target));\n\n        return this.direction == direction && canMoveOnePosition(board, distance, source);\n    }\n\n    private boolean canMoveOnePosition(Board board, double distance, Position source) {\n        Piece targetPosition = board.findPiece(source.add(direction));\n        return distance == 1 && targetPosition.isEmpty();\n    }\n}\n```\n\n### Pawn은 캡처할 때 대각선 방향이어야 한다.\n\n```java\npublic class PawnCaptureMovingStrategy implements MovingStrategy {\n\n    private final List<Direction> directions;\n\n    public PawnCaptureMovingStrategy(List<Direction> directions) {\n        this.directions = directions;\n    }\n\n    @Override\n    public boolean canMove(Board board, Position source, Position target) {\n        Direction direction = Direction.of(source, target);\n\n        return directions.contains(direction)\n                && source.calculateDistance(target) == 2\n                && isCapture(board, source, target);\n    }\n\n    private boolean isCapture(Board board, Position source, Position target) {\n        Piece sourcePiece = board.findPiece(source);\n        Piece targetPiece = board.findPiece(target);\n\n        return !targetPiece.isEmpty() && !sourcePiece.isSameColor(targetPiece);\n    }\n}\n```\n\n확실히 작은 문제로 접근하고 나니 훨씬 가독성있게 느껴졌다. 이제 해당 전략들을 사용하는 `Pawn`이다.\n\n```java\npublic class Pawn extends Piece {\n    ...\n    private final List<MovingStrategy> movingStrategies;\n\n    @Override\n    public void validateMove(Board board, Position source, Position target) {\n        boolean canMove = movingStrategies.stream()\n                .anyMatch(pawnMovingStrategy -> pawnMovingStrategy.canMove(board, source, target));\n\n        if (!canMove) {\n            throw new IllegalArgumentException();\n        }\n    }\n}\n```\n\n핵심은 `anyMatch`이다. 주입된 전략들을 통해 하나라도 이동이 가능하면 예외를 던지지 않고 통과한다.\n\n## References\n\n[널 오브젝트 패턴 (Null Object Pattern)](https://johngrib.github.io/wiki/pattern/null-object/)\n"},{"excerpt":"목표  우아한테크코스에서 진행한 미션의 리뷰와 피드백에 대해 정리한다. 실제 리뷰는 [1단계 - 블랙잭] 매트(최기현) 미션 제출합니다.에서 확인할 수 있다. 06. 2단계 - 블랙잭(베팅) 리뷰 확인 System.lineSeparator() 리뷰 중 일부 은 부터 제공되며 프로그램이 실행되는 OS에 따라 적합한 개행 문자를 리턴해주는 것을 확인했다. J…","fields":{"slug":"/java-blackjack-step2/"},"frontmatter":{"date":"March 21, 2022","title":"[레벨 1] 06. 2단계 - 블랙잭(베팅)","tags":["우아한테크코스","레벨1","미션"]},"rawMarkdownBody":"\n## 목표\n\n![](https://user-images.githubusercontent.com/59357153/152970395-a31c8134-fc89-449f-b4dc-441e03df929c.png)\n\n우아한테크코스에서 진행한 미션의 리뷰와 피드백에 대해 정리한다. 실제 리뷰는 [[1단계 - 블랙잭] 매트(최기현) 미션 제출합니다.](https://github.com/woowacourse/java-blackjack/pull/237)에서 확인할 수 있다.\n\n## 06. 2단계 - 블랙잭(베팅) 리뷰 확인\n\n## System.lineSeparator()\n\n#### 리뷰 중 일부\n```markdown\n`럿고`: `System.lineSeparator()` 이걸 한번 알아보면 어떠신가요?\n```\n\n`System.lineSeparator()`은 `JDK 1.7`부터 제공되며 프로그램이 실행되는 OS에 따라 적합한 개행 문자를 리턴해주는 것을 확인했다. Java에서 이러한 메서드를 제공하는 이유는 윈도우`(\\r\\n)`, 맥`(\\r)`, 유닉스`(\\n)`과 같은 운영체제 별로 개행문자를 다르게 해석하기 때문이라고 생각된다.\n\n더 나아가 자동으로 개행을 작성해주는 `System.out.println()` 메서드의 내부도 살펴보았다. 내부 로직을 따라가다 보면 `newLine` 부분에서 `System.lineSeparator()`을 활용하여 줄바꿈을 진행하는 것을 확인했다.\n\n```java\npublic class PrintStream extends FilterOutputStream\n    implements Appendable, Closeable\n{\n    ...\n    public void println(String x) {\n        synchronized (this) {\n            print(x);\n            newLine(); // <- 클릭\n        }\n    }\n    ...\n}\n```\n\n```java\npublic class PrintStream extends FilterOutputStream\n    implements Appendable, Closeable\n{\n    ...\n    private void newLine() {\n        try {\n            synchronized (this) {\n                ensureOpen();\n                textOut.newLine(); // <- 클릭\n                textOut.flushBuffer();\n                charOut.flushBuffer();\n                if (autoFlush)\n                    out.flush();\n            }\n        }\n        catch (InterruptedIOException x) {\n            Thread.currentThread().interrupt();\n        }\n        catch (IOException x) {\n            trouble = true;\n        }\n    }\n    ...\n}\n```\n\n```java\npublic class BufferedWriter extends Writer {\n    ...\n    public void newLine() throws IOException {\n        write(System.lineSeparator()); // 사용되는 것을 확인\n    }\n    ...\n}\n```\n\n## findFirst() vs findAny()\n\n#### 리뷰 중 일부\n```markdown\n`럿고`: findFirst()가 더 맞지 않을까요?\n```\n\nStream에서 어떤 조건에 일치하는 요소를 1개 찾을 때 `findFirst()`, `findAny()`와 같은 API를 사용할 수 있다. 가장 큰 차이는 `병렬 처리`할 때 이다.\n\n### findFirst()\n\n`findFirst()`는 여러 요소가 조건에 부합해도 Stream의 순서를 고려하여 가장 처음 부합하는 요소를 리턴한다.\n\n### findAny()\n\n`findAny()`는 멀티스레드에서 Stream을 처리할 때 가장 먼저 찾는 요소를 리턴한다. 즉 Stream의 순서를 고려하지 않는다.\n\n## BigDecimal을 사용한 BettingMoney\n\n#### 리뷰 중 일부\n```markdown\n`럿고`: BigDecimal을 선택하신 이유가 있나요?\n\n`매트`: 배팅 머니라서 돈이라는 도메인을 다루기 위해 BigDecimal을 사용하였습니다. Java에서 실수는 기본적으로 `부동 소수점 방식`을 활용하기 때문에 `연산 시 정확한 답을 보장하지 않는다`고 학습한 경험이 있습니다. 다양한 승리 조건에 따라 1.5, 1, 0 등을 곱해야 하기 때문에 단순히 double로 연산하게 될 경우 소중한 돈이 변경될 것을 우려하여 BigDecimal을 사용하였습니다! \n\n`럿고`: 좋은 근거입니다~ 👍\n```\n\n이전 미션에서 금액을 다루는 도메인에 대한 리뷰를 진행할 때 `BigDecimal`에 대한 키워드들을 들을 수 있었다. 이번 미션에서도 비슷하게 베팅 머니인 돈과 관련된 도메인이 등장하게 되었고 이전에 학습한 것을 기반으로 적용하게 되었다.\n\n```java\npublic class BettingMoney {\n\n    private static final int MONEY_SCALE = 0;\n    private static final int MONEY_LENGTH = 4;\n    private static final String MONEY_DIVIDE_STANDARD = \"000\";\n\n    public static final BettingMoney ZERO = new BettingMoney(BigDecimal.ZERO);\n\n    private final BigDecimal amount;\n\n    private BettingMoney(BigDecimal bigDecimal) {\n        this.amount = bigDecimal.setScale(MONEY_SCALE, RoundingMode.FLOOR);\n    }\n\n    public static BettingMoney of(String amount) {\n        validateLength(amount);\n        validateDivide(amount);\n        return new BettingMoney(new BigDecimal(amount));\n    }\n\n    private static void validateLength(String amount) {\n        if (amount.length() < MONEY_LENGTH) {\n            throw new IllegalArgumentException(\"배팅 금액은 1000원 이상입니다.\");\n        }\n    }\n\n    private static void validateDivide(String amount) {\n        if (!amount.endsWith(MONEY_DIVIDE_STANDARD)) {\n            throw new IllegalArgumentException(\"배팅 금액은 1000으로 나누어 떨어져야 합니다.\");\n        }\n    }\n\n    public BettingMoney times(double percent) {\n        BigDecimal multiplied = BigDecimal.valueOf(percent);\n        BigDecimal result = amount.multiply(multiplied);\n        return new BettingMoney(result);\n    }\n\n    public BettingMoney add(BettingMoney otherBettingMoney) {\n        BigDecimal add = amount.add(otherBettingMoney.amount);\n        return new BettingMoney(add);\n    }\n\n    public String getAmount() {\n        return amount.toString();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || getClass() != o.getClass()) {\n            return false;\n        }\n        BettingMoney that = (BettingMoney) o;\n        return Objects.equals(amount.toString(), that.amount.toString());\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(amount);\n    }\n}\n```\n\n기본적으로 VO로 동작하도록 값이 변하는 연산에는 새롭게 생성하여 반환 처리하였다. 또한 초기 `BettingMoney` 세팅 시 `1000이상이고 1000으로 나누어 떨어지는 상황`을 연출하기 위해 추가적인 검증을 진행하였다. 이러한 생성은 정적 팩토리 메서드 활용 하였다.\n\n정적 팩토리 메서드를 사용한 이유는 외부에서 생성될 때만 해당 검증을 진행하기 위해서이다. 객체 내부에서 사용할 때 해당 검증을 적용할 필요가 없기 때문에 검증을 분리하는 식으로 구현 하였다. 또한 자주 사용 되는 `ZERO`를 상수로 선언하여 이익 계산을 할 때 초기값으로 활용할 수 있도록 작성하였다.\n\n## 객체도 상수가 될 수 있다.\n\n#### 리뷰 중 일부\n```markdown\n`럿고`: `new Name(\"딜러\");` 자체를 상수로 관리해도 될듯 한데, 혹시 어떻게 생각하실까요?\n```\n\n각 참가자는 이름을 가지고 있다. 이러한 이름은 게임 시작과 동시에 입력된다. 하지만 딜러의 이름은 게임 시작과 동시에 `딜러`로 고정된다. 이러한 딜러는 게임 내내 변하지 않기 때문에 문자열 상수로 처리하였다. 하지만 현재 문자열 이름은 원시값 포장되어 Name 객체로 관리되고 있다. 즉 Name 객체 자체를 상수로 가지고 있어도 무방하다는 것이다. 사소한 차이이지만 다양한 시선에서 생각하는 방법을 확인할 수 있었다.\n\n## 상태 패턴\n\n수업 시간 중에 블랙잭 피드백을 진행했다. 해당 수업에서는 상태 패턴에 관한 내용을 다뤘고 이것을 간단히 학습한 뒤 이번 미션에 적용하였다. 아래는 상태 패턴에 대해 간단히 정리한 것이다.\n\n#### 상태 패턴\n```\n상태 패턴은 특정 기능을 수행한 뒤 다음 상태를 반환하는 것이다. 동일한 메서드가 상태에 따라 다르게 동작할 수 있도록 별도의 하위 타입으로 구현한다. 같은 기능을 단순히 조건문을 활용할 경우 상태가 추가될 때마다 조건문도 함께 추가된다. 하지만 상태 패턴을 사용하게 될 경우 코드의 복잡도가 증가하지 않고 상태를 추가할 수 있다.\n```\n\n아래는 이번 미션에 실제 적용한 상태 패턴이다. 가지고 있는 카드의 점수를 기반으로 현재 상태를 판단하여 다음 상태를 반환하는 방식으로 구현했다.\n\n### State Interface\n\n필요한 공통 상태를 선언한 인터페이스입니다. 구현할 상태에 변화를 줄 기능을 추상화한다.\n\n```java\npublic interface State {\n\n    State draw(Card card);\n\n    State stay();\n\n    boolean isRunning();\n\n    boolean isFinished();\n\n    Cards cards();\n\n    double earningRate(State state);\n}\n```\n\n해당 인터페이스를 기반으로 적절한 상태를 하위 클래스로 만들어 구현 했다. 상태 패턴을 적용한 클래스들의 다이어그램은 아래와 같다.\n\n![](https://user-images.githubusercontent.com/59357153/159109492-3677601f-6009-4abd-8d8a-cd13684426ef.png)\n\n모든 상태의 시작이 Ready가 될 수 있도록 나머지 상태는 protected로 외부 생성을 제한하였다.\n\n```java\npublic class Blackjack extends Finished {\n\n    protected Blackjack(Cards cards) {\n        super(cards);\n    }\n    ...\n}\n```\n\n또한 중간에 공통 상태(Finished)를 추상 클래스로 묶어 공통적인 행위들을 final로 지정하여 상속 받은 하위 타입이 다시 오버라이딩 할 수 없도록 제한하였다.\n\n```java\npublic abstract class Finished extends Started {\n\n    protected static final double BLACKJACK_WIN_RATE = 1.5;\n    protected static final int WIN_RATE = 1;\n    protected static final int TIE_RATE = 0;\n    protected static final int LOW_RATE = -1;\n\n    protected Finished(Cards cards) {\n        super(cards);\n    }\n\n    @Override\n    public final State draw(Card card) {\n        throw new IllegalStateException(\"카드를 뽑을 수 없는 상태입니다.\");\n    }\n\n    @Override\n    public final State stay() {\n        throw new IllegalStateException(\"스테이 상태로 변경할 수 없습니다.\");\n    }\n\n    @Override\n    public final boolean isRunning() {\n        return false;\n    }\n\n    @Override\n    public final boolean isFinished() {\n        return true;\n    }\n}\n```\n\n## Collections.emptyList() vs new List Instance\n\n#### 리뷰 중 일부\n```markdown\n`럿고`: `this(Collections.emptyList());` 이런식으로 작성이 불가능 할까요?\n```\n\n`Collections.emptyList()`와 `new ArrayList<>()`의 핵심 차이점은 불변성이다. `Collections.emptyList()`는 수정할 수 없는 목록을 반환한다. 또한 이름에서 비어있는 리스트를 표현하고 있기 때문에 의도를 잘 표현하고 있다. 즉 더 좋은 가독성을 가지고 있다.\n\n## References\n\n * [Java Stream - findAny()와 findFirst()의 차이점](https://codechacha.com/ko/java8-stream-difference-findany-findfirst/)\n * [상태 패턴(State Pattern)을 사용해보자](https://tecoble.techcourse.co.kr/post/2021-04-26-state-pattern/)\n * [Collections.emptyList() vs. New List Instance](https://www.baeldung.com/java-collections-emptylist-new-list)\n"},{"excerpt":"목표  우아한테크코스에서 진행한 미션의 리뷰와 피드백에 대해 정리한다. 실제 리뷰는 [1단계 - 블랙잭] 매트(최기현) 미션 제출합니다.에서 확인할 수 있다. 상속을 활용한 추상화 이전까지 미션을 진행하며 이른 시기의 추상화(ex. 필요에 의해 도입하지 않고 예측을 통한 전략 패턴 도입)로 인한 코드 수정을 야기한 경험이 있었기 때문에 이번 미션에서는 최…","fields":{"slug":"/java-blackjack-step1/"},"frontmatter":{"date":"March 17, 2022","title":"[레벨 1] 05. 1단계 - 블랙잭","tags":["우아한테크코스","레벨1","미션"]},"rawMarkdownBody":"\n## 목표\n\n![](https://user-images.githubusercontent.com/59357153/152970395-a31c8134-fc89-449f-b4dc-441e03df929c.png)\n\n우아한테크코스에서 진행한 미션의 리뷰와 피드백에 대해 정리한다. 실제 리뷰는 [[1단계 - 블랙잭] 매트(최기현) 미션 제출합니다.](https://github.com/woowacourse/java-blackjack/pull/237)에서 확인할 수 있다.\n\n## 상속을 활용한 추상화\n\n이전까지 미션을 진행하며 이른 시기의 추상화(ex. 필요에 의해 도입하지 않고 예측을 통한 전략 패턴 도입)로 인한 코드 수정을 야기한 경험이 있었기 때문에 이번 미션에서는 최대한 추상화 과정을 미뤄서 작성하였다. 이번 미션에서도 블랙잭 게임의 참가자인 Dealer와 Player도 공통된 행위가 많다고 판단하였고 공통된 코드를 상속을 통한 추상화를 고려하였다.\n\n하지만 상속 구조는 코드를 재사용 하기 용이하지만 상위 클래스와의 높은 결합도를 가지기 때문에 조합을 먼저 고려해야 한다고 학습한 경험이 있다. 또한 위 예시가 상속을 도입하는데 충분한 배경을 가지고 있는지 아직 판단이 잘 서지 않았다. 리뷰어 럿고는 이러한 고민에 아래와 같은 답변을 남겨 주었다.\n\n#### 리뷰 중 일부\n```markdown\n`럿고`: 안녕하세요 🙂 상속에 대한 질문을 남겨주셨는데, 답변 전에 상속을 먼저 해보라고 말씀드린 이유를 설명드릴려고 해요 🙂\n저의 근거는 사실 별건 아닌데요. 한번 직접 해보고 판단하자 라는 근거입니다 🙂\n사실 설계를 할때, 많은 고민을 하게 되는데요. 사실 그건 저도 똑같습니다. 그러나, 해보지 않고 판단하면 놓치게 되는 경우가 많더라구요.\n이미 설계할때 고민을 해보셨겠지만, 미션에 직접적으로 반영을 하지 않았다고 생각이 들어요.\n이펙티브자바에서도 나오다 보니 상속보다 조합 이라는 개념을 많이 접해보셨겠지만, 그렇다고 해서 무조건 조합을 사용하라는 이야기는 아닙니다.\n객체지향에서 중요한 개념중 하나가 다형성이라고 생각이 드는데요. 다형성의 이점을 얻기 위한 방법은 여러가지겠지만, 좋은 방법 중 하나는 상속입니다. 이러한 근거로 한번 직접 적용해보라고 리뷰를 드린것이니 참고해주시면 감사하겠습니다 🙂\n```\n\n정리하면 `해보지 않고 판단하는 것 보다 상속을 적용하여 경험해 본 뒤 필요에 따라 조합을 고려해보는 것을 추천`한다는 것이다. \n\n해당 피드백을 받고 많은 생각이 들었다. 언급한 것처럼 상속에 대한 문제는 다양한 책을 통해 접했지만 실제로 상속을 사용하며 경험해본 적은 없기 때문이다. 왜 사용하면 안되는지 의심하지 않은 채 책에서 조합을 먼저 고려하라는 말로 나는 상속을 체험해볼 좋은 기회를 놓치게 되었다.\n\n우아한테크코스는 `best practice`를 찾는 과정이 아니다. 위 같이 `다양한 도전`과 `시행착오`를 통해 성장해야 한다. 상속도 마찬가지다. 단순히 조합을 먼저 고려하라는 가르침 때문에 상속을 경험 해보지도 못한 채 조합을 먼저 고려하였을 것이다. 직접 경험하는 것 만큼 와닿는 방식도 없다. 바로 상속을 적용하여 중복된 코드를 개선하였다.\n\n우선 공통된 부분을 추출하여 상위 클래스에 위치 시켰다.\n\n```java\npublic abstract class Participant {\n\n    protected static final int BLACKJACK_SCORE = 21;\n\n    protected final Name name;\n    protected final Cards cards;\n\n    public Participant(String name, List<Card> cards) {\n        this.name = new Name(name);\n        this.cards = new Cards(cards);\n    }\n\n    public int getTotalScore() {\n        return cards.calculateTotalScore();\n    }\n\n    public void append(Card card) {\n        cards.append(card);\n    }\n\n    protected boolean isBust() {\n        return cards.calculateTotalScore() > BLACKJACK_SCORE;\n    }\n\n    public abstract boolean isDrawable();\n\n    public abstract GameResult decideResult(Participant participant);\n\n    public String getName() {\n        return name.getValue();\n    }\n\n    public List<Card> getCards() {\n        return cards.getValue();\n    }\n}\n```\n\n공통 부분을 제외한 변하는 부분은 abstract 키워드를 통해 `정제(refine)`할 수 있도록 작성하였다.\n\n#### 상속이 적절한 경우\n\n상속이 더욱 적절한 경우는 클래스의 행동을 `확장(extend)`하는 것이 아니라 `정제(refine)`할 때이다. 확장이란 새로운 행동을 덧 붙여 기존의 행동을 부분적으로 보완하는 것을 의미하고 정제란 부분적으로 불 완전한 행동을 완전하게 만드는 것을 의미한다.\n\n아래는 추상 클래스 Participant를 상속 받는 Player와 Dealer이다.\n\n```java\npublic class Player extends Participant {\n\n    public Player(String name, List<Card> cards) {\n        super(name, cards);\n    }\n\n    @Override\n    public boolean isDrawable() {\n        return cards.calculateTotalScore() <= BLACKJACK_SCORE;\n    }\n\n    @Override\n    public GameResult decideResult(Participant participant) {\n        if (isBust()) {\n            return GameResult.LOSE;\n        }\n\n        if (participant.isBust()) {\n            return GameResult.WIN;\n        }\n\n        return GameResult.of(getTotalScore(), participant.getTotalScore());\n    }\n}\n```\n\n```java\npublic class Dealer extends Participant {\n\n    private static final String DEALER_NAME = \"딜러\";\n    private static final int DRAWABLE_LIMIT_VALUE = 16;\n\n    public Dealer(List<Card> cards) {\n        super(DEALER_NAME, cards);\n    }\n\n    @Override\n    public boolean isDrawable() {\n        return cards.calculateTotalScore() <= DRAWABLE_LIMIT_VALUE;\n    }\n\n    @Override\n    public GameResult decideResult(Participant participant) {\n        if (participant.isBust()) {\n            return GameResult.WIN;\n        }\n\n        if (isBust()) {\n            return GameResult.LOSE;\n        }\n\n        return GameResult.of(getTotalScore(), participant.getTotalScore());\n    }\n}\n```\n\n## ArgumentsProvider를 통한 테스트 데이터\n\nJUnit `@ParameterizedTest`을 통해 다양한 데이터를 통해 반복적인 테스트를 진행할 수 있다. 또한 다양한 애노테이션과 함께 다양한 타입의 데이터를 활용하여 테스트를 진행할 수 있다. 그 중 직접 사용한 애노테이션을 간단히 정리하였다.\n\n* `@MethodSource`: 테스트 클래스 내의 메서드 혹은 외부 클래스 메서드가 반환하는 값을 source로 사용한다. static 메서드여야 하고 애노테이션에 해당 메서드명을 작성해야 한다.\n\n아래 처럼 작성 가능하다.\n```java\npublic class CardsTest {\n    ...\n    private static Stream<Arguments> provideArguments() {\n        return Stream.of(\n                arguments(new Cards(List.of(new Card(NINE, CLOVER), new Card(EIGHT, DIAMOND))), 17),\n                arguments(new Cards(List.of(new Card(KING, SPADE), new Card(ACE, CLOVER))), 21),\n                arguments(new Cards(List.of(new Card(SEVEN, CLOVER), new Card(KING, SPADE))), 17),\n                arguments(new Cards(List.of(new Card(ACE, CLOVER), new Card(ACE, SPADE))), 12),\n                arguments(new Cards(List.of(new Card(ACE, CLOVER), new Card(KING, SPADE))), 21),\n                arguments(new Cards(List.of(new Card(ACE, CLOVER), new Card(THREE, HEART))), 14)\n        );\n    }\n\n    @DisplayName(\"Cards가 주어지면 점수를 계산하면 반환한다.\")\n    @ParameterizedTest\n    @MethodSource(\"provideArguments\")\n    void 카드_점수_계산(Cards cards, int totalScore) {\n        assertThat(cards.calculateTotalScore()).isEqualTo(totalScore);\n    }\n}\n```\n\n만약 `이름을 전달하지 않을 경우 테스트 메서드와 이름이 같은 소스 메서드`를 검색한다. 또한 패키지 명을 포함하여 작성하는 경우 외부 클래스에 선언된 메서드를 참조할 수 있다.\n\n하지만 문자열로 메서드명을 전달하거나 작성하지 않는 경우 검색을 통해 메서드를 탐색하기 때문에 해당 메서드가 존재하지 않거나 오타로 작성하게 되면 테스트를 실행하는 시점에 예외를 던지게 된다. 즉 컴파일 시점에 해당 오류를 찾을 수 없다는 단점이 있다.\n\n* `@ArgumentsSource`: ArgumentProvider라는 인터페이스를 구현한 구현체를 사용한다.\n\n```java\npublic class CardsArgumentsProvider implements ArgumentsProvider {\n\n    @Override\n    public Stream<? extends Arguments> provideArguments(ExtensionContext context) {\n        return Stream.of(\n                arguments(new Cards(List.of(new Card(NINE, CLOVER), new Card(EIGHT, DIAMOND))), 17),\n                arguments(new Cards(List.of(new Card(KING, SPADE), new Card(ACE, CLOVER))), 21),\n                arguments(new Cards(List.of(new Card(SEVEN, CLOVER), new Card(KING, SPADE))), 17),\n                arguments(new Cards(List.of(new Card(ACE, CLOVER), new Card(ACE, SPADE))), 12),\n                arguments(new Cards(List.of(new Card(ACE, CLOVER), new Card(KING, SPADE))), 21),\n                arguments(new Cards(List.of(new Card(ACE, CLOVER), new Card(THREE, HEART))), 14)\n        );\n    }\n}\n```\n\n```java\npublic class CardsTest {\n    ...\n    @DisplayName(\"Cards가 주어지면 점수를 계산하면 반환한다.\")\n    @ParameterizedTest\n    @ArgumentsSource(CardsArgumentsProvider.class)\n    void 카드_점수_계산(Cards cards, int totalScore) {\n        assertThat(cards.calculateTotalScore()).isEqualTo(totalScore);\n    }\n}\n```\n\n`@MethodSource`와 동일한 기능을 제공한다. 외부에서 테스트를 위한 데이터를 관리하기 때문에 좀 더 직관적으로 관리가 가능하다. 또한 클래스를 전달하기 때문에 컴파일 시점에 존재 유무에 관한 오류들을 확인할 수 있다. 재사용 측면에서도 손쉽게 적용이 가능하다.\n\n관련 이점들을 확인하였고 이번 미션을 진행하며 공통적으로 필요한 테스트 데이터들 중 반복적으로 사용하는 것들은 `ArgumentsProvider`를 구현하여 적절히 사용하였다.\n\n## dto가 필요한 규모의 시스템인가?\n\n`dto`는 `Data Transfer Object`로 데이터 전달을 위한 객체이다. `계층간 데이터를 주고 받을 때` 데이터를 전달하는 바구니로 사용된다. 보통 dto는 Controller에서 Domain과 관련된 데이터를 가공하여 View에게 전달할 때 사용하였다. 이번에도 Domain과 View에 대한 결합도를 줄이기 위해 중간에 dto를 두어 작성하였다.\n\n하지만 아래와 같은 리뷰를 확인할 수 있었다.\n\n#### 리뷰 중 일부\n```markdown\n`구구`: dto가 필요한 규모의 시스템인가요?\ndto를 추가하면서 이를 처리하기 위한 메서드가 생겨나는군요.\n오히려 코드 복잡도를 높이고 있지 않나요?\n```\n\n사실 이번 블랙잭 미션의 경우 MVC 중 C에 해당하는 Controller 계층을 사용하지 않아도 될 정도로 작은 규모의 애플리케이션이다. 나는 그것을 고려하지 않은 채 무작정 Controller 부터 만들고 dto를 양산하고 있었다. 그로 인해 dto 변환을 위한 부가적인 코드까지 추가되었다. 해당 리뷰를 받고 난 뒤 dto가 필요한 규모의 시스템에 대해 고민하게 되었다.\n\n우선 dto의 목적에 대해 생각해봐야 한다. dto는 `계층간 데이터를 주고 받을 때` domain에 대한 중요한 정보를 숨기거나 view에서 필요로 하는 데이터를 가공할 때 사용한다. 또한 view의 요구사항은 domain에 비하여 자주 변경된다. 만약 view에서 domain에 대한 의존성을 가지고 있는 경우 view의 수정은 domain에 대한 수정을 야기할 수 있다. \n\n블랙잭 미션은 사실 계층을 나눌 만큼 큰 규모의 애플리케이션이 아니다. 특히 DB와 같은 데이터 저장소를 사용하지 않기 때문에 더더욱 Controller의 역할이 모호해진다. 이런 경우 단순히 domain만 활용하여 작성해도 괜찮을 것이라 판단한다. 한 가지 주의해야 할 점은 view에서 domain의 비즈니스 로직을 실행하는 것은 지양해야 한다는 것이다. 중요한 비즈니스 로직이 담긴 메서드를 실행할 경우 view와 domain이 강하게 결합되며 변화에 매우 취약한 구조를 야기한다. view에서는 최대한 domain에 getter를 통해 데이터를 받아서 사용해야 한다.\n\n아직은 나의 주관보다 리뷰로 오는 피드백이 내 코드에 많은 영향을 끼치고 있다. 레벨 1 기간 동안은 코드의 근거를 만드는 것과 나의 소신을 만드는 것도 중요하지만 리뷰어들의 다양한 시선을 통해 오는 피드백을 `이해하고 수용하는 것`도 중요하다고 생각한다. 아직은 배우는 입장이기 때문에 리뷰를 보고 단순히 넘기는 것 보다 `의도를 파악하고 이해하며 내것으로 만든 뒤 적절히 응용`하는 방법도 필요하다고 생각한다.\n\n## References\n\n * [Guide to JUnit 5 Parameterized Tests](https://www.baeldung.com/parameterized-tests-junit-5)\n * [DTO vs VO vs Entity](https://tecoble.techcourse.co.kr/post/2021-05-16-dto-vs-vo-vs-entity/)\n"},{"excerpt":"목표  우아한테크코스에서 진행한 미션의 리뷰와 피드백에 대해 정리한다. 실제 리뷰는 [2단계 - 로또(수동)] 매트(최기현) 미션 제출합니다.에서 확인할 수 있다. 추가된 요구사항 이전 로또 생성기는 자동 기능만 제공한다. 사용자가 수동으로 추첨 번호를 입력할 수 있도록 해야 한다.  수동으로 구매할 로또 수를 입력한다. 수동으로 구매할 번호를 입력한다.…","fields":{"slug":"/java-lotto-step2/"},"frontmatter":{"date":"March 06, 2022","title":"[레벨 1] 04. 2단계 - 로또(수동)","tags":["우아한테크코스","레벨1","미션"]},"rawMarkdownBody":"\n## 목표\n\n![](https://user-images.githubusercontent.com/59357153/152970395-a31c8134-fc89-449f-b4dc-441e03df929c.png)\n\n우아한테크코스에서 진행한 미션의 리뷰와 피드백에 대해 정리한다. 실제 리뷰는 [[2단계 - 로또(수동)] 매트(최기현) 미션 제출합니다.](https://github.com/woowacourse/java-lotto/pull/429)에서 확인할 수 있다.\n\n## 추가된 요구사항\n\n이전 로또 생성기는 자동 기능만 제공한다. 사용자가 수동으로 추첨 번호를 입력할 수 있도록 해야 한다. \n\n * 수동으로 구매할 로또 수를 입력한다.\n * 수동으로 구매할 번호를 입력한다.\n * 수동을 제외한 나머지는 자동으로 구매한다.\n\n## 수동 기능 구현\n\n최초 로또 생성을 위한 전략을 외부에서 주입 받는 방식으로 작성하였다.\n\n아래는 이전 코드의 생성 전략이다.\n```java\n@FunctionalInterface\npublic interface LottoNumberGenerator {\n    List<Integer> generate(int size);\n}\n```\n\n위 방식을 유지하며 수동 방식을 추가하려 했다. 하지만 기존에 작성한 전략을 수정하지 않고 수동 전략을 고려하는 것은 매우 힘들게 다가왔다. 임시방편으로 LottoTickets에 다양한 정적 팩토리 메서드를 두어 해결하려 했다.\n\n```java\npublic class LottoTickets {\n    ...\n    public static LottoTickets createAutoLottoTickets(int lottoCount, LottoNumberGenerator lottoNumberGenerator) {\n        return new LottoTickets(lottoCount, lottoNumberGenerator);\n    }\n\n    public static LottoTickets createManualLottoTickets(List<List<Integer>> manualNumbers) {\n        List<LottoTicket> lottoTickets = manualNumbers.stream()\n                .map(LottoTicket::new)\n                .collect(toList());\n\n        return new LottoTickets(lottoTickets);\n    }\n    ...\n}\n```\n\n하지만 이것은 오히려 복잡성을 야기하는 것 같았다. 해당 코드를 사용하는 입장에서 전혀 직관적이지 않다고 느껴졌다. 로운 역시 좋지 않다는 의견을 내게 전달하였다.\n\n#### 리뷰 중 일부\n```markdown\n`로운`: 자동의 경우 LottoNumberGenerator를 사용하는데 수동의 경우에도 사용하도록 해야 전략패턴으로 사용하는 의미가 있지 않을까요??\n그리고 정적 팩토리 메서드의 경우에는 매개변수 생성자를 1개 만들어 놓고 그 1개를 사용하는 방식으로 많이 사용합니다~\n위와 같이 되면 매개변수 생성자도 늘어나고, 정적팩토리 메서드도 늘어나겠죠??\n```\n\n전략 패턴 사용에 대해서 다시 한 번 고민해보았다. 현재 구조에서는 로또 생성 부분을 전략으로 가지는게 맞는지 전체적인 그림을 다시 그려보며 차근차근 코드를 수정 하였다.\n\n기존 로직은 수동을 전혀 고려하지 않고 로또 번호를 생성하였다. 즉 메서드의 시그니처가 수동 생성과는 맞지 않다고 판단했다. 그렇기 때문에 기존 로직을 과감히 삭제하고 생성자를 간결히 만들어 유연하게 대처할 수 있도록 통일하였다.\n\n```java\npublic class LottoTickets {\n\n    private final List<LottoTicket> lottoTickets;\n\n    public LottoTickets(List<List<Integer>> manualNumbers) {\n        this.lottoTickets = manualNumbers.stream()\n                .map(LottoTicket::new)\n                .collect(toList());\n    }\n\n    public void combine(LottoTickets targetLottoTickets) {\n        lottoTickets.addAll(targetLottoTickets.lottoTickets);\n    }\n\n    public LottoResult determine(WinningNumber winningNumber) {\n        Map<Rank, Long> ranks = lottoTickets.stream()\n                .map(winningNumber::compare)\n                .collect(groupingBy(identity(), counting()));\n\n        return new LottoResult(ranks);\n    }\n\n    public List<LottoTicket> getLottoTickets() {\n        return Collections.unmodifiableList(lottoTickets);\n    }\n}\n```\n\ngenerator를 과감히 삭제한 뒤 해당 로직을 LottoMachine으로 이동했다. 이전과 다르게 LottoTickets이 알고 있어야 하는 정보도 줄어 들고 정적 팩토리 메서드 사용을 고려하지 않아도 되는 구조로 개선되어 해당 객체의 역할이 좀 더 뚜렷해졌다고 생각된다.\n\n이에 대한 로운의 의견이었다.\n\n#### 리뷰 중 일부\n\n```markdown\n`로운`: lottoTicktets는 맞습니다! 다만 LottoTicket에서 하던 기능이 LottoGame으로 넘어갔는데요.\n저는 LottoNumberGenerator를 implement하는 AutoLottoNumberGenerator와 ManualLottoNumberGenerator를 만들어 사용하는 것을 생각했었습니다~\n\n고민해보시고 생각이 안나시면 다음 요청때 말씀해주세요ㅎㅎ\n제가 생각한 방법을 말씀드릴게요. 다음번에 머지할 예정이라 참고만 하시면 될거 같아요.\n오히려 제가 생각하는 방법이 복잡성을 높이고 오버 엔지니어링일 수 있어요.\n```\n\n해당 피드백을 듣고 많은 생각을 하게 되었다. 나는 보통 걱정이 많고 일어나지도 않은 일을 대비하는 성격을 가지고 있다. 이번 미션을 진행하며 일어나지도 않은 추가적인 요구사항에 대비하여 이른 시기에 전략 패턴을 도입했다. 하지만 이것은 오히려 변경하기 어려운 구조를 야기했고 결국 기존 코드를 대부분 수정하게 되었다.\n\n만약 단순히 생각하여 자동 번호를 만들어 외부에서 주입받는 지금의 형식을 유지했다면 해당 시그니처를 기반으로 전략을 설계했을 것이다. 점진적으로 코드가 리팩토링이 되지 못했다. 단순히 기존 코드를 억지로 유지하며 리팩토링 하려 했다. \n\n많은 도메인을 접하지 못한 경험도 있지만 너무 과도한 계획과 설계는 전략을 추상화 하는데 큰 방해가 될 뿐이다. 다음 미션을 진행할 땐 해당 문제를 최대한 담백하고 깔끔하게 바라보는 시선을 길러야 겠다.\n\n## 무분별한 DTO 사용\n\n앞서 언급한 것 처럼 나는 걱정이 많고 일어나지 않은 일에 대비하려 한다. 이것은 DTO를 설계할 때도 발목을 잡았다. 필요에 의해 만든 것이 아니라 너무 무분별하게 많은 DTO를 만든 것이다.\n\n#### 리뷰 중 일부\n```markdown\n`매트`: 이전 피드백을 기반으로 MVC 각각의 역할과 책임에 대해 학습할 수 있었습니다. 특히 controller에서는 dto를 활용한 값 전달로 view와의 결합도를 충분히 낮췄다고 생각됩니다. 다만 표현하고자 하는 값이 늘어날수록 dto의 개수가 늘어나서 다소 직관적 이지 않게 느껴지지 않을까 우려됩니다.\n\n`로운`: 말씀하신거처럼 dto가 계속 늘어날 수 있는데요. 관리가 힘들어지게 되지만 dto를 사용함으로써 얻는 점들이 많아 사용하고 있습니다.\n\n제가 공유드린 페이지에 있는 것들 이외에도 dto를 사용하는 이유에 대해 찾아보시면 좋을거 같아요!\n그리고 dto안에 dto가 생겨나는 것이나 불필요한 dto가 생겨난다고 생각되는 dto들은 Integer, String과 같이 원시값 형태로 넘길 수 없을지 고민해보는 것도 좋은 것 같습니다.\n```\n\n로운은 정확히 내가 고민하는 것을 짚어 주었다. `불필요한 dto가 생겨난다고 생각되는 dto들은 Integer, String과 같이 원시값 형태로 넘길 수 없을지 고민`하고 있던 차에 가려운 곳을 긁어 주었다. \n\n피드백 이후 과감하게 DTO를 삭제하였다! 이제 좀 더 직관적으로 해당 객체들의 역할을 확인할 수 있게 되었다.\n\n## 로또 번호를 재사용하라!\n\n나는 다른 크루의 코드를 구경하는 것을 좋아한다. 그 사람의 코드를 통해 다양한 시선을 기를 수 있고 더 좋은 설계와 코드 작성 방식을 배울 수 있다. 이번에도 알지 못했던 방식에 대해 알 수 있게 되었다.\n\nLottoNumber는 로또 번호 한 자리를 나타내기 위한 VO로 설계하였다. 즉 `new LottoNumber(1)`은 `new LottoNumber(1)`과 항상 동일하고 동등해야 한다. 즉 이러한 숫자 1 ~ 45는 불변을 보장하는 VO이기 때문에 재사용되어도 문제가 되지 않는다.\n\n즉 이말은 한 번만 생성해두고 재활용 가능하다는 이야기 이다.\n\n```java\npublic class LottoNumber {\n\n    private static final int START_NUMBER = 1;\n    private static final int END_NUMBER = 45;\n    private static final String NUMBER_RANGE_ERROR_MESSAGE = \"로또 번호의 범위는 1 ~ 45 사이입니다.\";\n    private static final Map<Integer, LottoNumber> LOTTO_NUMBERS = IntStream.rangeClosed(START_NUMBER, END_NUMBER)\n            .boxed()\n            .collect(toMap(identity(), LottoNumber::new));\n\n    private final int lottoNumber;\n\n    private LottoNumber(int lottoNumber) {\n        this.lottoNumber = lottoNumber;\n    }\n\n    public static LottoNumber from(int lottoNumber) {\n        if (!LOTTO_NUMBERS.containsKey(lottoNumber)) {\n            throw new IllegalArgumentException(NUMBER_RANGE_ERROR_MESSAGE);\n        }\n\n        return LOTTO_NUMBERS.get(lottoNumber);\n    }\n    ...\n}\n```\n\n위 코드에서 핵심은 `private static final Map<Integer, LottoNumber> LOTTO_NUMBERS`이 부분이다. 정적으로 생성하여 재사용되고 있다. Map을 활용하여 LottoNumber를 캐싱하였고, `from`을 통해 기존 객체를 꺼내 반환할 수 있도록 구현하였다.\n\n이제 로또 번호를 중복해서 생성하지 않고 기존 것을 재사용 하도록 개선하였다.\n\n## 공통 테스트 데이터 추출\n\n#### 리뷰 중 일부\n```markdown\n`로운`: 테스트를 위한 데이터가 계속 반복이 되는거 같은데요.\n이전에 말씀드린 공통적으로 사용하는 데이터를 활용하는 방법은 test에 util 혹은 다른객체나 LottoTicktesTest에 메서드를 만들어 사용되는 객체를 만들어두고 반환하도록 하는 형태로 사용하는 것을 말씀드렸던 겁니다~\n```\n\n테스트 패키지 하위에 공통적으로 사용할 수 있는 데이터나 메서드를 모아 클래스를 생성하여 개선하였다.\n\n```java\npublic class LottoTestDataGenerator {\n\n    public static List<List<LottoNumber>> generateLottoTickets() {\n        return List.of(\n                parseLottoNumbers(List.of(8, 21, 23, 41, 42, 43)),\n                parseLottoNumbers(List.of(3, 5, 11, 16, 32, 38)),\n                parseLottoNumbers(List.of(7, 11, 16, 35, 36, 44))\n        );\n    }\n\n    public static List<LottoNumber> generateNumbers() {\n        return parseLottoNumbers(List.of(8, 21, 23, 41, 42, 43));\n    }\n\n    public static List<LottoNumber> parseLottoNumbers(List<Integer> numbers) {\n        return numbers.stream()\n                .map(LottoNumber::from)\n                .collect(toList());\n    }\n}\n```\n\n## References\n\n[DTO의 사용 범위에 대하여](https://tecoble.techcourse.co.kr/post/2021-04-25-dto-layer-scope/)\n"},{"excerpt":"목표  우아한테크코스에서 진행한 미션의 리뷰와 피드백에 대해 정리한다. 실제 리뷰는 [1단계 - 로또(자동)] 매트(최기현) 미션 제출합니다.에서 확인할 수 있다. 미션을 대하는 자세 이번 로또 미션을 해결할 때 가장 크게 고려한 것은 하는 것과 이다. 객체에게 적절한 책임을 부여 객체에게 직관적인 메시지를 보내 자연스럽게 도메인 사이의 협력을 이룰 수 …","fields":{"slug":"/java-lotto-step1/"},"frontmatter":{"date":"February 28, 2022","title":"[레벨 1] 03. 1단계 - 로또(자동)","tags":["우아한테크코스","레벨1","미션"]},"rawMarkdownBody":"\n## 목표\n\n![](https://user-images.githubusercontent.com/59357153/152970395-a31c8134-fc89-449f-b4dc-441e03df929c.png)\n\n우아한테크코스에서 진행한 미션의 리뷰와 피드백에 대해 정리한다. 실제 리뷰는 [[1단계 - 로또(자동)] 매트(최기현) 미션 제출합니다.](https://github.com/woowacourse/java-lotto/pull/366)에서 확인할 수 있다.\n\n## 미션을 대하는 자세\n\n이번 로또 미션을 해결할 때 가장 크게 고려한 것은 `객체에게 적절한 책임을 부여`하는 것과 `의식적인 TDD 연습`이다.\n\n### 객체에게 적절한 책임을 부여\n\n객체에게 직관적인 메시지를 보내 자연스럽게 도메인 사이의 협력을 이룰 수 있도록 노력하였다. 초반 설계대로 대부분의 기능을 구현했지만 세부 구현을 진행할 때 마다 고려해야할 점들이 늘어나 그때 그때 필요한 것을 추가하며 살아 있는 문서가 될 수 있도록 작성하였다.\n\n미션을 진행하며 가장 크게 느낀 것은 초반 `설계에 대한 중요성`과 `요구사항과 도메인에 대한 충분한 배경지식의 필요성`이다. 무턱대고 개발부터 진행하게 되면 어떤 객체에게 책임을 부여해야 할지 알 수 없기 때문이다. \n\n이번 미션은 도메인에 대한 사전 지식을 어느정도 가지고 있다고 판단했지만 그럼에도 불구하고 쉽지 않은 작업이었다. 객체에게 유의미한 메시지 전달을 위해 메서드명을 정하는 것도 쉽지 않았다. 이번 미션을 통해 이러한 연습을 꾸준히 진행해볼 생각이다.\n\n### 의식적인 TDD\n\n테스트 주도 개발은 지속적으로 의식하지 않으면 쉽게 적용할 수 없다. 어떻게 보면 지금까지 하던 개발 방법을 완전히 뒤집어서 적용해야 하는데 아직 습관을 버리는 것은 쉽지 않았다. 그럼에도 의식적은 연습을 통해 극복하려 했지만 오랜시간 집중하는 것은 나에게 어려운 일이 었다. 우선 TDD를 유연하게 진행하려면 앞서 언급한 것 처럼 도메인에 대한 배경지식과 요구사항에 대한 이해도가 높아야 한다. 이러한 사실을 기반으로 각 객체의 책임을 검증하며 구현 코드를 채워가야 한다.\n\n유사한 TDD를 작성했지만 그럼에도 얻어가는 점은 많았다. 확실히 다수의 테스트 코드가 뒷받침되어 프로그램의 안정성을 확인시켜 주었다. 또한 정리한 요구사항을 기반으로 테스트를 진행했기 때문에 진행 상황도 빠르게 반영이 가능했다.\n\nTDD는 불안함을 귀찮음으로 바꿔준다고 한다. 아직은 귀찮음의 힘이 더 크게 작용하지만 의식적인 연습을 통해 극복 가능하다고 생각한다. \n\n## 과연 적절한 책임인가?\n\n미션을 진행할 때 실제 로또를 구매하는 상상을 하며 설계를 진행하였다. 보통 우리가 로또 구매를 위해서는 판매점에 방문한다. 자동으로 구매할 경우 로또 구입 금액을 지불하여 로또 번호 생성 기계에서 나오는 로또 티켓을 발급 받는다. 이것을 그림으로 표현했을 때 구입 과정은 아래와 같다고 생각했다.\n\n![](https://user-images.githubusercontent.com/59357153/155666634-33b8b9ac-dad1-4cbd-b2d9-9006c37b28a7.png)\n\n여기서 LottoMacine은 `로또 티켓 발급의 책임`을 가진다. 로또를 구매하는 클라이언트는 로또 머신에게 구매하기 위한 메시지를 요청한다. 이것을 기반으로 `LottoMacine`은 아래와 같이 작성되었다.\n\n```java\npublic class LottoMachine {\n\n    public LottoTickets purchase(Money money) {\n        return new LottoTickets(money.calculateTicketCount(), new AutoLottoNumberGenerator());\n    }\n}\n```\n\n단순히 구매하는 요청 메시지 처리를 위해 `purchase`라는 메서드명을 활용했다. 하지만 아래와 같은 피드백을 확인할 수 있었다.\n\n#### 리뷰 중 일부\n\n```markdown\n`로운`: 작업전 객체 책임 부여와 설계 너무 좋네요 💯\n\n객체의 메서드는 자기 자신이 어떠한 행동을 한다는 것을 보여주는 것일텐데요. (create, find, print, calculate 등)\n클라이언트 입장에서는 구매하는 것이 맞지만 LottoMachine입장에서는 자기가 로또를 구매하는 것이 맞는 의미인지 의문이 들었어요.\n\n로또 티켓 리스트를 자동으로 **발급받기 위한** 기계가 아닌 로또 티켓 리스트를 자동으로 **발급하는** 기계가 아닐까요??\n\n객체를 정의함으로써 역할과 책임을 가지게 되고 그 역할과 책임에 맞게 행동(method)을 하게 되죠.\n객체를 주체성과 의인화로 표현하기도 하는데 이 관점에서는 매트의 생각의 방향과 다르지 않을까요??\n메세지 전송이 행동 요청이라고 본다면 LottoMachine에게 로또 발급을 요청하는 것 아닐까요??\n\n> 객체지향 세계에서는 모든 것이 능독적이고 자율적인 존재로 바뀐다.\n> 레베카 워프스브록은 능동적이고 자율적인 존재로 소프트웨어 객체를 설계하는 원칙을 가리켜 의인화(anthropomorphism)라고 한다.\n> 훌룡한 객체지향 설계란 소프트웨어를 구성하는 모든 객체들이 자율적으로 행동하는 설계를 가리킨다.\n```\n\n가장 주목해서 본 것은 `LottoMacine은 로또 티켓 리스트를 자동으로 발급하는 객체`라는 것이다. 객체는 `능동적`이고 `자율적`이어야 한다. 하지만 현재 purhase라는 의미는 외부 클라이언트에 의해 `수동적`으로 행해지고 있다.\n\n이렇게 사소한 메서드명이지만 객체의 자율성을 침해하였다. `모든 객체들은 능동적이고 자율적인 존재`라는 것을 항상 기억해야 한다.\n\n이제 LottoMachine은 더이상 외부에 의해 구매되는 것이 아닌 자율적으로 발급해주는 객체가 되었다.\n\n```java\npublic class LottoMachine {\n\n    public LottoTickets issue(Money money) {\n        return new LottoTickets(money.calculateTicketCount(), new AutoLottoNumberGenerator());\n    }\n}\n```\n\n## Controller와 View의 의존성을 줄여라!\n\n시작은 리뷰어 [로운](https://github.com/lowoon)의 한 문장이었다.\n\n#### 리뷰 중 일부\n```markdown\n`로운`: controller가 view를 가지는게 맞을까요??\n```\n\n기존 `Controller`는 `InputView와 OutputView를 생성 시점에 주입`받아 사용하고 있었다.\n\n```java\npublic class LottoController {\n\n    private final InputView inputView;\n    private final OutputView outputView;\n\n    public LottoController(InputView inputView, OutputView outputView) {\n        this.inputView = inputView;\n        this.outputView = outputView;\n    }\n    ...\n}\n```\n\n위와 같이 설계한 이유는 아래와 같았다.\n\n#### 리뷰 중 일부\n```markdown\n`매트`: Controller에서 View에 대한 존재는 알 수 있다고 판단 하였습니다. 또한 View는 Console에만 국한된 것이 아니라 웹과 같이 다른 종류도 위치할 수 있다고 판단하여 Controller의 생성 시점에 주입될 수 있도록 작성하였습니다.\n\nMVC 패턴을 활용하여 설계를 진행할 때 로운이 언급하신 것 처럼 Controller에서 View를 어떤식으로 사용하면 좋은지 고민이 많았습니다. 단순히 View에서 사용하는 메서드들을 static으로 만들어 유틸리티 클래스로 사용할 경우 View와 Controller의 강한 결합도로 변경에 유연하게 대처하지 못할 것이라 판단하여 생성자 주입을 통한 View 객체를 활용하였습니다.\n\n생성자 주입 방식을 통한 의존 객체 주입은 유연성 가져다 준다고 생각합니다. 이러한 방법 이외에는 View와 Controller를 어떤식으로 활용하여 사용해야 할지 감이 잡히지 않아 해당 방식이 적절하다고 판단하여 선택하였습니다.\n\n관련해서 Controller가 상태를 가지는 경우 주의해야 할 점이나 제가 정리한 개념 중 잘못된 것이 있는지, 참고할 수 있는 키워드를 주시면 활용하여 반영하겠습니다!\n```\n\n#### 리뷰 중 일부\n```markdown\n`로운`: 많은 고민과 정리를 하셨군요 👍 생성자 주입 방식을 통해 유연성을 가져다 주는 것을 알고 계시네요 💯\n\n제가 물어본 이유도 View는 Console에만 국한된 것이 아니라 웹과 같이 다른 종류도 위치할 수 있다 이 부분 때문이었는데요.\n\n말씀하신 web이나 앱의 요청일 경우에는 controller를 사용하지 못할거에요.\n생각하신 방법에서 console view가 아닌 web인 경우라면 view를 통해 어떻게 들어오는 걸까요???\n\nview를 통해 사용자의 값을 입력받은 것을 web에서 아이디/패스워드를 입력한 것이라고 한다면, 서버가 아이디와 패스워드 값만 받아 검증 및 처리를 하는 것과 같이 controller에 view를 통해 입력된 값만 전달되야하지 않을까요??\n\n기본적으로 서버는 front(view)에 상관없이 요청이 들어오면 같은 형태의 데이터를 보내줄 수 있어야 해서 여쭤보게 됐어요!\n```\n\n처음 피드백을 확인했을 때 살짝 멘붕이 왔다. 결국 이전에 설계한 구조 또한 `Console View에 종속적인 Controller`를 만들게 된 것이다.\n\n많은 고민들을 진행했다. 로운의 피드백 중 가장 집중하며 본 것은 `controller에 view를 통해 입력된 값만 전달`이다. 즉 Controller에서 View에게 메시지를 보내는 것이 아닌 `값`을 통해 둘 사이의 통신이 이루어져야 한다.\n\n### Controller 개선하기\n\n가장 먼저 Controller가 의존하고 있는 View를 없애고 단순히 값을 주고 받을 수 있는 구조로 개선하였다.\n\n```java\npublic class LottoController {\n\n    public MoneyDto createMoney(int money) {\n        return MoneyDto.from(new Money(money));\n    }\n\n    public LottoTicketsDto createLottoTickets(int money) {\n        LottoMachine lottoMachine = new LottoMachine();\n        LottoTickets lottoTickets = lottoMachine.issue(new Money(money));\n\n        return LottoTicketsDto.from(lottoTickets);\n    }\n\n    public WinningNumberDto createWinningNumber(List<Integer> normalNumbers, int bonusNumber) {\n        WinningNumber winningNumber = new WinningNumber(new LottoTicket(normalNumbers), new LottoNumber(bonusNumber));\n\n        return WinningNumberDto.from(winningNumber);\n    }\n\n    public LottoResultDto createLottoResult(int money, WinningNumberDto winningNumberDto,\n                                            LottoTicketsDto lottoTicketsDto) {\n\n        WinningNumber winningNumber = winningNumberDto.toWinningNumber();\n        LottoTickets lottoTickets = lottoTicketsDto.toLottoTickets();\n\n        LottoResult lottoResult = lottoTickets.determine(winningNumber);\n\n        return LottoResultDto.from(lottoResult.getRanks(), lottoResult.calculateYield(new Money(money)));\n    }\n}\n```\n\n이제 Controller의 역할은 Console View에 종속적이지 않고 단순히 View에서 요청하는 데이터 형식에 domain을 적절히 가공하여 반환할 수 있는 형태로 개선되었다.\n\n이것으로 인한 장점으로는 View와 Controller 사이의 결합도를 낮추고 `값 으로만 통신`하기 때문에 추후에 Web과 같은 요구사항이 추가된다면 `Controller와 Domain은 그대로 사용`이 가능할 것으로 판단한다.\n\n## assertJ와 Junit5의 혼용\n\n기존의 단위 테스트는 모두 assertJ로 통일하여 사용하였다. 예외를 던지지 않고 정상적으로 생성하는 테스트를 작성할 때 보통 `assertThatCode`를 활용하였다.\n\n```java\nclass LottoMachineTest {\n\n    @DisplayName(\"구입 금액을 기반으로 로또 티켓을 자동 발급한다.\")\n    @Test\n    void 로또_머신_정상_발급() {\n        // given\n        LottoMachine lottoMachine = new LottoMachine();\n\n        // when & then\n        assertThatCode(() -> lottoMachine.issue(new Money(14000)))\n                .doesNotThrowAnyException();\n    }\n}\n```\n\n하지만 Junit5에 더 직관적인 이름을 가진 메서드가 존재했다. 그것은 바로 `assertDoesNotThrow`였다.\n\n처음 도입 이전에는 assertJ와 Junit5를 혼용해서 사용해도 괜찮은지 의문이었다. 관련 피드백은 아래에서 확인할 수 있었다.\n\n#### 리뷰 중 일부\n```markdown\n`로운`: 한 테스트안에서 두가지를 혼용해서 사용하고 있습니다. 같이 혼용하는 것이 문제가 되지는 않아서요. 추후에 mock이라는 것도 사용하시게 될텐데 이렇게 여러가지를 같이 쓰시게 될거에요.\n\njunit5의 assertAll을 알려드리려고 했는데 지금 말씀드리면 되겠네요 😄\n```\n\n```java\nassertAll(\n        () -> assertThat(rank).isEqualTo(Rank.SECOND),\n        () -> assertThat(rank.getPrizeMoney()).isEqualTo(30_000_000)\n);\n```\n\n```markdown\nassertThat을 연달아 쓸때 첫번째 assert에서 실패하게 되면 두번째 assert는 안돌게 되는데요. assertAll을 쓰게되면 첫번째가 실패하더라도 두번째도 테스트를 하게 됩니다\n```\n\n덕분에 `assertAll`이라는 좋은 기능도 확인할 수 있었다. 이제는 부담없이 필요한 곳에 적절히 사용할 예정이다.\n\n## 정적 팩토리 메서드의 적용\n\n#### 리뷰 중 일부\n```markdown\n`로운`: 정적 팩토리 메서드를 적용해 보는 것도 좋을거 같네요!\n```\n\n[정적 팩토리 메서드(Static Factory Method)는 왜 사용할까?](https://tecoble.techcourse.co.kr/post/2020-05-26-static-factory-method/)\n\n사실 이전에는 정적 팩토리 메서드를 왜 사용해야 하는지 알지 못했다. 이번 기회를 통해 정적 팩토리 메서드에 대해 공부하고 적용해보며 장점들을 확인할 수 있는 좋은 기회가 되었다. \n\n1단계 미션이 merge되면 정적 팩토리 메서드에 대해 다시 정리하여 따로 작성할 예정이다. 아래는 기존 생성자 코드를 정적 팩토리 메서드로 개선한 코드이다.\n\n```java\npublic class LottoTicketsDto {\n\n    private final List<LottoTicketDto> lottoTickets;\n\n    private LottoTicketsDto(LottoTickets lottoTickets) {\n        this.lottoTickets = lottoTickets.getLottoTickets()\n                .stream()\n                .map(LottoTicketDto::new)\n                .collect(toList());\n    }\n\n    // 정적 팩토리 메서드\n    public static LottoTicketsDto from(LottoTickets lottoTickets) {\n        return new LottoTicketsDto(lottoTickets);\n    }\n\n    public LottoTickets toLottoTickets() {\n        List<LottoTicket> lottoTickets = this.lottoTickets.stream()\n                .map(LottoTicketDto::toLottoTicket)\n                .collect(toList());\n        return new LottoTickets(lottoTickets);\n    }\n\n    public List<LottoTicketDto> getLottoTickets() {\n        return Collections.unmodifiableList(lottoTickets);\n    }\n}\n```\n\n이제 from이라는 이름을 통해 의도를 드러낼 수 있고, 생성자의 내부 구현을 숨기며 작성이 가능하다.\n\n아래와 같이 직관적인 방식을 통해 객체를 생성할 수 있게 된다.\n\n```java\npublic class LottoController {\n    ...\n    public LottoTicketsDto createLottoTickets(int money) {\n        LottoMachine lottoMachine = new LottoMachine();\n        LottoTickets lottoTickets = lottoMachine.issue(new Money(money));\n\n        return LottoTicketsDto.from(lottoTickets);\n    }\n    ...\n}\n```\n\n## References\n\n[정적 팩토리 메서드(Static Factory Method)는 왜 사용할까?](https://tecoble.techcourse.co.kr/post/2020-05-26-static-factory-method/)"},{"excerpt":"목표  우아한테크코스에서 진행한 미션의 리뷰와 피드백에 대해 정리한다. 실제 리뷰는 [2단계 - 자동차 경주 리팩터링] 매트(최기현) 미션 제출합니다.에서 확인할 수 있다. 1. 객체지향 관점에서 유틸리티 클래스 최초에 미션을 접하고 설계를 진행할 때에도 객체지향적인 설계를 위해 노력했다. 하지만 모든 클래스에서 공유하여 사용할 수 있는 들의 사용은 장점…","fields":{"slug":"/java-racing-car-step2/"},"frontmatter":{"date":"February 17, 2022","title":"[레벨 1] 02. 2단계 - 자동차 경주 구현","tags":["우아한테크코스","레벨1","미션"]},"rawMarkdownBody":"\n## 목표\n\n![](https://user-images.githubusercontent.com/59357153/152970395-a31c8134-fc89-449f-b4dc-441e03df929c.png)\n\n우아한테크코스에서 진행한 미션의 리뷰와 피드백에 대해 정리한다. 실제 리뷰는 [[2단계 - 자동차 경주 리팩터링] 매트(최기현) 미션 제출합니다.](https://github.com/woowacourse/java-racingcar/pull/349)에서 확인할 수 있다.\n\n## 1. 객체지향 관점에서 유틸리티 클래스\n\n최초에 미션을 접하고 설계를 진행할 때에도 객체지향적인 설계를 위해 노력했다. 하지만 모든 클래스에서 공유하여 사용할 수 있는 `클래스 메서드`들의 사용은 장점도 많지만 객체지향에 가깝지 않다고 학습한 경험이 있고 `클래스 메서드`들은 `객체의 생명주기`와 관계없이 관리되기 때문에 객체가 중심이 되는 `객체지향`과는 거리가 멀다고 판단했다.\n\n또한 기존 utils 패키지에 존재하던 `유틸리티 클래스(Console, Randoms)`의 역할이 다소 부실하다고 느꼈습니다. 또한 사용되는 곳이 한정적이기 때문에 굳이 클래스 분리를 하지 않고 객체 내부로 `해당 책임을 이전(InputView, RandomMovingPolicy)` 하여 유틸리티 클래스를 제거했다.\n\n이러한 학습을 기반으로 아래와 같이 개선했다.\n\n* 기존 utils 패키지에 있던 모든 클래스를 제거했다.\n* 클래스 메서드를 가졌던 InputView와 OutputView를 객체 생성으로 변경한 뒤 Controller 생성 시점에 주입했다.\n\n#### InputView\n\n```java\npublic class InputView {\n    private static final String INPUT_NAMES_MESSAGE = \"경주할 자동차 이름을 입력하세요(이름은 쉼표(,)를 기준으로 구분).\";\n    private static final String SPLIT_REGEX = \",\";\n    private static final int SPLIT_LIMIT = -1;\n    private static final String INPUT_COUNT_MESSAGE = \"시도할 회수는 몇회인가요?\";\n\n    private final Scanner scanner;\n\n    public InputView() {\n        this.scanner = new Scanner(System.in);\n    }\n\n    public String[] getCarNames() {\n        System.out.println(INPUT_NAMES_MESSAGE);\n        String input = scanner.nextLine();\n        return input.split(SPLIT_REGEX, SPLIT_LIMIT);\n    }\n\n    public String getCount() {\n        System.out.println(INPUT_COUNT_MESSAGE);\n        return scanner.nextLine();\n    }\n}\n```\n\n#### OutputView\n\n```java\npublic class OutputView {\n    private static final String STATUS_MESSAGE = \"\\n실행 결과\";\n    private static final String WINNER_NAME_DELIMITER = \", \";\n    private static final String END_MESSAGE = \"가 최종 우승했습니다.\";\n\n    public void printStatusMessage() {\n        System.out.println(STATUS_MESSAGE);\n    }\n\n    public void printStatus(String carsStatus) {\n        System.out.println(carsStatus);\n        System.out.println();\n    }\n\n    public void printResult(List<String> winners) {\n        System.out.println(String.join(WINNER_NAME_DELIMITER, winners) + END_MESSAGE);\n    }\n\n    public void printErrorMessage(String message) {\n        System.out.println(message + \"\\n\");\n    }\n}\n```\n\n#### Application\n\n```java\npublic class Application {\n\n    public static void main(String[] args) {\n        new RacingCarController(new InputView(), new OutputView()).run();\n    }\n}\n```\n\n### 변경 후 이점\n\n변경 후 이점에 대해 고민 해보았다. 우선 RancingCarController 생성 시점에 View에 대한 의존성을 주입하기 때문에 후에 요구사항이 변경된다면 View를 다른 종류의 View(ex. web)를 주입하여 유연하게 변경이 가능하다고 생각한다.\n\n또한 외부의 자원에 의존하지 않기 때문에 단위 테스트를 작성할 때 온전히 해당 객체만을 테스트할 수 있었다. 덕분에 view와 관련된 단위 테스트까지 진행할 수 있었다.\n\n제이에게 이러한 방향성을 가지고 개선하였다는 것을 전달하였고 아래와 같은 답변을 확인할 수 있었다.\n\n#### 리뷰 중 일부\n```\n첫 번째 미션인데도 불구하고 많은것을 도전해보셨네요 👍\n랜덤값을 이용하는 Car에 대한 테스트를 어떻게 진행해야할까를 넘어서 Controller도 상황에 맞게 테스트 가능한 구조를 만들어보셨네요. 말씀 주신 내용에 대한 이견은 없습니다! 구조가 훨씬 유연해졌다고 생각해요.\n```\n\n긍정적인 답변을 확인할 수 있었다. 후에는 특정 객체를 생성하여 주입하는 책임을 따로 분리해볼 생각이다. 현재에는 생성자 주입을 통한 점진적인 코드로 발전시키기 위해 노력하고 있다.\n\n## View 테스트 진행\n\n기존에 받은 피드백을 기반으로 view 테스트를 진행했고, 의도한 대로 동작하는 것을 확인했다. 특히 @MethodSource를 활용하여 복잡한 객체를 전달하는 방법을 습득하였다.\n\n```java\nprivate staticStream<Arguments> getNamesMethodSourceProvider() {\n    return Stream.of(\n        Arguments.arguments(\"pobi,woni,jun\", 3),\n        Arguments.arguments(\",,,,\", 5),\n        Arguments.arguments(\",pobi,\", 3),\n        Arguments.arguments(\" , ,, , \", 5),\n        Arguments.arguments(\"pobi\", 1)\n    );\n}\n```\n\n## 의도하지 않은 DTO 도입\n\n이전에 Car에서 값을 가공하여 출력문을 만드는 책임을 `CarsStatus`에게 주어 `domain 패키지`에 위치하였다. 하지만 관련해서 아래와 같은 피드백을 확인하였다.\n\n#### 리뷰 중 일부\n```\nCarStatus라는 도메인패키지에 위치하고있는 클래스안에서 carStatus.append(CAR_STATUS_CRITERIA); 와 같이 뷰에서 그려주는 로직들이 들어있는데요,(makeCarStatus메서드) domain에서 뷰에 그려주는 로직들을 분리하여 view에게 책임을 가져가도록 리팩토링해보면 어떨까요?\n```\n\n처음 의도는 `view에서 단순히 domain을 get하는 행위 조차 분리하기 위한 목적`이었다. 하지만 결국 CarsStatus에서는 `출력을 위한 문장을 만드는 책임`을 가지게 되었다. 결국 `domain 내부에 view와 관련된 로직이 포함`된 것이다. \n\n하지만 도저히 `view에서 domain 관련 객체를 get하는 것`은 자존심이 허락하지 않았다. 결국 개선하기 위한 다른 방법이 필요했다.\n\n위와 같은 피드백을 확인하고 아래와 같이 개선하였다.\n * `CarsStatus` 객체를 `제거`하였다.\n * `domain`이 `view`에서 사용되지 않도록 `추가적인 DTO를 사용`하여 `결합도를 낮추었다.`\n\n#### CarDto\n\nCar 객체의 정보를 전달하기 위한 DTO이다.\n\n```java\npublic class CarDto {\n    private final String name;\n    private final int position;\n\n    public CarDto(Car car) {\n        this.name = car.getName();\n        this.position = car.getPosition();\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public int getPosition() {\n        return position;\n    }\n}\n```\n\n#### CarsDto\n\nCars 객체의 정보를 전달하기 위한 DTO이다.\n\n```java\npublic class CarsDto {\n    private final List<CarDto> cars;\n\n    public CarsDto(Cars cars) {\n        this.cars = cars.getCars()\n            .stream()\n            .map(CarDto::new)\n            .collect(toList());\n    }\n\n    public List<CarDto> getCars() {\n        return Collections.unmodifiableList(cars);\n    }\n}\n```\n\n`getCars()`를 활용할 때 `Collections.unmodifiableList()`를 활용하여 불변성을 유지하기 위해 노력하였다.\n\n#### OutputView\n\n이제 `Cars(domain)`에서 직접적으로 값을 꺼내 출력문을 만들지 않고 `CarsDto`를 통해 전달 받은 값으로 출력문을 생성하도록 개선하였다.\n\n```java\npublic class OutputView {\n    private static final String STATUS_MESSAGE = \"\\n실행 결과\";\n    private static final String CARS_STATUS_JOIN_DELIMITER = \"\\n\";\n    private static final String CAR_STATUS_CRITERIA = \" : \";\n    private static final int DEFAULT_POSITION = 0;\n    private static final String CAR_STATUS_POSITION = \"-\";\n    private static final String WINNER_NAME_DELIMITER = \", \";\n    private static final String END_MESSAGE = \"가 최종 우승했습니다.\";\n\n    public void printStatusMessage() {\n        System.out.println(STATUS_MESSAGE);\n    }\n\n    public void printStatus(CarsDto carsDto) {\n        System.out.println(makeCarsStatus(carsDto));\n        System.out.println();\n    }\n\n    public String makeCarsStatus(CarsDto carsDto) {\n        return carsDto.getCars()\n            .stream()\n            .map(this::makeCarStatus)\n            .collect(joining(CARS_STATUS_JOIN_DELIMITER));\n    }\n\n    private String makeCarStatus(CarDto carDto) {\n        StringBuilder carStatus = new StringBuilder(carDto.getName());\n        carStatus.append(CAR_STATUS_CRITERIA);\n        int position = carDto.getPosition();\n        while (position-- > DEFAULT_POSITION) {\n            carStatus.append(CAR_STATUS_POSITION);\n        }\n        return carStatus.toString();\n    }\n\n    public void printResult(List<String> winners) {\n        System.out.println(String.join(WINNER_NAME_DELIMITER, winners) + END_MESSAGE);\n    }\n\n    public void printErrorMessage(String message) {\n        System.out.println(message + \"\\n\");\n    }\n}\n```\n\n객체 간의 의존 관계를 그림으로 표현하면 아래와 같다.\n\n![](https://user-images.githubusercontent.com/59357153/154450880-b0c996b9-5366-4505-80d5-5be2ed0aca4b.png)\n\n## VO \n\n관련해서는 [VO(Value Ojbect)란 무엇일까?](https://tecoble.techcourse.co.kr/post/2020-06-11-value-object)에서 답을 확인할 수 있었다. 추가적인 학습을 통해 정리가 필요 할 것 같다.\n\n## References\n\n * [웹 MVC 각 컴포넌트 역할](https://tecoble.techcourse.co.kr/post/2021-04-26-mvc/)\n * [System.in과 System.out에 대한 테스트](https://sakjung.tistory.com/33)\n * [VO(Value Ojbect)란 무엇일까?](https://tecoble.techcourse.co.kr/post/2020-06-11-value-object)\n"},{"excerpt":"목표  우아한테크코스에서 진행한 미션의 리뷰와 피드백에 대해 정리한다. 실제 리뷰는 [1단계 - 자동차 경주 구현] 매트(최기현) 미션 제출합니다.에서 확인할 수 있다. 1단계 - 자동차 경주 구현 리뷰 확인 우아한테크코스의 가장 큰 장점인 실제 현업 개발자에게 작성한 코드를 리뷰 받을 수 있다는 것이다. 처음 받는 리뷰이고 누군가에게 내 코드를 보여준다…","fields":{"slug":"/java-racing-car-step1/"},"frontmatter":{"date":"February 15, 2022","title":"[레벨 1] 01. 1단계 - 자동차 경주 구현","tags":["우아한테크코스","레벨1","미션"]},"rawMarkdownBody":"\n## 목표\n\n![](https://user-images.githubusercontent.com/59357153/152970395-a31c8134-fc89-449f-b4dc-441e03df929c.png)\n\n우아한테크코스에서 진행한 미션의 리뷰와 피드백에 대해 정리한다. 실제 리뷰는 [[1단계 - 자동차 경주 구현] 매트(최기현) 미션 제출합니다.](https://github.com/woowacourse/java-racingcar/pull/275)에서 확인할 수 있다.\n\n## 1단계 - 자동차 경주 구현 리뷰 확인\n\n우아한테크코스의 가장 큰 장점인 실제 현업 개발자에게 작성한 코드를 리뷰 받을 수 있다는 것이다. 처음 받는 리뷰이고 누군가에게 내 코드를 보여준다는 것이 조금은 부끄럽게 다가왔다. 하지만 좋은 기회를 통해 평소 고민했던 것들을 나누며 많은 조언들과 힌트를 얻을 수 있었다.\n\n첫 미션의 리뷰어는 제이이다. 아래는 리뷰를 통해 추가적으로 알게된 것과 피드백 후 개선 중 생겨난 고민들을 정리하였다.\n\n### 요구사항 정리\n\n아래는 이번 미션을 진행하며 정리한 요구사항인 구현 기능 목록이다. 프리코스 당시 진행한 미션과 동일했기 때문에 요구사항을 파악하는데 큰 힘이 들진 않았다.\n\n```markdown\n## 🛠 구현 기능 목록\n\n* [x] 경주할 자동차의 이름을 입력한다.\n* [x] 각 자동차의 이름은 `쉼표(,)`를 기준으로 구분한다.\n* [x] 시도할 회수를 입력한다.\n* [x] 시도할 회수는 `0이상` 이다.\n* [x] 시도할 회수는 `숫자 이외의 값` 또는 `음수`를 전달할 경우 `예외를 throw` 한다.\n* [x] 자동차의 이름은 `5자 이하`이다.\n* [x] 자동차의 이름이 `6자 이상`이면 `예외 throw` 한다.\n* [x] 자동차의 이름은 `null`, `''`, `' '` 이 올 수 없다.\n* [x] 자동차의 이름이 `중복`될 경우 `예외를 throw` 한다.\n* [x] 시도할 회수만큼 자동차는 움직일 수 있다.\n* [x] 회수마다 `전진하는 조건을 판단`하여 자동차를 이동시킨다.\n* [x] `0에서 9 사이에 random 값`을 구한 후 `random 값이 4 이상` 인 경우 `전진`하고, `3 이하`인 경우 멈춘다.\n* [x] 실행 결과를 출력한다.\n* [x] 경주가 완료된 후 현재 위치를 확인한 뒤 우승자를 출력한다.\n* [x] 우승자는 한 명 이상일 수 있다.\n* [x] 입력에 실패할 경우 `예외를 catch`하고 `재입력` 받는다.\n```\n\n현재 미션의 규모가 크지 않기 때문에 더 세부적인 그룹화는 진행하지 않았다. 관련해서는 아래와 같은 피드백을 확인할 수 있었다.\n\n#### 리뷰 중 일부\n```\n나중에 프로젝트가 커지게되면 요구사항을 그룹화해서 나눠보는것도 좋을거에요.\n자동차라는 그룹 하위에 이름에 대한 정책들, 움직임에 대한 정책들 같이요.\n지금도 충분히 좋아요~\n```\n\n언급하신 것 처럼 규모가 커지게 되면 요구하는 사항들이 늘어나고 결국 그룹화하지 않은 목록들은 직관적이지 않게 될 것이다. 결국 사람이 보는 문서이기 때문에 한 눈에 이해할 수 있도록 작성하는 방법에 대해서도 고민해 보면 좋을 것 같다.\n\n### 책임의 부여\n\n이번 미션을 진행하며 각 객체에게 적절한 책임을 부여하고 객체간에 충분한 협력을 진행하기 위해 노력했다. 그러한 과정에서 생겨난 객체들의 책임을 정리하였다.\n\n### view\n\n#### InputView\n\n입력의 책임을 가지고 있다. \n\n#### OutputView\n\n출력에 대한 책임을 가지고 있다. 출력 양식에 맞춰 문자열을 가공하고 출력한다.\n\n### utils\n\n프리코스 당시 사용했던 utils의 메서드명을 참고하였다.\n\n#### Console\n\n입력 관련 유틸 클래스이다. 현재 한 줄 단위로 읽기 위한 기능을 가지고 있다.\n\n#### Randoms\n\n랜덤과 관련된 유틸 클래스이다. 파라미터로 전달된 구간 사이의 값을 랜덤으로 반환하는 기능을 가지고 있다.\n\n### domain\n\n#### Car\n\n차를 표현하기 위한 Car이다. Car의 이름과 현재 위치, 이동 전략에 대한 정보를 가지고 있다. \n\n#### CarName\n\n차의 이름의 표현하기 위한 객체이다. 차의 이름에 대한 검증을 모두 여기서 이루어진다.\n\n#### Cars\n\nCar List를 가진 일급 컬렉션이다. Cars는 Car List를 활용하여 차 이름의 중복을 검사할 수 있다. 또한 현재 위치를 기반으로 우승자 List를 확인할 수 있다.\n\n#### MovingPolicy\n\n자동차의 이동 전략이다. 현재에는 랜덤한 숫자를 기반으로 이동하는 랜덤 이동 정책 구현체(RandomMovingPolicy)를 활용하여 차의 이동 유무를 확인한다.\n\n#### Count\n\n시도 횟수를 가진 객체이다. 시도 가능 유무를 확인하고 가능하면 시도 횟수를 차감하여 게임이 가능한지 확인할 수 있다.\n\n#### RacingCarController\n\n자동차 경주를 제어하기 위한 Controller이다. domain과 view사이에 위치하여 제어를 진행한다.\n\n#### 리뷰 중 일부\n```\n정말 잘 나누어주셨네요 👍\n저는 개인적으로 문서화가 굉장히 중요하다고 생각해요. 협업하는 사람들 혹은 새로합류하는 사람들을 위해서 큰 도움이 됩니다.\n큰 장점을 가지신것같아요. 나중에 많은 도움이 될거에요!\n```\n\n평소 문서화에 대한 중요성을 몸소 느끼고 있었는데 중요성을 한 번 더 언급하셨다. 앞서 말한 것 처럼 문서는 결국 사람이 보는 것이기 때문에 무엇보다 직관성이 중요하다고 생각한다.\n\n### 전략 패턴\n\n전략 패턴에 대해서는 직접 학습한 경험도 많고 이전 미션에도 적용하였기 때문에 쉽게 생각해낼 수 있었다. \n\n#### 리뷰 중 일부\n```\n자동차의 이동 유무를 판단하기 위한 전략 패턴을 사용하였습니다. \nCar 객체를 생성하는 시점에 전략을 정할 수 있어서 유연하게 이동과 관련된 단위 테스트를 진행할 수 있었습니다. \n후에 이동에 대한 다른 요구사항이 추가된다면 구현체를 추가하고 교체하는 행위로 쉽게 변경이 가능할 것으로 판단됩니다! \n이번에 전략 패턴을 적용하며 위와 같은 장점 들을 알 수 있었습니다.\n\n네 저도 매트가 이야기한 코드의 유연성, 테스트의 용이성 측면에서 좋은 선택이라고 생각해요!\n```\n\n실제 적용해보며 다양한 장점들을 느낄 수 있었다. 미션을 진행할 때는 생성자를 통해 전략을 주입해주는 방식을 채택하였다. 하지만 생각해보면 move 메서드를 움직이는 시점에 해당 전략을 주입할 수도 있을 것이다. 두 상황에 대해 어떠한 장단점을 가지고 있을까?\n\n#### 1. 생성자를 통한 전략 패턴\n\n```java\npublic class Car {\n    private final CarName name;\n    private int position;\n    private final MovingPolicy movingPolicy;\n\n    public Car(String name, MovingPolicy movingPolicy) {\n        this.name = new CarName(name);\n        this.position = 0;\n        this.movingPolicy = movingPolicy;\n    }\n\n    public void move() {\n        if (movingPolicy.isMovable()) {\n            position++;\n        }\n    }\n\n    public String getName() {\n        return name.getName();\n    }\n\n    public int getPosition() {\n        return position;\n    }\n}\n```\n\n위 코드를 살펴보면 `Car 객체를 생성하는 시점`에 객체 내부의 인스턴스 변수에 전략이 정해진다. 즉 추가적인 인스턴스 변수가 필요하고, `별도의 setter나 수정 관련 메서드`가 없다면 생성된 Car의 이동 전략은 변경되지 않을 것이다.\n\n#### 2. move() 실행 시점에 전달된 전략 패턴\n\n```java\npublic class Car {\n    private final CarName name;\n    private int position;\n\n    public Car(String name) {\n        this.name = new CarName(name);\n        this.position = 0;\n    }\n\n    public void move(MovingPolicy movingPolicy) {\n        if (movingPolicy.isMovable()) {\n            position++;\n        }\n    }\n\n    public String getName() {\n        return name.getName();\n    }\n\n    public int getPosition() {\n        return position;\n    }\n}\n```\n\n위 코드는 전략을 가진 MovingPolicy를 `move() 메서드 실행 시점`에 전달되고 있다. 기존에 존재하던 인스턴스 변수는 유지할 필요 없어졌고, 이동할 때마다 전략을 변경할 수 있게 되었다. 하지만 move() 실행 시 외부에서 매번 전략을 전달해야 한다.\n\n이것은 추가적인 질문을 통해 이해한 바가 맞는지 질문할 예정이다.\n\n#### 리뷰 중 일부\n```\n지금 상황에서라면 1번 모습이 더 낫습니다. \n자동차의 움직임이 변경되는 요구사항이 없기 때문에 굳이 move를 할때마다 전략을 넘겨주는 행위는 불필요하다고 생각해요.\n추후에 예를 들어, 객체에 매번 메세지를 보낼때마다 행위가 달라져야하는 요구사항이 생긴다면 2번으로 코드를 작성해도 될 것 같아요. \n혹은 클래스내에 전략을 List로 가지고있고 인자값을 받은 후 맞는 전략을 선택해서 실행하게끔요.\n```\n\n```java\npublic class AA {\n    private final List<AAPolicy> AAPolicies;\n```\n\n```\n정리하면 잘못된건 없고 필요에 맞춰서 유연하게 사용하는것이 중요하다고 생각해요! \n```\n\n나의 생각도 동일하다. 현재 상황에서는 주어진 동작 방식을 변경하기 위한 요구사항이 존재하지 않기 때문에 생성자를 통해 주입하는 방식이 적절하다고 판단한다. \n\n정리하면, 충분한 근거와 함께 필요에 맞게 사용하면 문제는 없다! 추가적으로 전략을 List로 관리하는 꿀팁까지 얻을 수 있었다.\n\n### 검증 로직\n\n요구사항 만족을 위해 다양한 검증 로직을 작성하였다. 각 객체의 검증 책임도 자신에게 있다고 생각하여 객체 내부에서 진행했다. 한 예시로 최초에 Car는 단순히 String으로 name이라는 인스턴스 변수를 가지고 있었다. \n\n```java\npublic class Car {\n    private final String name;\n    ...\n    \n    public Car(String name, MovingPolicy movingPolicy) {\n        validateNull(name);\n        validateEmpty(name);\n        validateBlank(name);\n        validateNameLength(name);\n        this.name = name;\n        ...\n    }\n\n    private void validateNull(String name) {\n        if (name == null) {\n            throw new IllegalArgumentException();\n        }\n    }\n    private void validateEmpty(String name) {\n        if (name.isEmpty()) {\n            throw new IllegalArgumentException();\n        }\n    }\n    private void validateBlank(String name) {\n        if (name.isBlank()) {\n            throw new IllegalArgumentException();\n        }\n    }\n    private void validateNameLength(String name) {\n        if (name.length() > 5) {\n            throw new IllegalArgumentException();\n        }\n    }\n    ...\n}\n```\n\n하지만 과도하게 name에 대한 검증 로직이 늘어나 해당 객체의 책임을 이해하는데 어려움이 있다고 판단했고 결국 String을 포장한 `CarName` 객체를 작성하여 이름에 대한 책임을 분리했다.\n\n현재에는 아래와 같이 작성하였다.\n\n#### CarName\n```java\npublic class CarName {\n    private final String name;\n\n    public CarName(String name) {\n        validateNull(name);\n        validateEmpty(name);\n        validateBlank(name);\n        validateNameLength(name);\n        this.name = name;\n    }\n\n    private void validateNull(String name) {\n        if (name == null) {\n            throw new IllegalArgumentException(\"이름은 null이 될 수 없습니다.\");\n        }\n    }\n\n    private void validateEmpty(String name) {\n        if (name.isEmpty()) {\n            throw new IllegalArgumentException(\"이름이 비어 있습니다.\");\n        }\n    }\n\n    private void validateBlank(String name) {\n        if (name.isBlank()) {\n            throw new IllegalArgumentException(\"이름은 공백이 될 수 없습니다.\");\n        }\n    }\n\n    private void validateNameLength(String name) {\n        if (name.length() > 5) {\n            throw new IllegalArgumentException(\"이름은 5자를 초과할 수 없습니다.\");\n        }\n    }\n\n    public String getName() {\n        return name;\n    }\n}\n```\n\n#### Car\n\n```java\npublic class Car {\n    private final CarName name;\n    private int position;\n    private final MovingPolicy movingPolicy;\n\n    public Car(String name, MovingPolicy movingPolicy) {\n        this.name = new CarName(name);\n        this.position = 0;\n        this.movingPolicy = movingPolicy;\n    }\n\n    public void move() {\n        if (movingPolicy.isMove()) {\n            position++;\n        }\n    }\n\n    public String getName() {\n        return name.getName();\n    }\n\n    public int getPosition() {\n        return position;\n    }\n}\n```\n\n한 가지 고민인 것은 검증에 대한 책임을 `Validator`와 같은 클래스로 분리하는 것을 종종 본 기억이 있는데 어떠한 방식이 더 선호 되는지 궁금했다.\n\n#### 리뷰 중 일부\n```markdown\n어떤 행위를 할때는 필요에 의해서 하는게 중요하다고 생각해요. 무조건 객체 포장해야지 가 아니라 왜 포장을 해야될까를 생각해보고 하는것이 중요합니다.\n매트가 조치를 한 내용을 보니 잘 하신것으로 보여요.\n\n* Car에서 이름검증 수행\n* 역할이 너무 많아짐을 인지\n* 분리의 필요성 인지\n```\n\n제이가 가장 강조한 것은 `필요`에 의한 객체 포장이다. 즉 포장을 진행할 때 그에 맞는 이유를 동반해야 한다. \n\nValidator의 경우에도 마찬가지이다. CarName과 유사한 검증 코드를 가진 다양한 객체가 있는 경우 공통 부분을 선별하여 Validator를 생성하면 된다.\n\n* CarName말고 AirplaneName, ShipName 등등이 출현\n* 3개의 객체에서 중복 로직들 인지\n* 분리의 필요성 인지 -> `이유를 동반`\n* NameValidator로 추출 -> `검증을 위한 책임 부여`\n\n정리하면, 결국 모든 코드는 존재하기 위한 이유를 동반해야 한다.\n\n### 매직 넘버에 대한 기준\n\n프리코스 진행 당시 매직 넘버, 매직 리터럴에 대한 키워드를 확인하였고 이번 미션 에도 적용하기 위해 노력했다. 하지만 메서드 명에서 해당 기능을 뚜렷하게 표현하고 있을 때 상수로 변경하는 것이 맞는지 고민이 되었다. 이유는 한 메서드에서만 사용하기 때문에 중복 사용될 우려가 없고 무의미하게 메모리를 차지하는 것은 아닌지 등 적절한 기준에 대해 알지 못했다.\n\n아래는 고민의 흔적 중 일부이다. 결국 상수 처리하지 않고 제출하였다.\n\n```java\npublic class CarName {\n    private final String name;\n\n    public CarName(String name) {\n        ...\n        validateNameLength(name);\n        this.name = name;\n    }\n    ...\n    private void validateNameLength(String name) {\n        if (name.length() > 5) {\n            throw new IllegalArgumentException(\"이름은 5자를 초과할 수 없습니다.\");\n        }\n    }\n    ...\n}\n```\n\n#### 리뷰 중 일부\n```\n메서드에서 이름을 검증한다는 것은 드러납니다.\n하지만 이 이름의 길이인 5라는 값을 해당 메서드 말고 다른곳에서 쓰이면 어떻게 될까요? 모두 5라는 숫자가 들어가야합니다.\n혹여나 길이에 대한 정책이 바뀌게되면 모든 5를 전부 찾아서 바꿔야되겠죠. 실수로 한 부분을 바꾸지 않는다면 장애가 날 수도 있습니다.\n```\n\n정리하면, 상수 추출은 결국 `해당 메서드만을 위한 것이 아니다.` 미래의 애플리케이션은 어떠한 규모로 성장할 지 모르기 때문에 충분한 습관을 들여야 한다. 결국 자연스럽게 매직 넘버와 관련된 위험성을 줄일 수 있게 된다.\n\n### 패키지 구조\n\n패키지란? 관련 클래스들을 모아서 관리할 수 있도록 사용한다.\n\n자동차 경주 미션을 진행하며 view, domain, utils로 크게 3개의 패키지를 분리했는데 domain 패키지에 Car와 Car의 이동 전략, Controller를 포함하고 있다.\n\n#### 리뷰 중 일부\n```\n현재 위와 같은 모습으로 보이는데요, Controller가 domain패키지에 위치하는것이 맞을까요?\n자동차 만을 위한 정책이 들어가야 domain패키지의 역할에 맞다고 생각해요. Controller에 view를 의존하고있는데 domain이 controller를 가지게되면 view도 가지게 되는 꼴이됩니다. controller를 다른 패키지로 옮겨보면 어떨까요?\n```\n\n내가 생각하는 Controller의 역할은 domain과 view제어하며 명령을 내리는 역할이라고 생각한다. 즉 Controller를 제외한 domain과 view는 `서로의 존재`를 알지 못해야 한다. 하지만 현재 Controller와 domain을 같은 패키지에 위치 시키면 즉 `domain`이 `view에 대한 정보`를 알게 된다.\n\n관련 내용은 [웹 MVC 각 컴포넌트 역할](https://tecoble.techcourse.co.kr/post/2021-04-26-mvc/)에서 확인할 수 있었다.\n\n제이는 미션을 진행하며 지속적인 경험을 통해 습득할 수 있다고 조언했다.\n\n## view에서 return\n\n현재 InputView은 입력에 대한 책임을 가지도록 설정하였습니다. view에서 도메인의 비즈니스 로직을 포함하지 않아야 한다고 학습한 경험이 있습니다. 이러한 배경 지식으로 가장 고민한 부분은 아래와 코드입니다.\n\n```java\npublic class InputView {\n    private static final String INPUT_NAMES_MESSAGE = \"경주할 자동차 이름을 입력하세요(이름은 쉼표(,)를 기준으로 구분).\";\n    private static final String SPLIT_REGEX = \",\";\n    private static final int SPLIT_LIMIT = -1;\n    private static final String INPUT_COUNT_MESSAGE = \"시도할 회수는 몇회인가요?\";\n\n    public static String[] getCarNames() {\n        System.out.println(INPUT_NAMES_MESSAGE);\n        String input = Console.readLine();\n        return input.split(SPLIT_REGEX, SPLIT_LIMIT);\n    }\n\n    public static Count getCount() {\n        System.out.println(INPUT_COUNT_MESSAGE);\n        return new Count(Console.readLine());\n    }\n}\n```\n\n`getCount()`는 시도할 회수를 입력받아 `Count 객체를 생성하여 반환`한다. 보통 view에서는 domain을 활용한 비즈니스 로직을 실행하지 않아야 한다고 학습했다. 이유는 domain과 view는 서로의 존재를 몰라야 하기 때문이다.\n\n#### 리뷰 중 일부\n```\n한마디로 정리하면 `view에서 domain을 생성해도 되는가?` 에 대한 질문으로 이해하였어요. 아니라면 재차 말씀부탁드려요.\n\n현재 구조에서는 사실 뷰에서는 정말 input값만 가지고 컨트롤러로 넘어와서 컨트롤러에서 Count(도메인)을 new 해주는게 역할분리에 있어서 더 맞아보입니다.\n\n지금 당장에 코드수정보다는 mvc 구조에 대해서 서치를 해보고 본인만의 지식으로 만들어보면 어떨까요?\n여력이 된다면 수정해보시고, 조금더 레퍼런스를 찾아보고싶으시면 찾아보고 스레드로 남겨주시는것도 좋아요~\n개인적으로는 추후에 코드적으로 경험할 일이 많으니 레퍼런스를 더 찾아보시는걸 추천드립니다.\n```\n\n만약 view가 웹 이라고 가정한다. 현재는 콘솔을 기반으로 한 view지만 이것을 교체하기 위해서는 최대한 domain에 대한 정보를 모르는 것이 좋다. 즉 view에 도메인 로직을 포함하면 안된다. 로직은 생성자를 포함한다.\n\n아래와 같이 개선 가능하다.\n\n#### InputView\n```java\npublic class InputView {\n    private static final String INPUT_NAMES_MESSAGE = \"경주할 자동차 이름을 입력하세요(이름은 쉼표(,)를 기준으로 구분).\";\n    private static final String SPLIT_REGEX = \",\";\n    private static final int SPLIT_LIMIT = -1;\n    private static final String INPUT_COUNT_MESSAGE = \"시도할 회수는 몇회인가요?\";\n\n    public static String[] getCarNames() {\n        System.out.println(INPUT_NAMES_MESSAGE);\n        String input = Console.readLine();\n        return input.split(SPLIT_REGEX, SPLIT_LIMIT);\n    }\n\n    public static int getCount() {\n        System.out.println(INPUT_COUNT_MESSAGE);\n        return Console.readLine();\n    }\n}\n```\n\n#### RacingCarController\n```java\npublic class RacingCarController {\n    ...\n    private Count getCount() {\n        try {\n            return new Count(InputView.getCount());\n        } catch (IllegalArgumentException e) {\n            OutPutView.printErrorMessage(e.getMessage());\n            return getCount();\n        }\n    }\n    ...\n}\n```\n\n현재에는 view의 static 메서드를 활용하고 있다. 만약 요구사항이 변경되어 view를 바꾸게 된다면 domain 객체가 아닌 원시 타입이나 원시 타입을 포장한 객체 혹은 DTO를 사용하면 각 객체 간의 결합을 줄일 수 있다고 판단된다!\n\n## MVC 패턴\n\n### MVC란?\n\nMVC(Model - View - Controller)는 애플리케이션을 세 가지 역할로 구분한 개발 방법론 중 하나이다.\n\n### Model(Domain)\n * Controller가 호출할 때 요청에 맞는 역할을 수행한다. `비즈니스 로직을 구현하는 영역`으로 응용 프로그램에서 데이터를 처리하는 부분이 된다. \n * DB에 연결하고 데이터를 조회, 저장 삭제 등의 작업을 수행하거나 데이터에 대한 변경 작업을 묶은 트랜잭션을 다루기도 한다.\n * Model은 다른 컴포넌트(View, Controller)들에 대해 알지 못한다. 오로지 자기 자신의 `수행해야 하는 행위`에 대해서만 알고 있다.\n\n### View\n * `Controller`로 부터 받은 `Model`의 결과값을 가지고 `사용자에게 출력`할 화면을 만든다. `무엇을 보여주기 위한 역할`이다.\n * 만들어진 화면은 웹브라우저에 전송되어 웹브라우저에서 출력한다. \n * View 또한 다른 컴포넌트(Model, Controller)들에 대해 알지 못한다. 자신의 수행해야 하는지만 알고 있다.\n\n### Controller\n * 클라이언트의 요청을 받았을 때, 그 요청에 대한 `실제 업무를 수행하는 Model 컴포넌트`를 호출한다. Model이 데이터를 `어떻게 처리할지 알려주는 역할`이다.\n * 클라이언트가 보낸 데이터가 있다면 Model에 전달하기 쉽게 데이터를 가공한다. 모델이 해당 업무를 마치면 `결과`를 `View에 전달`한다.\n * 다른 컴포넌트(Model, View)들에 대해 알고 있다. Model과 View가 무엇을 수행하는지 알고 있다.\n\n![](https://user-images.githubusercontent.com/59357153/153734491-35a83d12-3477-4a18-8314-df574d5ec32c.png)\n\n내가 생각했을 때 MVC 패턴의 각 컴포넌트들의 의존관계를 그림으로 표현한 것이다.\n\n### 더 생각해보기\n\n현재 미션을 해결할 때 View는 Console로 진행된다. 하지만 추후 요구사항이 변경되어 Web의 화면을 표시하기 위한 View를 사용하기로 결정하면 어떻게 해야 하는지 생각해보았다.\n\n의존 관계의 변경을 쉽게 하기 위해서는 협력을 이루는 객체간의 의존도가 낮아야 한다고 생각한다. 즉 View에서는 비즈니스 로직에 속하는 도메인 정보에 대해 알지 못해야 한다. 정해진 규격에 맞춘 데이터 타입을 기반으로 통신해야 한다.\n\n즉 view에서 특정 도메인에게 메시지를 보내거나 반환하지 않아야 한다. \n\n### view 테스트\n\n[System.in과 System.out에 대한 테스트](https://sakjung.tistory.com/33) \n\n제이의 추천 개시글을 읽어보자. 위 언급한 피드백보다 우선순위가 낫기 때문에 차근차근 리팩토링을 진행할 예정이다.\n\n## 리뷰를 받는 사람의 자세\n\n첫 리뷰를 진행하며 코드와 관련된 피드백도 중요하지만 가장 우선이 되야 하는건 `리뷰를 받는 사람의 자세`라고 생각한다.\n\n#### 리뷰 중 일부\n```\n리뷰를 받는 사람은 이 사람이 왜 이렇게 이야기를 했을까를 고민하는것이 우선이 되어야한다고 생각해요. 하지만 더 중요한것은 리뷰어의 말이 전적으로 옳다는 아니라는 것입니다.\n컨벤션이 잘못되었거나 요구사항대로 돌지 않는 버그가 있거나 하는 객관적인 것들은 다 반영이 되어야하는 부분이지만, 답이 없는 문제들 (예를 들면, 설계나 코딩 스타일 같은) 에 대해서는 사람마다 생각하는 것이 다르기 때문에 매트가 어떻게 생각하느냐가 더 중요해요.\n\n같은 코드를 봐도 각자 본인만의 스타일이 있기 때문에 리뷰어들마다 다른 피드백이 올 수 있어요. 그 때마다 무조건적으로 받아들이게 되면 본인만의 아이덴티티가 모호해질 수 있어요. (아닌것같다고 생각하는 부분은 꼭 반론을 제시하시구요)\n지금은 초반이라 걱정하지 않으셔도되지만 우테코가 끝날때쯤에는 매트는 어떤 스타일을 가진 개발자다 라는걸 어느정도 만들었으면 좋겠어요!\n\n리뷰를 진행하실 때 중점적으로 살펴보는 태도에 대해서도 질문을 주셨는데, 저는 소통이 잘 되는걸 먼저 봐요. 어떤 코멘트를 남겼을때 긍정의 이모지 혹은 코멘트를 남기거나, 혹은 다르게 생각하면 반론의 스레드를 남기거나 하는것들이에요. 아무것도 달지 않으면 어떻게 생각하는지 알 수가 없으니까요. 매트는 잘 해주고 계셔서 걱정하지 않으셔도되어요!\n```\n\n정리하면 무조건적인 수용보다 약간의 `반란군 기질`을 발휘하며 `자신 만의 강점`을 키워야 한다는 것이다. 많은 생각을 하게 되는 조언을 들은 것 같다. \n\n## References\n\n * [웹 MVC 각 컴포넌트 역할](https://tecoble.techcourse.co.kr/post/2021-04-26-mvc/)\n * [System.in과 System.out에 대한 테스트](https://sakjung.tistory.com/33) \n"},{"excerpt":"2021년 10월 22일 우아한테크코스 모집을 위한 서류 접수가 시작 되었다. 워낙 유명한 교육이기 때문에 의심할 여지 없이 지원 서류를 작성하였다. 더 나아가 교육의 과  등 자세한 설명은 우아한테크코스 4기 온라인 설명회 에서 확인할 수 있었고, 지원서 작성에 많은 도움이 되었다. 왜 우아한테크코스를 선택했는가? 처음 프로그래밍을 학습한 것은 대학 강…","fields":{"slug":"/precourse-pass/"},"frontmatter":{"date":"December 20, 2021","title":"우아한테크코스 프리코스 후기","tags":["우아한테크코스","프리코스"]},"rawMarkdownBody":"\n![](https://user-images.githubusercontent.com/59357153/147727536-be29c06d-5d3f-4297-8192-a844403d7739.jpeg)\n\n2021년 10월 22일 우아한테크코스 모집을 위한 서류 접수가 시작 되었다. 워낙 유명한 교육이기 때문에 의심할 여지 없이 지원 서류를 작성하였다. 더 나아가 교육의 `본질`과 `추구하는 방향` 등 자세한 설명은 [우아한테크코스 4기 온라인 설명회](https://www.youtube.com/watch?v=mQhgF7RoUCA) 에서 확인할 수 있었고, 지원서 작성에 많은 도움이 되었다.\n\n## 왜 우아한테크코스를 선택했는가?\n\n처음 프로그래밍을 학습한 것은 대학 강의였다. 하지만 대학 강의에서는 배울 수 있는 것이 한정되어 있었기 때문에 항상 배움에 대한 갈망을 가지고 있었다. 또한 개발 진로에 대해 명확한 답을 내리지 못했기 때문에 항상 결승선이 없는 마라톤을 하는 기분이었다. \n\n그 중 가장 흥미를 느낀 것은 웹 분야였다. 처음 웹 분야를 접했을 때는 안쓰이는 곳이 없다고 생각했다. 또한 이러한 서비스를 기획하고 고민하는 과정이 너무 재미있게 다가왔다. 이러한 흥미는 결국 Java와 Spring까지 닿게 되었다. \n\n처음에는 단순히 기술을 익히는데 급급했다. 다양한 강의를 구매하고 책을 읽으며 코드를 따라치기 바빴다. 그렇게 반년의 시간이 지났지만 뒤돌아보면 머릿속에는 남은 것이 하나도 없는 것 처럼 느껴졌다.\n\n결국 Java든 Spring이든 이러한 도구들이 `추구하는 방향`이나 `내부 구현` 등 `기초적인 지식`은 무시한 채 기술만 학습했다. 정리하면 시멘트 없이 단순히 벽돌로 언제 무너져도 이상하지 않는 고층 빌딩을 짓는 것과 마찬가지 였다. \n\n기초 지식을 쌓기 위한 필요성을 확인 하였고, 그때 가장 눈에 뛴 것은 [우아한Tech](https://www.youtube.com/playlist?list=PLgXGHBqgT2TvpJ_p9L_yZKPifgdBOzdVH) 의 우아한테크코스 크루들의 테코톡과 [Tecoble](https://tecoble.techcourse.co.kr/) 블로그 였다. 다양한 크루들이 열정적으로 발표하는 모습과 정돈된 정리들을 보여 감탄하며 한참을 찾아봤다. 무엇보다 학습을 진행하는 모습들이 너무 행복해 보였다.\n\n다른 교육과는 확실히 다른 무언가가 느껴졌다. 그것이 내 호기심을 자극했다.\n\n## 1년의 준비 기간\n\n사실 우아한테크코스의 지원은 처음이 아니었다. 2020년 3기에도 지원을 하였지만 아쉽게 프리코스 조차 하지 못하고 떨어지게 되었다. 3기 불합격은 큰 자극이 되었고, 더 나아가 우아한테크코스 4기는 2021년의 가장 큰 목표로 자리잡게 되었다.\n\n그중 가장 큰 자극이 되었던 것은 지원서의 한 항목이었다.\n\n### 마음이 끌리는 무엇인가에 긴시간 동안 몰입해 본 경험이 있나요?\n\n> 지원서 항목 중 일부\n> \n> *우아한테크코스는 약 10개월 동안 꾸준히 학습해야 수료할 수 있는 과정입니다. 지금까지 살아오면서 마음이 끌리는 무엇인가에 최소 1년 이상을 투자해 결과물을 만들어 낸 것이 있다면 공유해 주세요. 반드시 소프트웨어와 관련된 일이 아니어도 괜찮습니다. 어떤 성과를 냈는지도 중요하지만 어떤 과정과 노력을 했는지를 구체적으로 작성해주세요.*\n>\n> 이 항목을 처음 마주한 순간 정말 막막했다. 아무리 고민했지만 자신있게 떠오르지 않았다. 24년이 넘는 시간 동안 고작 1년을 몰두한 경험이 없다는게 조금은 충격으로 다가왔다. 부랴부랴 최대한 살을 붙여 작성했지만 앞서 언급한 것 처럼 불학격을 마주하게 되었다.\n\n### 일일 커밋, 그 시작\n\n크게 좌절한 것은 아니지만 약간의 번아웃이 찾아왔고 무언가 나를 움직일 수 있는 동기가 필요했다. 그때 \"기억보단 기록을\"을 운영하는 이동욱 님의 [일일커밋의 효용성](https://jojoldu.tistory.com/402) 을 읽게 되었다. \n\n일일커밋을 진행하며 히스토리를 채워가는 모습이 마치 게임 캐릭터를 키우듯 흥미롭고 재미있게 다가왔다. 진행하며 자존감이 많이 떨어진 자신에게 증명하고 싶었고 동기부여가 되고 싶었다. \n\n![](https://user-images.githubusercontent.com/59357153/147730123-db1329b3-5ebb-49a8-b82c-a46d72271947.png)\n\n무엇보다 개발 공부를 `긴시간 동안 몰입`하게 되었다. 뚜렷한 결과물은 아니지만 다양한 프로젝트와 경진대회에 입상하며 많은 경험을 쌓을 수 있었다. 일일 커밋과 함께하는 우아한테크코스 준비는 `1년`이라는 시간이 순식간에 지나갔다.\n\n## 프리코스 합격!\n\n지원서를 제출하고 코딩 테스트를 진행한 뒤 프리코스 결과를 기다렸다. \n\n![](https://user-images.githubusercontent.com/59357153/147730475-da3594cb-899a-4642-8fe8-6857ccb132bc.png)\n\n위 합격 메일을 받고 정말 기뻤다. 지난 1년의 시간을 헛되이 보내지 않았음을 보여주는 것 같았다. 아래는 프리코스를 진행하며 고민했던 내용들을 정리하였다.\n\n * [프리코스 1주차](https://hyeonic.github.io/%EA%B8%B0%ED%83%80/woowacourse/precource-1.html)\n * [프리코스 2주차](https://hyeonic.github.io/%EA%B8%B0%ED%83%80/woowacourse/precourse-2.html)\n * [프리코스 3주차](https://hyeonic.github.io/%EA%B8%B0%ED%83%80/woowacourse/precourse-3.html)\n\n### 프리코스 진행 소감\n\n아래는 프리코스 3주차 제출때 과제 진행 소감을 첨부하였다.\n\n> 😀 과제 진행 소감\n> \n> 안녕하세요 프리코스에 참여한 최기현입니다. 벌써 1, 2주차를 넘어 마지막 미션을 제출하고 소감을 작성하며 너무나 빠르게 시간이 흘러갔다는 것을 체감하고 있습니다.\n>\n> 프리코스 진행 이전에는 웹 개발에 매력에 빠져 1년 정도의 기간 동안 Java와 Spring의 대한 지식들을 채우기 위해 공부를 진행했습니다. 다양한 강의와 개발 서적 접하며 학습 진행했고 이러한 학습을 기반으로 다양한 프로젝트를 진행할 수 있었습니다. 하지만 진행할수록 무언가 채워지지 않는 허전함을 가지고 있었습니다. 객체지향 언어인 Java를 왜 쓰는지, Spring은 어떤 점들 때문에 객체지향적인 설계를 도와주는지 등 근간이 되는 Java와 객체에 대해 전혀 알지 못한 채 단순히 기술과 방법을 배우는데 급급했습니다.\n>\n> 프리코스는 기존의 학습 방법으로 인한 채워지지 않은 허전함을 해결해줄 든든한 한끼처럼 다가왔습니다. 3주간의 미션을 해결하며 주어진 기능을 정리하고 설계하는 과정에서 Java와 객체지향에 대한 이점들을 확인할 수 있었고, 다양한 피드백을 통해 현재 방식에 대해 점검하고 개선할 수 있는 기회로 다가왔습니다. 이전 1년의 학습과는 전혀 다른 방향의 학습 이었지만 단기간에 많은 지식과 앞으로 나아가야할 방향성에 대한 답을 얻을 수 있게 되었습니다.\n>\n> 프리코스 기간 동안 주된 학습 방법은 개발 서적입니다. 특히 오브젝트와 클린 코드를 읽으며 피드백의 의도를 책을 통해 더 구체적인 내용으로 확인할 수 있었고, 모던 자바 인 액션을 통해 Java 8에서 적용할 수 있는 다양한 문법에 대해 학습하였습니다. 관련 내용과 고민 과정들을 한 순간의 기억으로 남기지 않기 위해 꾸준한 기록도 진행하였습니다.\n>\n> 3주전의 나와 현재의 나를 비교한다면 당당하게 성장했다고 말할 수 있습니다. 앞으로 펼쳐진 길은 매우 험난하고 어려울 것으로 예상되지만 3주간의 경험을 통해 충분히 극복할 수 있다고 생각합니다. 미션을 통해 또 다른 배움의 즐거움을 준 프리코스에게 감사합니다.\n\n### 프리코스 최종 코딩 테스트\n\n2021년 12월 18일 최종 코딩 테스트를 진행하였다. 5시간의 긴 시간 동안 프리코스 기간 동안 학습한 것들을 활용하여 주어진 요구사항을 정리하고 구현해야 한다. \n\n실제 제출한 코드는 [[페어매칭관리 애플리케이션] 최기현 미션 제출합니다.](https://github.com/woowacourse/java-pairmatching-precourse/pull/3) 에서 확인할 수 있다.\n\n사실 이제서야 후기를 작성하는 것은 최종 코딩 테스트가 만족스럽지 않았기 때문이다. 시간안에 모든 기능을 구현하지 못했고, 문제에서 주어진 기본적인 테스트도 실수로 인해 체크하지 못했다. 해당하는 코드를 다시 마주하기에는 자신이 없었다.\n\n최대한 행위에 초점을 맞춰 각자의 역할을 부여하도록 노력하였다. 특히 해당하는 객체의 검증은 객체 내부에서 진행하였고, 만약 이러한 책임이 커진다면 객체를 나누어 책임을 전달하였다. \n\n## 최종 합격!\n\n![](https://user-images.githubusercontent.com/59357153/147727116-2ca4c477-197c-4ab2-8bda-c0c48b4db7e2.jpeg)\n\n드디어 합격 메일을 받게 되었다! 올해 가장 큰 선물을 받은 것 같아 너무 기쁜 나머지 눈물도 조금 흘린 것 같다.\n\n본격적인 교육은 2월 부터 시작이라고 한다. 그전까지는 공부보다는 자신을 돌아보는 시간을 주로 가져야 겠다. 평소 못했던 것들을 하나, 둘 처리하며 마음의 여유를 가질 예정이다.\n"},{"excerpt":"미션 - 자판기 우아한테크코스 4기 프리코스 3주차 미션을 진행하며 고민한 내용을 정리하고 추가적인 개인 목표를 세워 정리해보았다.  미션 - 자동차 경주 게임 제출 코드 목차 1. 시작하기 전 2. 구현 목록 정리 3. Can’t automatically merge 4. MVC 패턴 5. 비즈니스 로직과 UI 로직 분리 6. Stream 활용 7. en…","fields":{"slug":"/precourse-3/"},"frontmatter":{"date":"November 15, 2021","title":"프리코스 3주차","tags":["우아한테크코스","프리코스"]},"rawMarkdownBody":"\n## 미션 - 자판기\n\n우아한테크코스 4기 프리코스 3주차 미션을 진행하며 고민한 내용을 정리하고 추가적인 개인 목표를 세워 정리해보았다. \n\n * [미션 - 자동차 경주 게임](https://github.com/hyeonic/java-vendingmachine-precourse)\n * [제출 코드](https://github.com/hyeonic/java-vendingmachine-precourse/tree/hyeonic)\n\n## 목차\n\n * [1. 시작하기 전](#_1-시작하기-전)\n * [2. 구현 목록 정리](#_2-구현-목록-정리)\n * [3. Can’t automatically merge](#_1-can-t-automatically-merge)\n * [4. MVC 패턴](#_4-mvc-패턴)\n * [5. 비즈니스 로직과 UI 로직 분리](#_5-비즈니스-로직과-ui-로직-분리)\n * [6. Stream 활용](#_6-stream-활용)\n * [7. enum](#_7-enum)\n * [8. 객체에게 메시지 보내기](#_8-객체에게-메시지-보내기)\n * [9. 과도한 검증 코드와 책임의 이전](#_9-과도한-검증-코드와-책임의-이전)\n * [References](#references)\n\n## 1. 시작하기 전\n\n이번 주차에는 다시 한 번 초심으로 돌아가 기존에 주어진 `1, 2차 피드백`을 최대한 수용하고 객체의 `결합도는 줄이고 응집도를 높이기` 위해 노력하였다. \n\n3차 미션은 확실히 1, 2차보다 난이도가 높다는 느낌이 들었다. 이전에는 객체의 역할이 뚜렷하게 머리에 그려졌지만 다소 복잡한 자판기 로직으로 인해 객체에게 적절한 `역할`과 `책임`을 부여하는데 오랜 시간이 걸렸다. \n\n또한 현재 진행하고 있는 방식이 적절한지 끊임 없이 의심하였다. 특히 객체의 `응집도`를 높이기 위해 단순히 반복되는 검증 코드들을 남발하는 것이 아닌지 고민이 되었다. 이것은 결국 좋은 설계를 위한 `트레이드 오프`의 과정이라고 생각된다.\n\n## 2. 구현 목록 정리\n\n2주차 공통 피드백에는 아래와 같은 내용이 담겨 있었다.\n\n> 기능 목록 구현을 재검토한다\n\n> 기능 목록을 클래스 설계와 구현, 함수(메서드) 설계와 구현과 같이 너무 상세하게 작성하지 않는다. 클래스 이름, 함수(메서드) input/output은 언제든지 변경될 수 있기 때문이다. 너무 세세한 부분까지 정리하기보다 구현해야 할 기능 목록을 정리하는 데 집중한다. **정상적인 경우도 중요하지만, 예외적인 상황도 기능 목록에 정리** 한다. 특히 예외 상황은 시작단계에서 모두 찾기 힘들기 때문에 기능을 구현하면서 계속해서 추가해 나간다.\n\n#### 기능 목록 작성 예시\n- 사용자가 입력한 이름은 쉼표 기준으로 분리해야 한다.\n- 사용자 이름이 5자 이하인지 검증해야 한다.\n- 자동차는 4 이상인 경우 전진한다.\n- 자동차는 4 미만인 경우 정지한다.\n- 0 ~ 9 사이의 임의의 값을 생성한다.\n- 여러 대의 자동차 중 최대 위칫값을 구한다.\n- 최대 위칫값에 해당하는 자동차 목록을 구한다.\n\n우선 구현해야 할 기능 목록을 정리하는 데 집중하기 위해 노력하였다. 기능 목록을 작성하고 개발을 진행하던 중에도 계속해서 고려해야 할 예외나 요구사항들이 생겨 났다. 그럴 때 마다 적절히 수정하여 `살아 있는 문서`를 만들기 위해 노력하였다.\n\n<details>\n<summary>ver 0.1 기능 목록</summary>\n\n반환되는 동전이 최소한이 되는 자판기를 구현한다.\n\n### 1. 보유 금액\n * [ ] 보유 금액을 `입력` 받는다.\n * [ ] 보유 금액은 `정수`이다.\n * [ ] 보유 금액은 `음수가 될 수 없다.`\n * [ ] 보유 금액은 `10으로 나누어 떨어져야 한다.`\n * [ ] 보유 금액으로 동전을 `무작위`로 생성한다.\n * [ ] 생성이 완료되면 동전 별 보유 개수를 `출력`한다. 보유 개수가 0개인 경우에도 출력을 진행한다.\n \n### 2. 투입 금액\n * [ ] 투입 금액을 `입력` 받는다.\n * [ ] 투입 금액은 `정수`이다.\n * [ ] 투입 금액은 `음수가 될 수 없다.`\n * [ ] 투입 금액은 `10으로 나누어 떨어져야 한다.`\n * [ ] 투입 금액으로는 동전을 생성하지 않는다.\n\n### 3. 상품\n * [ ] `상품명`, `가격`, `수량`을 `입력`하여 상품을 추가한다.\n * [ ] 개별 상품은 대괄호`[]`로 묶어 세미콜론`;`으로 구분한다. ex) `[콜라,1500,20];[사이다,1000,10]`\n * [ ] 개별 상품은 `대괄호`로 묶여 있어야 한다.\n * [ ] 상품이 한 개 이상인 경우 `세미콜론`으로 구분되어야 한다.\n * [ ] 상품 가격은 `100원 부터 시작`하며, `10원으로 나누어 떨어져야 한다.`\n\n### 4. 구매\n * [ ] 상품 구매를 위해 상품명을 `입력`한다.\n * [ ] `상품이 존재하지 않는 경우` 예외를 던지고 재입력을 진행한다.\n * [ ] 상품 구매를 진행 할 때 `현재 투입 금액`이 `출력`된다.\n\n### 5. 잔돈 반환\n * [ ] 구매가 완료되면 `잔돈을 반환`한다.\n * [ ] 남은 금액이 `상품의 최저 가격보다 적거나`, `모든 상품이 소진된 경우` 바로 잔돈을 돌려준다.\n * [ ] 잔돈을 반환할 수 없는 경우 잔돈으로 `반환할 수 있는 금액만 반환`한다.\n * [ ] 현재 투입 금액을 출력하고 `투입 금액의 최소 개수의 동전`으로 잔돈을 돌려준다.\n * [ ] 반환되지 않은 금액은 자판기에 남는다.\n</details>\n\n<details>\n<summary>ver 0.2 기능 목록</summary>\n\n반환되는 동전이 최소한이 되는 자판기를 구현한다.\n\n### 1. 보유 금액\n * [ ] 보유 금액을 `입력` 받는다.\n * [ ] 보유 금액은 `정수`이다.\n * [ ] 보유 금액은 `음수가 될 수 없다.`\n * [ ] 보유 금액은 `10으로 나누어 떨어져야 한다.`\n * [ ] 보유 금액으로 동전을 `무작위`로 생성한다.\n * [ ] 생성이 완료되면 동전 별 보유 개수를 `출력`한다. 보유 개수가 0개인 경우에도 출력을 진행한다.\n\n### 2. 상품\n* [ ] `상품명`, `가격`, `수량`을 `입력`하여 상품을 추가한다.\n* [ ] `개별 상품`은 대괄호`[]`로 묶어 세미콜론`;`으로 구분한다. ex) `[콜라,1500,20];[사이다,1000,10]`\n* [ ] 상품이 한 개 이상인 경우 `세미콜론`으로 구분되어야 한다.\n* [ ] `개별 상품`은 `대괄호`로 묶여 있어야 한다. \n* [ ] `상품의 이름`이 `비어있는 경우` 예외를 던진다. ex) `` ✚\n* [ ] `상품의 이름`이 `공백인 경우` 예외를 던진다. ex) ` ` ✚\n* [ ] `상품의 가격`은 `정수`이다. ✚\n* [ ] `상품의 가격`은 `음수가 될 수 없다.` ✚\n* [ ] `상품의 가격`은 `100원 부터 시작`한다. ✚\n* [ ] `상품의 가격`은 `10원으로 나누어 떨어져야 한다.` ✚\n* [ ] `상품의 수량`은 `정수`이다. ✚\n* [ ] `상품의 수량`은 `음수가 될 수 없다.` ✚\n\n### 3. 투입 금액\n * [ ] 투입 금액을 `입력` 받는다.\n * [ ] 투입 금액은 `정수`이다.\n * [ ] 투입 금액은 `음수가 될 수 없다.`\n * [ ] 투입 금액은 `10으로 나누어 떨어져야 한다.`\n * [ ] 투입 금액으로는 동전을 생성하지 않는다.\n\n### 4. 구매\n * [ ] 상품 구매를 위해 상품명을 `입력`한다.\n * [ ] `상품이 존재하지 않는 경우` 예외를 던지고 재입력을 진행한다.\n * [ ] 상품 구매를 진행 할 때 `현재 투입 금액`이 `출력`된다.\n\n### 5. 잔돈 반환\n * [ ] 구매가 완료되면 `잔돈을 반환`한다.\n * [ ] 남은 금액이 `상품의 최저 가격보다 적거나`, `모든 상품이 소진된 경우` 바로 잔돈을 돌려준다.\n * [ ] 잔돈을 반환할 수 없는 경우 잔돈으로 `반환할 수 있는 금액만 반환`한다.\n * [ ] 현재 투입 금액을 출력하고 `투입 금액의 최소 개수의 동전`으로 잔돈을 돌려준다.\n * [ ] 반환되지 않은 금액은 자판기에 남는다.\n\n## ver 0.3 기능 목록\n반환되는 동전이 최소한이 되는 자판기를 구현한다.\n\n### 1. 보유 금액\n * [ ] 보유 금액을 `입력` 받는다.\n * [ ] 보유 금액은 `정수`이다.\n * [ ] 보유 금액은 `음수가 될 수 없다.`\n * [ ] 보유 금액은 `10으로 나누어 떨어져야 한다.`\n * [ ] 보유 금액으로 동전을 `무작위`로 생성한다.\n * [ ] 생성이 완료되면 동전 별 보유 개수를 `출력`한다. 보유 개수가 0개인 경우에도 출력을 진행한다.\n\n### 2. 상품\n* [ ] `상품명`, `가격`, `수량`을 `입력`하여 상품을 추가한다.\n* [ ] `개별 상품`은 대괄호`[]`로 묶어 세미콜론`;`으로 구분한다. ex) `[콜라,1500,20];[사이다,1000,10]`\n* [ ] 상품이 한 개 이상인 경우 `세미콜론`으로 구분되어야 한다.\n* [ ] `개별 상품`은 `대괄호`로 묶여 있어야 한다. \n* [ ] `상품의 이름`이 `비어있는 경우` 예외를 던진다. ex) ``\n* [ ] `상품의 이름`이 `공백인 경우` 예외를 던진다. ex) ` `\n* [ ] `상품의 가격`은 `정수`이다.\n* [ ] `상품의 가격`은 `음수가 될 수 없다.`\n* [ ] `상품의 가격`은 `100원 부터 시작`한다.\n* [ ] `상품의 가격`은 `10원으로 나누어 떨어져야 한다.`\n* [ ] `상품의 수량`은 `정수`이다.\n* [ ] `상품의 수량`은 `음수가 될 수 없다.`\n\n### 3. 투입 금액\n * [ ] 투입 금액을 `입력` 받는다.\n * [ ] 투입 금액은 `정수`이다.\n * [ ] 투입 금액은 `음수가 될 수 없다.`\n * [ ] 투입 금액은 `10으로 나누어 떨어져야 한다.`\n * [ ] 투입 금액으로는 동전을 생성하지 않는다.\n\n### 4. 구매\n * [ ] 상품 구매를 위해 상품명을 `입력`한다.\n * [ ] `구매 상품의 이름`이 `비어있는 경우` 예외를 던진다. ✚\n * [ ] `구매 상품의 이름`이 `공백인 경우` 예외를 던진다. ✚\n * [ ] `상품이 존재하지 않는 경우` 예외를 던지고 재입력을 진행한다.\n * [ ] 상품 구매를 진행 할 때 `현재 투입 금액`이 `출력`된다.\n\n### 5. 잔돈 반환\n * [ ] 구매가 완료되면 `잔돈을 반환`한다.\n * [ ] 남은 금액이 `상품의 최저 가격보다 적거나`, `모든 상품이 소진된 경우` 바로 잔돈을 돌려준다.\n * [ ] 잔돈을 반환할 수 없는 경우 잔돈으로 `반환할 수 있는 금액만 반환`한다.\n * [ ] 현재 투입 금액을 출력하고 `투입 금액의 최소 개수의 동전`으로 잔돈을 돌려준다.\n * [ ] 반환되지 않은 금액은 자판기에 남는다.\n</details>\n\n<details>\n<summary>ver 0.4 기능 목록</summary>\n\n### 1. 보유 금액\n * [ ] 보유 금액을 `입력` 받는다.\n * [ ] 보유 금액은 `정수`이다.\n * [ ] 보유 금액은 `음수가 될 수 없다.`\n * [ ] 보유 금액은 `10으로 나누어 떨어져야 한다.`\n * [ ] 보유 금액으로 동전을 `무작위`로 생성한다.\n * [ ] 생성이 완료되면 동전 별 보유 개수를 `출력`한다. 보유 개수가 0개인 경우에도 출력을 진행한다.\n\n### 2. 상품\n * [ ] `상품명`, `가격`, `수량`을 `입력`하여 상품을 추가한다.\n * [ ] `개별 상품`은 대괄호`[]`로 묶어 세미콜론`;`으로 구분한다. ex) `[콜라,1500,20];[사이다,1000,10]`\n * [ ] 상품이 한 개 이상인 경우 `세미콜론`으로 구분되어야 한다.\n * [ ] `개별 상품`은 `대괄호`로 묶여 있어야 한다.\n * [ ] `상품의 이름`이 `비어있는 경우` 예외를 던진다. ex) ``\n * [ ] `상품의 이름`이 `공백인 경우` 예외를 던진다. ex) ` `\n * [ ] `상품의 가격`은 `정수`이다.\n * [ ] `상품의 가격`은 `음수가 될 수 없다.`\n * [ ] `상품의 가격`은 `100원 부터 시작`한다.\n * [ ] `상품의 가격`은 `10원으로 나누어 떨어져야 한다.`\n * [ ] `상품의 수량`은 `정수`이다.\n * [ ] `상품의 수량`은 `음수가 될 수 없다.`\n\n### 3. 투입 금액\n * [ ] 투입 금액을 `입력` 받는다.\n * [ ] 투입 금액은 `정수`이다.\n * [ ] 투입 금액은 `음수가 될 수 없다.`\n * [ ] 투입 금액은 `10으로 나누어 떨어져야 한다.`\n * [ ] 투입 금액으로는 동전을 생성하지 않는다.\n\n### 4. 구매\n * [ ] 상품 구매를 위해 상품명을 `입력`한다.\n * [ ] `구매 상품의 이름`이 `비어있는 경우` 예외를 던진다.\n * [ ] `구매 상품의 이름`이 `공백인 경우` 예외를 던진다.\n * [ ] `상품이 존재하지 않는 경우` 예외를 던지고 재입력을 진행한다.\n * [ ] 상품 구매를 진행 할 때 `현재 투입 금액`이 `출력`된다.\n * [ ] 투입 금액이 `구매 가능한 상품의 최저 가격보다 적거나`, `모든 상품이 소진된 경우` 구매가 불가능 하다. ✚\n\n### 5. 잔돈 반환\n * [ ] 구매가 완료되면 `잔돈을 반환`한다.\n * [ ] 잔돈을 반환할 수 없는 경우 잔돈으로 `반환할 수 있는 금액만 반환`한다.\n * [ ] 현재 투입 금액을 출력하고 `투입 금액의 최소 개수의 동전`으로 잔돈을 돌려준다.\n * [ ] 반환되지 않은 금액은 자판기에 남는다.\n</details>\n\n<details>\n<summary>ver 0.5 기능 목록</summary>\n\n### 1. 보유 금액\n * [ ] 보유 금액을 `입력` 받는다.\n * [ ] 보유 금액은 `정수`이다.\n * [ ] 보유 금액은 `음수가 될 수 없다.`\n * [ ] 보유 금액은 `10으로 나누어 떨어져야 한다.`\n * [ ] 보유 금액으로 동전을 `무작위`로 생성한다.\n * [ ] 생성이 완료되면 동전 별 보유 개수를 `출력`한다. 보유 개수가 0개인 경우에도 출력을 진행한다.\n\n### 2. 상품\n * [ ] `상품명`, `가격`, `수량`을 `입력`하여 상품을 추가한다.\n * [ ] `개별 상품`은 대괄호`[]`로 묶어 세미콜론`;`으로 구분한다. ex) `[콜라,1500,20];[사이다,1000,10]`\n * [ ] 상품이 한 개 이상인 경우 `세미콜론`으로 구분되어야 한다.\n * [ ] `개별 상품`은 `대괄호`로 묶여 있어야 한다.\n * [ ] `개별 상품`의 형식이 잘못된 경우 예외를 던진다. ex) `[콜라,1500,20][콜라,1500,20]`, `[콜라,1500]`\n * [ ] `상품의 이름`이 `비어있는 경우` 예외를 던진다. ex) ``\n * [ ] `상품의 이름`이 `공백인 경우` 예외를 던진다. ex) ` `\n * [ ] `상품의 이름`은 중복될 수 없다. 중복된 경우 예외를 던진다. ✚\n * [ ] `상품의 가격`은 `정수`이다.\n * [ ] `상품의 가격`은 `음수가 될 수 없다.`\n * [ ] `상품의 가격`은 `100원 부터 시작`한다.\n * [ ] `상품의 가격`은 `10원으로 나누어 떨어져야 한다.`\n * [ ] `상품의 수량`은 `정수`이다.\n * [ ] `상품의 수량`은 `음수가 될 수 없다.`\n * [ ] `상품의 수량`은 적어도 `1개 이상`이다. ✚\n\n### 3. 투입 금액\n * [ ] 투입 금액을 `입력` 받는다.\n * [ ] 투입 금액은 `정수`이다.\n * [ ] 투입 금액은 `음수가 될 수 없다.`\n * [ ] 투입 금액은 `10으로 나누어 떨어져야 한다.`\n * [ ] 투입 금액으로는 동전을 생성하지 않는다.\n * [ ] 투입 금액으로 `제공된 상품을 구매할 수 없는 경우(구매 가능 상품 최저가 보다 적은 경우)` 예외를 던진다. ✚\n\n### 4. 구매\n * [ ] 상품 구매를 위해 상품명을 `입력`한다.\n * [ ] `구매 상품의 이름`이 `비어있는 경우` 예외를 던진다.\n * [ ] `구매 상품의 이름`이 `공백인 경우` 예외를 던진다.\n * [ ] `상품이 존재하지 않는 경우` 예외를 던지고 재입력을 진행한다.\n * [ ] 상품 구매를 진행 할 때 `현재 투입 금액`이 `출력`된다.\n * [ ] 투입 금액이 `구매 가능한 상품의 최저 가격보다 적거나`, `모든 상품이 소진된 경우` 구매가 불가능 하다.\n\n### 5. 잔돈 반환\n * [ ] 구매가 완료되면 `잔돈을 반환`한다.\n * [ ] 잔돈을 반환할 수 없는 경우 잔돈으로 `반환할 수 있는 금액만 반환`한다.\n * [ ] 현재 투입 금액을 출력하고 `투입 금액의 최소 개수의 동전`으로 잔돈을 돌려준다.\n * [ ] 반환되지 않은 금액은 자판기에 남는다.\n</details>\n\n## 3. Can’t automatically merge\n\n미션 해결 중간에 테스트 코드의 수정으로 `upstream repository`에 수정에 관련된 `commit`이 추가되었다. 변경된 소스 코드를 반영하지 않고 직접 수정할 경우 `Pull Request`를 진행할 때 `Can’t automatically merge.`문구를 확인할 수 있다.\n\n변경에 관련된 공지 메일에서도 이와 같은 설명을 언급하고 있다. 즉 소스 코드 `병합`을 통해 이것을 해결해야 한다.\n\n### git rebase\n\n병합하는 방법에는 크게 merge를 활용하는 방법과 `rebase`를 활용하는 방법이 있다. 그 중 `rebase`를 활용하여 적용해보려 한다.\n\n`rebase`는 merge관련 commit을 추가적으로 생성하지 않고 해당 branch의 `base를 다시 설정`한다. 그렇기 때문에 소스 코드가 수정되어도 수정된 commit을 `중간에 반영`하고 해당 branch의 base를 재 정리한다.\n\n이러한 rebase를 사용하면 깔끔한 commit 히스토리를 유지할 수 있다.\n\n## 4. MVC 패턴\n\nMVC은 Model-View-Controller의 약자로 하나의 애플리케이션을 구성할 때 구성 요소를 세가지의 역할로 구분한 개발 방법론이다. 특히 소프트웨어의 `비즈니스 로직과 화면을 구분`하는데 중점을 두고 있다. 이러한 `관심사의 분리`는 객체가 각자의 책임을 가질 수 있도록 도와준다.\n\n또한 MVC 패턴을 사용하면 Model과 View가 다른 컴포넌트들에 종속되지 않아 변경에 유리하다는 장점을 가진다.\n\n### Model\n\n내부 비즈니스 로직을 처리하기 위한 역할을 한다. Model은 다른 컴포넌트(ex View, Controller)들에 대해 알지 못한다. `자기 자신이 무엇을 수행하는지`만 알고 있다.\n\n### View\n\n화면(ex 웹, console 등)에 `무엇`을 보여주기 위한 역할이다. Model이 처리한 데이터나 그 작ㅇ버 결과를 가지고 사용자에게 출력할 화면을 만든다. View 또한 다른 컴포넌트들에 대해 알지 못한다. 단순히 자신이 무엇을 수행하는지만 알고 있다. \n\n### Controller\n\nModel과 View 사이에 있는 컴포넌트이다. Model이 데이터를 `어떻게 처리`할지 알려주는 역할이다. 클라이언트의 요청을 받으면 해당 요청에 대한 실제 업무를 수행하기 위해 Model을 호출한다. Model이 업무 수행을 완료하면 그 결과를 가지고 화면을 생성하기 위해 View에 전달한다. 클라이언트의 요청에 대해 Model과 View를 결정하여 전달하는 일종의 조정자로서의 일을 진행한다.\n\n`Controller는 다른 컴포넌트들에 대해 알고 있다.` 자기 자신 외에 Model과 View가 무엇을 수행하는지 알고 있다.\n\n## 5. 비즈니스 로직과 UI 로직 분리\n\n### 비즈니스 로직과 UI 로직을 분리해라\n\n비즈니스 로직과 UI 로직을 한 클래스가 담당하지 않도록 한다. 단일 책임의 원칙에도 위배된다.\n\n```java\npublic class Car {\n    private int position;\n\n    // 자동차 이동 여부를 결정하는 비즈니스 로직\n    public void move(int randomValue) {\n        ...\n    }\n\n    // UI 로직\n    private void print(int position) {\n        StringBuilder sb = new StringBuilder();\n        ...\n    }\n}\n```\n\n현재 객체의 상태를 보기 위한 로그 메시지 성격이 강하다면 `toString()`을 통해 구현한다. View에서 사용할 데이터라면 getter 메서드를 통해 데이터를 전달한다.\n\n위 내용은 2주차 공통 피드백의 일부분이다. MVC 패턴을 기반으로 `비즈니스 로직`과 `UI 로직`을 한 클래스가 담당하지 않도록 노력하였다.\n\n```java\npublic class PossessionCoin {\n    private static final int DEFAULT_QUANTITY = 0;\n    private static final String TO_STRING_FORMAT = \"%d원 - %d개\";\n\n    private final Coin coin;\n    private final int quantity;\n\n    public PossessionCoin(Coin coin, int quantity) {\n        this.coin = coin;\n        this.quantity = quantity;\n    }\n\n    public Coin getCoin() {\n        return coin;\n    }\n\n    public boolean isExistQuantity() {\n        return quantity > DEFAULT_QUANTITY;\n    }\n\n    public int calculatePossibleQuantity(InvestmentMoney investmentMoney) {\n        return investmentMoney.trade(coin.getAmount(), quantity);\n    }\n\n    @Override\n    public String toString() {\n        return String.format(TO_STRING_FORMAT, coin.getAmount(), quantity);\n    }\n}\n```\n\n위 코드는 실제 미션 코드의 일부분을 가져온 것이다. 모델의 성격을 띄는 `PossessionCoin`이 `UI로직`을 가지지 않도록 조정하였다. 단순히 객체의 상태를 로그 메시지로 만들기 위해 `toString`을 활용하여 구현하였다.\n\n## 6. Stream 활용\n\n미션을 진행하며 `메서드 15라인`과 `depth의 제한`을 지키기 위해 노력하였다. 그 중 depth를 지키기 위해 단순 반복문을 사용하기 보다 `Stream`을 활용하여 해결하기 위해 노력하였다.\n\n그중 가장 기억에 남는 리팩터링을 하나 소개해보려 한다.\n\n### 반복문을 활용한 잔돈 계산\n\n```java\npublic class PossessionCoins {\n    List<PossessionCoin> possessionCoins;\n\n    public PossessionCoins(List<PossessionCoin> possessionCoins) {\n        this.possessionCoins = possessionCoins;\n    }\n\n    public List<PossessionCoin> getPossessionCoins() {\n        return Collections.unmodifiableList(possessionCoins);\n    }\n\n    public List<Change> takeChange(InvestmentMoney investmentMoney) {\n        List<Change> changes = new ArrayList<>();\n\n        for (PossessionCoin possessionCoin : possessionCoins) {\n            Coin coin = possessionCoin.getCoin();\n            if (possessionCoin.isExistQuantity() && investmentMoney.isPossibleChange(coin)) {\n                int coinQuantity = possessionCoin.calculate(investmentMoney);\n                changes.add(new Change(coin, coinQuantity));\n            }\n        }\n\n        return changes;\n    }\n}\n```\n\n위 코드는 보유 동전 리스트를 가지고 있는 일급 컬렉션이다. 잔돈 계산을 위해서는 `takeChange` 메서드를 활용하여 잔돈 리스트를 반환 받아야 한다. \n\n최초에 단순 `반복문`을 활용하여 검증을 진행하고 잔돈 개수를 계산하여 잔돈 리스트에 추가하는 로직으로 구성하였다. 하지만 메서드에 많은 기능을 담고 있으며 검증을 위한 `if`가 `&&`의 사용으로 직관적이지 않게 느껴졌다. 위 코드는 `메서드가 한 가지 일만 잘하도록 개선`하고, 로직의 `직관성을 높여야 한다는 필요성`을 느끼게 되었다.\n\n### 개선된 잔돈 계산\n\n```java\npublic class PossessionCoins {\n    List<PossessionCoin> possessionCoins;\n\n    public PossessionCoins(List<PossessionCoin> possessionCoins) {\n        this.possessionCoins = possessionCoins;\n    }\n\n    public List<PossessionCoin> getPossessionCoins() {\n        return Collections.unmodifiableList(possessionCoins);\n    }\n\n    public List<Change> takeChange(InvestmentMoney investmentMoney) {\n        return possessionCoins.stream()\n            .filter(PossessionCoin::isExistQuantity)\n            .filter(investmentMoney::isPossibleChange)\n            .map(possessionCoin -> getChange(investmentMoney, possessionCoin))\n            .collect(toList());\n    }\n\n    private Change getChange(InvestmentMoney investmentMoney, PossessionCoin possessionCoin) {\n        int coinQuantity = possessionCoin.calculatePossibleQuantity(investmentMoney);\n        return new Change(possessionCoin.getCoin(), coinQuantity);\n    }\n}\n```\n\nStream을 활용하여 개선한 `takeChange`이다. 우선 `getChange`을 활용하여 메서드를 분리하였다. 또한 stream의 활용으로 depth를 1까지 줄일 수 있게 되었다. \n\n이제 보유 동전을 탐색하며 `filter`를 활용한 검증을 진행한다. 그 다음 역할은 나눈 `getChange`를 통해 `mapping`을 진행한 뒤 종료 연산인 `collect`를 통해 `List`를 반환한다. 이전에 복잡하게 얽힌 반복문과 검증 관련 로직을 `Stream`을 통해 `더 나은 가독성`을 갖추도록 노력하였다.\n\n## 7. enum\n\n이번 미션에는 동전을 나타내는 상수들이 열거 타입인 `Coin`으로 주어진다. 우선 이것이 의미하는 바를 파악하기 위해 `enum`의 등장 배경부터 살펴보았다.\n\nenum은 Java 1.5부터 등장하였다. 이전에는 상수 사용을 위해 `정수 열거 패턴`을 주로 사용하였다. 이것에는 아래와 같이 몇 가지 문제점을 가지고 있었다.\n\n * 상수에 부여된 러터럴은 상수와 관련이 없다.\n * 이름의 충돌이 발생할 수 있다.\n * 타입 안전을 보장하지 않고 표현력이 좋지 않다.\n\n정리하면 기존에 사용하던 상수 관리의 단점들을 보완하고 타입의 안정성과 IDE의 추가적인 지원을 받을 수 있다.\n\n### enum의 values 메서드\nenum에는 선언하지 않아도 다양한 메서드를 사용할 수 있다. 그 중 하나의 예시는 `values()` 이다. `values()` 메서드는 열거 형의 모든 값을 선언된 순서대로 모든 값을 포함하여 배열을 반환한다.\n\n아래와 같이 동전을 표현하는 enum `Coin`이 있다고 가정한다. \n```java\npublic enum Coin {\n    COIN_500(500),\n    COIN_100(100),\n    COIN_50(50),\n    COIN_10(10);\n\n    private final int amount;\n\n    Coin(final int amount) {\n        this.amount = amount;\n    }\n\n    public int getAmount() {\n        return amount;\n    }\n}\n```\n\n아래와 같이 활용 가능하다.\n```java\nfor (Coin coin : Coin.values()) {\n    System.out.println(coin);\n}\n```\n\n### 적용\n\n아래는 실제 미션 코드의 일부분을 가져온 것이다.\n\n```java\npublic enum Coin {\n    COIN_500(500),\n    COIN_100(100),\n    COIN_50(50),\n    COIN_10(10);\n\n    public static final ArrayList<Coin> COINS = new ArrayList<>(Arrays.asList(Coin.values()));\n    public static final String PREFIX = \"COIN_\";\n\n    private final int amount;\n\n    Coin(final int amount) {\n        this.amount = amount;\n    }\n\n    public static List<Integer> getCoinAmounts() {\n        return COINS.stream()\n            .map(coin -> coin.amount)\n            .collect(toList());\n    }\n\n    public static Coin parseCoin(int amount) {\n        return Coin.valueOf(PREFIX + amount);\n    }\n\n    public int getAmount() {\n        return amount;\n    }\n}\n```\n\nenum으로 인해 클래스와 같이 필드와 메서드들을 가질 수 있게 된다. 또한 Coin의 종류를 한정할 수 있기 때문에 추가적인 검증 과정을 줄일 수 있다.\n\n아래는 Coin을 인스턴스 필드로 활용하는 `PossessionCoin`이다. PossessionCoin은 현재 자판기가 보유하고 있는 동전의 타입과 수량을 나타낸다.\n\n```java\npublic class PossessionCoin {\n    private static final int DEFAULT_QUANTITY = 0;\n    private static final String TO_STRING_FORMAT = \"%d원 - %d개\";\n\n    private final Coin coin;\n    private final int quantity;\n\n    public PossessionCoin(Coin coin, int quantity) {\n        this.coin = coin;\n        this.quantity = quantity;\n    }\n    ...\n}\n```\n\n * `public PossessionCoin(Coin coin, int quantity)`: 생성자를 살펴보면 Coin 타입으로 받는 것을 확인할 수 있다. 만약 단순히 int로 해당 값을 받게 된다면 500, 100, 50, 10이 아닐 경우 `추가적인 검증`이 필요하게 된다. Coin으로 한정시키게 되면 선언한 상수들만 사용하여 해당 생성자를 활용하도록 `제한`할 수 있다.\n\n## 8. 객체에게 메시지 보내기\n\n이번 미션을 해결하면서 가장 지키기 어려웠던 사항이었다. 피드백의 일부분을 살펴보면 아래와 같다.\n\n### 객체에 메시지를 보내라\n상태 데이터를 가지는 객체에서 데이터를 꺼내려 (get)하지 말고 객체에게 메시지를 보내라. 예를 들어 Car가 우승자인지를 판단하기 위해 최대 이동 거리 값을 가지는 Car인지 판단 기능은?\n\n```java\nprivate boolean isMaxPosition(Car car) {\n    return car.getPosition() == maxDistance;\n}\n```\n\n위와 같이 구현하지 않고 다음과 같이 Car에게 메시지를 보내 구현한다.\n\n```java\ncar.isMaxPosition(maxDistance);\n```\n\n위 예제의 의도는 정확히 이해하였다. 하지만 실제 기능 사항을 정리하고 해결해가는 과정에서 getter를 활용하지 않고 로직을 처리하는 것은 많은 힘이 들었다. 그 중 가장 많은 고민을 진행한 것은 `상품의 가격과 투입 금액을 비교하는 부분`이다.\n\n### 상품을 관리하는 책임을 가진 Product\n\n아래는 자판기에 들어있는 상품 정보를 관리하기 위한 `Product`이다. 내부 인스턴스 변수들은 `원시 타입을 포장하고 있는 객체`를 사용하고 있다.\n\n```java\npublic class Product {\n    ...\n\n    private final Name name;\n    private final Price price;\n    private final Quantity quantity;\n\n    public Product(String inputProduct) {\n        ...\n        this.name = new Name(splitInputProduct[NAME_INDEX]);\n        this.price = new Price(splitInputProduct[PRICE_INDEX]);\n        this.quantity = new Quantity(splitInputProduct[QUANTITY_INDEX]);\n    }\n\n    ...\n\n    public String getName() {\n        return name.getName();\n    }\n\n    public int getPrice() {\n        return price.getPrice();\n    }\n\n    public boolean isSameName(String productPurchaseName) {\n        return this.name.isSame(productPurchaseName);\n    }\n\n    public void receive() {\n        if (!quantity.isExistQuantity()) {\n            throw new IllegalArgumentException(VALID_PRODUCT_QUANTITY);\n        }\n        quantity.decreaseQuantity();\n    }\n\n    public boolean isExistQuantity() {\n        return quantity.isExistQuantity();\n    }\n}\n```\n\n * `public boolean isSameName(String productPurchaseName)`: 외부에서 구입하기 위한 상품 이름을 전달 받아 동일 여부를 확인하고 반환한다.\n * `public boolean isExistQuantity()`: 상품의 수량의 존재 여부를 반환한다.\n\n위 두 메서드는 `Product`에게 메시지를 보내서 관련 로직을 처리하기 위해 노력하였다. 하지만 문제는 `getPrice`였다.\n\n### 투입 금액을 관리하는 책임을 가진 InvestmentMoney\n\n투입된 금액의 검증과 로직 처리를 위한 `InvestmentMoney`이다.\n\n```java\npublic class InvestmentMoney {\n    ...\n    private int investmentMoney;\n\n    public InvestmentMoney(String inputInvestmentMoney) {\n        ...\n        int investmentMoney = Integer.parseInt(inputInvestmentMoney);\n        ...\n        this.investmentMoney = investmentMoney;\n    }\n    ...\n    \n    public void calculate(int price) {\n        if (investmentMoney < price) {\n            throw new IllegalArgumentException(VALID_PRODUCT_PRICE);\n        }\n        investmentMoney -= price;\n    }\n\n    public boolean isPay(Product product) {\n        return investmentMoney >= product.getPrice();\n    }\n    ...\n}\n```\n\n`public boolean isPay(Product product)` 메서드는 Product를 전달 받아 해당 price를 꺼내 `지불 가능 여부를 반환`해야 한다. 결국 투입 금액과 상품 가격을 모두 알아야 지불 여부를 확인할 수 있기 때문에 조회를 위한 getter 없이 처리하기에는 무리가 있다고 판단하였다.\n\n단순히 `int price` 매개 변수로 받는다고 해도 결국 해당 메서드를 활용하는 부분에서 getter의 사용은 불가피하게 된다. 이러한 제한 사항들을 제외하고는 최대한 객체에게 메시지를 전달하여 처리할 수 있도록 노력하였다. \n\n메시지를 전달하는 목적은 결국 협력 안에서 객체가 수행하는 책임에 초점을 맞추기 위해서 이다. 이러한 메시지를 통해 객체는 책임을 갖게 된다. 좀 더 객체지향 패러다임에 맞게 작성을 위해서 `메시지가 객체를 결정`할 수 있도록 시선을 길러야 겠다.\n\n## 9. 과도한 검증 코드와 책임의 이전\n\n### Effective Java 아이템 49. 매개변수가 유효한지 검사하라\n\n> 메서드나 생성자를 작성할 때면 그 매개변수들에 어떤 제약이 있을지 생각해야 한다. 그 제약들을 문서화하고 메서드 코드 시작 부분에서 명시적으로 검사해야 한다. 이런 습관을 반드시 기르도록 하자. 그 노력은 유효성 검사가 실제 오류를 처음 걸러낼 때 충분히 보상 받을 것이다.\n>\n> *Effective Java 301p*\n\n위와 같은 내용을 확인하였고 객체 생성 시점에 올바르게 생성이 가능하도록 인스턴스 변수들을 검증하기 위해 다양한 검증 코드를 활용했다. \n\n이러한 검증 관련 코드들은 해당 객체의 인스턴스 변수와 관련된 메서드들 이기 때문에 내부에 위치하는 것이 알맞다고 판단 했다. 또한 `단순한 검증`의 경우 `메서드 추출`을 통해 직관적인 코드를 만들 수 있었다.\n\n아래는 검증 로직을 포함한 예시이다.\n```java\npublic class ProductPurchase {\n    private static final String VALID_EMPTY = \"[ERROR] 상품명이 비어있습니다.\";\n    private static final String VALID_BLANK = \"[ERROR] 상품명은 공백이 될 수 없습니다.\";\n\n    private final String name;\n\n    public ProductPurchase(String name) {\n        validateEmpty(name);\n        validateBlank(name);\n        this.name = name;\n    }\n\n    private void validateEmpty(String name) {\n        if (name.isEmpty()) {\n            throw new IllegalArgumentException(VALID_EMPTY);\n        }\n    }\n\n    private void validateBlank(String name) {\n        if (name.trim().isEmpty()) {\n            throw new IllegalArgumentException(VALID_BLANK);\n        }\n    }\n\n    public String getName() {\n        return name;\n    }\n}\n```\n\n메서드 추출은 비교적 간결하게 검증 로직을 표현할 수 있다. 하지만 이러한 검증 로직이 많아 지면 생성자와 검증과 관련된 메서드들이 반 이상을 차지하게 된다.\n\n아래는 실제 과도한 검증 로직으로 인해 `너무 많은 책임`을 부여한 것이 아닌지 고민하게 된 `Product`이다.\n\n### Product\n\n```java\npublic class Product {\n    ...\n    private final String name;\n    private final int price;\n    private int quantity;\n\n    public Product(String inputProduct) {\n        validateStartWithAndEndWith(inputProduct);\n        inputProduct = inputProduct.replace(INPUT_PRODUCT_PREFIX, EMPTY);\n        inputProduct = inputProduct.replace(INPUT_PRODUCT_SUFFIX, EMPTY);\n\n        String[] splitInputProduct = inputProduct.split(INPUT_PRODUCT_SPLIT_REGEX, INPUT_PRODUCT_SPLIT_LIMIT);\n        validateSplitInputProduct(splitInputProduct);\n\n        this.name = splitInputProduct[NAME_INDEX];\n        this.price = Integer.parseInt(splitInputProduct[PRICE_INDEX]);\n        this.quantity = Integer.parseInt(splitInputProduct[QUANTITY_INDEX]);\n    }\n\n    private void validateStartWithAndEndWith(String inputProduct) {\n        if (!(inputProduct.startsWith(INPUT_PRODUCT_PREFIX) && inputProduct.endsWith(INPUT_PRODUCT_SUFFIX))) {\n            throw new IllegalArgumentException();\n        }\n    }\n\n    private void validateSplitInputProduct(String[] splitInputProduct) {\n        validateName(splitInputProduct[NAME_INDEX]);\n        validatePrice(splitInputProduct[PRICE_INDEX]);\n        validateQuantity(splitInputProduct[QUANTITY_INDEX]);\n    }\n\n    private void validateName(String name) {\n        validateEmpty(name);\n        validateBlank(name);\n    }\n\n    private void validateEmpty(String name) {\n        if (name.isEmpty()) {\n            throw new IllegalArgumentException();\n        }\n    }\n\n    private void validateBlank(String name) {\n        if (name.trim().isEmpty()) {\n            throw new IllegalArgumentException();\n        }\n    }\n\n    private void validatePrice(String inputPrice) {\n        validateNumberFormat(inputPrice);\n        int price = Integer.parseInt(inputPrice);\n\n        validateNumberSize(price);\n        validateDivide(price);\n    }\n\n    private void validateNumberSize(int price) {\n        if (price < DEFAULT_PRICE) {\n            throw new IllegalArgumentException();\n        }\n    }\n\n    private void validateDivide(int price) {\n        if (price % PRICE_QUOTIENT != REMAINDER) {\n            throw new IllegalArgumentException();\n        }\n    }\n\n    private void validateQuantity(String inputQuantity) {\n        validateNumberFormat(inputQuantity);\n        int quantity = Integer.parseInt(inputQuantity);\n        validateNegativeNumber(quantity);\n    }\n\n    private void validateNumberFormat(String input) {\n        try {\n            Integer.parseInt(input);\n        } catch (NumberFormatException e) {\n            throw new IllegalArgumentException();\n        }\n    }\n\n    private void validateNegativeNumber(int quantity) {\n        if (quantity < DEFAULT_QUANTITY) {\n            throw new IllegalArgumentException();\n        }\n    }\n    ...\n}\n```\n\n비즈니스 로직을 제외한 검증 코드만 100줄이 넘게 채워져 있다. 이것을 개선하기 위해 `원시 타입이 포장된 객체를 활용`하여 `객체의 책임을 이전`하였다.\n\n### Name\n\n상품 이름에 관한 책임을 가지는 `Name`이다. `관련 검증` 또한 `해당 객체로 이동`하게 된다.\n\n```java\npublic class Name {\n    private static final String VALID_EMPTY = \"[ERROR] 상품 이름이 비어있습니다.\";\n    private static final String VALID_BLANK = \"[ERROR] 상품 이름이 공백입니다.\";\n\n    private final String name;\n\n    public Name(String name) {\n        validateEmpty(name);\n        validateBlank(name);\n        this.name = name;\n    }\n\n    private void validateEmpty(String name) {\n        if (name.isEmpty()) {\n            throw new IllegalArgumentException(VALID_EMPTY);\n        }\n    }\n\n    private void validateBlank(String name) {\n        if (name.trim().isEmpty()) {\n            throw new IllegalArgumentException(VALID_BLANK);\n        }\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public boolean isSame(String name) {\n        if (this.name.equals(name)) {\n            return true;\n        }\n        return false;\n    }\n}\n```\n\nProduct의 다른 `인스턴스 변수(Price, Quantity)`들도 동일하게 객체로 포장하여 `책임을 이전`하였다.\n\n### 개선된 Product\n\n```java\npublic class Product {\n    ...\n    private final Name name;\n    private final Price price;\n    private final Quantity quantity;\n\n    public Product(String inputProduct) {\n        validateStartWithAndEndWith(inputProduct);\n        inputProduct = inputProduct.replace(INPUT_PRODUCT_PREFIX, EMPTY);\n        inputProduct = inputProduct.replace(INPUT_PRODUCT_SUFFIX, EMPTY);\n\n        String[] splitInputProduct = inputProduct.split(INPUT_PRODUCT_SPLIT_REGEX, INPUT_PRODUCT_SPLIT_LIMIT);\n        validateArrayLength(splitInputProduct.length);\n\n        this.name = new Name(splitInputProduct[NAME_INDEX]);\n        this.price = new Price(splitInputProduct[PRICE_INDEX]);\n        this.quantity = new Quantity(splitInputProduct[QUANTITY_INDEX]);\n    }\n\n    private void validateStartWithAndEndWith(String inputProduct) {\n        if (!(inputProduct.startsWith(INPUT_PRODUCT_PREFIX) && inputProduct.endsWith(INPUT_PRODUCT_SUFFIX))) {\n            throw new IllegalArgumentException(VALID_START_END_WITH);\n        }\n    }\n\n    private void validateArrayLength(int length) {\n        if (length != DEFAULT_STRING_SPLIT_LENGTH) {\n            throw new IllegalArgumentException(VALID_STRING_SPLIT_LENGTH);\n        }\n    }\n\n    public String getName() {\n        return name.getName();\n    }\n\n    public int getPrice() {\n        return price.getPrice();\n    }\n\n    public boolean isSameName(String productPurchaseName) {\n        if (this.name.isSame(productPurchaseName)) {\n            return true;\n        }\n        return false;\n    }\n\n    public void receive() {\n        if (!quantity.isExistQuantity()) {\n            throw new IllegalArgumentException(VALID_PRODUCT_QUANTITY);\n        }\n        quantity.decreaseQuantity();\n    }\n\n    public boolean isExistQuantity() {\n        if (quantity.isExistQuantity()) {\n            return true;\n        }\n        return false;\n    }\n}\n```\n\n이제 각 인스턴스 변수의 `검증 책임`이 개별 포장된 객체로 `이전`되었다. 이전 보다 훨씬 깔끔한 구조를 만들 수 있도록 노력하였다.\n\n### 정리\n\n검증 관련 코드를 메서드로 추출하고 더 나아가 `과도한 책임`이 부여되면 해당 `책임을 분리`한다.\n\n## References\n\n### MVC 패턴\n * [세상에서 제일 쉬운 MVC 패턴](https://log.hodol.dev/techcourse/mvc-pattern)\n * [웹 MVC 각 컴포넌트 역할](https://tecoble.techcourse.co.kr/post/2021-04-26-mvc/)\n\n### enum\n * [else 예약어를 쓰지 않는다](https://tecoble.techcourse.co.kr/post/2020-07-29-dont-use-else/)\n * [Class Enum](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Enum.html)\n\n### 과도한 검증 코드\n * [[JAVA] 객체 생성시 유효성 검사에 관하여](https://velog.io/@wannte/%EA%B0%9D%EC%B2%B4-%EC%83%9D%EC%84%B1%EC%8B%9C-%EC%9C%A0%ED%9A%A8%EC%84%B1-%EA%B2%80%EC%82%AC%EC%97%90-%EA%B4%80%ED%95%98%EC%97%AC)"},{"excerpt":"미션 - 자동차 경주 게임 우아한테크코스 4기 프리코스 2주차 미션을 진행하며 고민한 내용을 정리하고 추가적인 개인 목표를 세워 정리해보았다. 미션 - 자동차 경주 게임 제출 코드 목차 1. 살아 있는 문서 2. 구현 순서 맞추기 3. 매직 넘버, 매직 리터럴 4. Car, Strategy Pattern 적용 5. 캡슐화 6. String의 split 메…","fields":{"slug":"/precourse-2/"},"frontmatter":{"date":"November 08, 2021","title":"프리코스 2주차","tags":["우아한테크코스","프리코스"]},"rawMarkdownBody":"\n## 미션 - 자동차 경주 게임\n\n우아한테크코스 4기 프리코스 2주차 미션을 진행하며 고민한 내용을 정리하고 추가적인 개인 목표를 세워 정리해보았다.\n\n * [미션 - 자동차 경주 게임](https://github.com/woowacourse/java-racingcar-precourse)\n * [제출 코드](https://github.com/hyeonic/java-racingcar-precourse/tree/hyeonic)\n\n## 목차\n\n * [1. 살아 있는 문서](#_1-살아-있는-문서)\n * [2. 구현 순서 맞추기](#_2-구현-순서-맞추기)\n * [3. 매직 넘버, 매직 리터럴](#_3-매직-넘버-매직-리터럴)\n * [4. Car, Strategy Pattern 적용](#_4-car-strategy-pattern-적용)\n * [5. 캡슐화](#_5-캡슐화)\n * [6. String의 split 메서드](#_6-string의-split-메서드)\n * [7. String + 연산자보다 StringBuilder](#_7-string-연산자보다-stringbuilder)\n * [8. 모든 원시값과 문자열을 포장하라](#_7-모든-원시값과-문자열을-포장하라)\n * [9. 단위 테스트 명명법](#_8-단위-테스트-명명법)\n * [10. git rebase](#_10-git-rebase)\n * [References](#references)\n\n## 1. 살아 있는 문서\n\n아래는 1주차 공통 피드백에 담긴 내용들이다.\n\n### 기능 목록을 업데이트하라\nREADME.md 파일에 작성하는 기능 목록은 기능 구현을 하면서 `변경될 수 있다`. 시작할 때 모든 기능 목록을 완벽하게 정리해야 한다는 부담감을 가지기보다 기능을 구현하면서 문서를 `계속 업데이트`한다. 죽은 문서가 아니라 `살아 있는 문서`를 만들기 위해 노력한다.\n\n### 기능 목록을 재검토하라\n기능 목록을 클래스 설계와 구현, 함수(메서드) 설계와 구현과 같이 너무 `상세하게 작성하지 않는다.` 클래스 이름, 함수(메서드) 시그니처와 반환값은 언제든지 변경될 수 있기 때문이다. 너무 세세한 부분까지 정리하기 보다 구현해야 할 기능 목록을 정리하는 데 집중한다. **정상적인 경우도 중요하지만, 예외적인 상황도 기능 목록에 정리**한다. 특히 예외 상황은 시작 단계에서 모두 찾기 힘들기 때문에 기능을 구현하면서 계속해서 추가해 나간다.\n\n위와 같은 사항들을 확인할 수 있었다. 피드백을 기반으로 `살아 있는 문서`를 만들기 위해 노력한다.\n\n<details> \n<summary>ver 0.1 기능 목록</summary>\n\n### 1. 자동차\n * [ ] 자동차는 이름을 가질 수 있다.\n * [ ] 자동차의 이름은 `5자 이하`만 가능하다.\n * [ ] 자동차는 전진 또는 멈출 수 있다.\n * [ ] 0에서 9 사이에 무작위 값을 구한 후 무작위 값이 4 이상일 경우 전진한다.\n \n### 2. 입력\n * [ ] 경주할 자동차 이름을 입력 받는다.\n    * [ ] 경주할 자동차 이름은 쉼표를 기준으로 나눈다.\n    * [ ] 입력 받은 자동차 이름은 검증을 마친 후 List로 변환되어 전달한다.\n * [ ] 시도할 회수를 입력 받는다.\n \n### 3. 게임 실행\n * [ ] 레이싱 게임을 실행할 수 있다.\n * [ ] 레이싱 게임은 반복되지 않는다.\n\n### 4. 출력\n * [ ] 결과값 출력에 대한 전반적인 책임을 가진다.\n * [ ] `IllegalArgumentException`이 발생할 경우 `\"[ERROR]\"로 시작하는 에러 메시지 출력`을 진행한다.\n</details>\n\n<details>\n<summary>ver 0.2 기능 목록</summary>\n\n### 1. 자동차\n * [ ] 자동차는 이름을 가질 수 있다.\n * [ ] 자동차의 이름은 `5자 이하`만 가능하다.\n * [ ] 자동차는 전진 또는 멈출 수 있다.\n * [ ] 자동차는 이동 유무를 판단하는 `isMoving` 메서드를 가진 `MovingPolicy` 인터페이스를 가진다. ✚\n    * [ ] 자동차의 전진 유무는 `MovingPolicy`의 `isMoving`을 통해 확인한다. ✚\n    * [ ] `MovingPolicy`의 구현체인 `RandomMovingPolicy`을 활용하여 0에서 9 사이에 무작위 값을 구한 후 무작위 값이 4 이상일 경우 전진한다. ✚\n \n### 2. 입력\n * [ ] 경주할 자동차 이름을 입력 받는다.\n    * [ ] 경주할 자동차 이름은 쉼표를 기준으로 나눈다.\n    * [ ] 입력 받은 자동차 이름은 검증을 마친 후 List로 변환되어 전달한다.\n * [ ] 시도할 회수를 입력 받는다.\n \n### 3. 게임 실행\n * [ ] 레이싱 게임을 실행할 수 있다.\n * [ ] 레이싱 게임은 반복되지 않는다.\n\n### 4. 출력\n * [ ] 결과값 출력에 대한 전반적인 책임을 가진다.\n * [ ] `IllegalArgumentException`이 발생할 경우 `\"[ERROR]\"로 시작하는 에러 메시지 출력`을 진행한다.\n</details>\n\n<details>\n<summary>ver 0.3 기능 목록</summary>\n\n### 1. 자동차\n * [ ] 자동차는 이름을 가질 수 있다.\n * [ ] 자동차의 이름은 `5자 이하`만 가능하다.\n * [ ] 자동차는 전진 또는 멈출 수 있다.\n * [ ] 자동차는 이동 유무를 판단하는 `isMoving` 메서드를 가진 `MovingPolicy` 인터페이스를 가진다.\n    * [ ] 자동차의 전진 유무는 `MovingPolicy`의 `isMoving`을 통해 확인한다.\n    * [ ] `MovingPolicy`의 구현체인 `RandomMovingPolicy`을 활용하여 0에서 9 사이에 무작위 값을 구한 후 무작위 값이 4 이상일 경우 전진한다.\n \n### 2. 입력\n * [ ] 경주할 자동차 이름을 입력 받는다.\n    * [ ] 경주할 자동차 이름은 쉼표를 기준으로 나눈다.\n    * [ ] 입력 받은 자동차 이름은 검증을 마친 후 List로 변환되어 전달한다.\n * [ ] 시도할 회수를 입력 받는다.\n\n### 3. 자동차 리스트\n * [ ] 자동차들을 관리하는 일급 컬렉션이다. ✚\n * [ ] 자동차들을 일괄적으로 움직이게할 수 있다. ✚\n * [ ] 각 차수별 실행 결과를 만들어 반환한다. ✚\n * [ ] 최종 우승자 안내 문구를 제공한다. ✚\n\n### 4. 게임 실행\n * [ ] 레이싱 게임을 실행할 수 있다.\n * [ ] 레이싱 게임은 반복되지 않는다.\n\n### 5. 출력\n * [ ] 결과값 출력에 대한 전반적인 책임을 가진다.\n * [ ] `IllegalArgumentException`이 발생할 경우 `\"[ERROR]\"로 시작하는 에러 메시지 출력`을 진행한다.\n</details>\n\n<details>\n<summary>ver 0.4 기능 목록</summary>\n\n### 1. 자동차\n * [ ] 자동차는 이름을 가질 수 있다.\n * [ ] 자동차의 이름은 `5자 이하`만 가능하다.\n * [ ] 자동차의 이름은 `공백`이거나 `비어있는 경우` 예외 처리를 진행한다. 아래는 예외 처리가 일어날 수 있는 이름의 예시이다. ✚\n    * ` ` ✚\n    * `null` ✚\n * [ ] 자동차는 전진 또는 멈출 수 있다.\n * [ ] 자동차는 이동 유무를 판단하는 `isMoving` 메서드를 가진 `MovingPolicy` 인터페이스를 가진다.\n    * [ ] 자동차의 전진 유무는 `MovingPolicy`의 `isMoving`을 통해 확인한다.\n    * [ ] `MovingPolicy`의 구현체인 `RandomMovingPolicy`을 활용하여 0에서 9 사이에 무작위 값을 구한 후 무작위 값이 4 이상일 경우 전진한다.\n \n### 2. 입력\n * [ ] 경주할 자동차 이름을 입력 받는다.\n    * [ ] 경주할 자동차 이름은 쉼표를 기준으로 나눈다.\n    * [ ] 입력 받은 자동차 이름은 검증을 마친 후 List로 변환되어 전달한다.\n * [ ] 시도할 회수를 입력 받는다.\n    * [ ] 시도할 회수가 숫자가 아니면 예외를 던진다. ✚\n\n### 3. 자동차 리스트\n * [ ] 자동차들을 관리하는 일급 컬렉션이다. \n * [ ] 자동차들을 일괄적으로 움직이게 한다.\n * [ ] 각 차수별 실행 결과를 만들어 반환한다. \n * [ ] 최종 우승자 안내 문구를 제공한다.\n\n### 4. 게임 실행\n * [ ] 레이싱 게임을 실행할 수 있다.\n * [ ] 레이싱 게임은 반복되지 않는다.\n * [ ] 예외 처리가 일어나면 해당 에러 메시지를 출력한 후 입력을 다시 받는다. ✚\n\n### 5. 출력\n * [ ] 결과값 출력에 대한 전반적인 책임을 가진다.\n * [ ] `IllegalArgumentException`이 발생할 경우 `\"[ERROR]\"로 시작하는 에러 메시지 출력`을 진행한다.\n</details>\n\n<details>\n<summary>ver 0.5 기능 목록</summary>\n\n### 1. 자동차\n * [ ] 자동차는 이름을 가질 수 있다.\n * [ ] 자동차의 이름은 `5자 이하`만 가능하다.\n * [ ] 자동차의 이름은 `공백`이거나 `비어있는 경우` 예외 처리를 진행한다. 아래는 예외 처리가 일어날 수 있는 이름의 예시이다. \n    * `''`\n    * `' '`\n    * `'   '`\n * [ ] 자동차는 전진 또는 멈출 수 있다.\n * [ ] 자동차는 이동 유무를 판단하는 `isMoving` 메서드를 가진 `MovingPolicy` 인터페이스를 가진다.\n    * [ ] 자동차의 전진 유무는 `MovingPolicy`의 `isMoving`을 통해 확인한다.\n    * [ ] `MovingPolicy`의 구현체인 `RandomMovingPolicy`을 활용하여 0에서 9 사이에 무작위 값을 구한 후 무작위 값이 4 이상일 경우 전진한다.\n \n### 2. 입력\n * [ ] 경주할 자동차 이름을 입력 받는다.\n    * [ ] 경주할 자동차 이름은 쉼표를 기준으로 나눈다.\n    * [ ] 입력 받은 자동차 이름은 검증을 마친 후 List로 변환되어 전달한다.\n * [ ] 시도할 회수를 입력 받는다.\n\n### 3. 시도 회수\n* [ ] 시도할 회수를 표현하기 위한 역할을 가진다. ✚\n* [ ] 시도할 회수가 `숫자가 아니면` 예외를 던진다. ✚\n* [ ] 시도할 회수가 `음수`이면 예외를 던진다. ✚\n\n### 4. 자동차 리스트\n * [ ] 자동차들을 관리하는 일급 컬렉션이다. \n * [ ] 자동차의 이름이 `중복`되는 경우 예외를 던진다. ✚\n * [ ] 자동차들을 일괄적으로 움직이게 한다.\n * [ ] 각 차수별 실행 결과를 만들어 반환한다. \n * [ ] 최종 우승자 안내 문구를 제공한다.\n\n### 5. 게임 실행\n * [ ] 레이싱 게임을 실행할 수 있다.\n * [ ] 레이싱 게임은 반복되지 않는다.\n * [ ] 예외 처리가 일어나면 해당 에러 메시지를 출력한 후 입력을 다시 받는다.\n\n### 6. 출력\n * [ ] 결과값 출력에 대한 전반적인 책임을 가진다.\n * [ ] `IllegalArgumentException`이 발생할 경우 `\"[ERROR]\"로 시작하는 에러 메시지 출력`을 진행한다.\n</details>\n\n## 2. 구현 순서 맞추기\n\n> 구현 순서도 코딩 컨벤션이다\n> \n> 클래스는 상수, 멤버 변수, 생성자, 메서드 순으로 작성한다.\n\n1주차 공통 피드백에서 구현 순서에 따른 피드백도 확인할 수 있었다. 관련 자료를 더 찾아보기 위해 [Clean Code 클린 코드 애자일 소프트웨어 장인 정신](http://www.yes24.com/Product/Goods/11681152)을 참고하였다.\n\n> 형식 맞추기\n> 책의 세부 내용은 예제 코드를 기반으로 [형식 맞추기](https://hyeonic.github.io/%EA%B8%B0%ED%83%80/clean-code/match-the-format.html)에 작성하였다.\n\n공통 피드백과 책의 내용을 기반으로 구현 순서에 신경쓰며 작성하기 위해 노력하였다.\n\n## 3. 매직 넘버, 매직 리터럴\n\n> 매직 넘버를 사용하지 마라\n> 매직 넘버는 의미를 나타낼 수 있는 상수(static final)로 치환하여 코드의 가독성을 높인다.\n\n1주차 공통 피드백에서 매직 넘버와 관련된 피드백을 확인할 수 있었다. 매직 넘버, 매직 리터럴이 의미하는 바는 무엇이고 이것을 통해 얻고자 하는 것이 무엇인지 정리하였다.\n\n`매직 넘버(magic number)`, `매직 리터럴(magic literal)` 이란 소스 코드에서 의미를 가진 숫자나 문자를 그대로 표현한 것을 말한다. \n\n이러한 표현은 소스 코드를 읽기 어렵게 만든다. 상수로 선언되어 있지 않은 숫자, 문자열은 무엇을 의미하는지 확신할 수 없게 만든다. 이러한 의미를 파악하기 위해 해당 클래스와 흐름을 이해하기 위해 많은 시간을 요구한다. \n\n`상수(static final)`로 선언하게 되면 이러한 값들에게 `이름이 부여`된다. 이름을 통하여 `의미와 역할`을 확실히 전달할 수 있다.\n\n아래는 [What is a magic number, and why is it bad?](https://stackoverflow.com/questions/47882/what-is-a-magic-number-and-why-is-it-bad)의 예제를 인용한 것이다.\n\n아래 코드는 매직 넘버가 사용된 예시이다.\n```java\npublic class Foo {\n    public void setPassword(String password) {\n         // don't do this\n         if (password.length() > 7) {\n              throw new InvalidArgumentException(\"password\");\n         }\n    }\n}\n```\n\n위 코드는 아래와 같이 리팩토링 되어야 한다.\n```java\npublic class Foo {\n    public static final int MAX_PASSWORD_SIZE = 7;\n\n    public void setPassword(String password) {\n         if (password.length() > MAX_PASSWORD_SIZE) {\n              throw new InvalidArgumentException(\"password\");\n         }\n    }\n}\n```\n\n이러한 리팩토링은 코드의 `가독성이 향상`되고 `유지 관리`가 더 쉽게 만들 수 있다.\n\n### 적용\n\n실제 제출 코드의 일부분을 가져온 것이다. 숫자와 문자열 모두 의미를 정확하게 전달할 수 있도록 이름을 부여하였기 때문에 이전 보다 더 명확하게 의도를 전달할 수 있게 되었다.\n\n```java\npublic class InputView {\n    private static final String INPUT_NAMES_MESSAGE = \"경주할 자동차 이름을 입력하세요.(이름은 쉼표(,) 기준으로 구분)\";\n    private static final String INPUT_TRY_COUNT_MESSAGE = \"시도할 회수는 몇회인가요?\";\n    private static final String SPLIT_REGEX = \",\";\n    private static final int SPLIT_LIMIT = -1;\n\n    public List<String> getNames() {\n        System.out.println(INPUT_NAMES_MESSAGE);\n        String inputNames = Console.readLine();\n        String[] names = inputNames.split(SPLIT_REGEX, SPLIT_LIMIT);\n        return new ArrayList<>(Arrays.asList(names));\n    }\n\n    public TryCount getTryCount() {\n        System.out.println(INPUT_TRY_COUNT_MESSAGE);\n        String inputTryCount = Console.readLine();\n        return new TryCount(inputTryCount);\n    }\n}\n```\n\n## 4. Car, Strategy Pattern 적용\n\n### Strategy Pattern 도입 배경\n\n기존 Car 객체 설계 당시 단순히 `내부`에서 랜덤한 값을 활용하여 `이동 여부를 처리`하였다.\n\n```java\npublic class Car {\n    private static final int DEFAULT_POSITION = 0;\n    private static final int NAME_MAX_LENGTH = 5;\n    private static final int MIN_NUMBER_RANGE = 0;\n    private static final int MAX_NUMBER_RANGE = 9;\n    private static final int MOVE_CONDITION = 4;\n\n    private final String name;\n    private int position = DEFAULT_POSITION;\n    public Car(String name) {\n        validateName(name);\n        this.name = name;\n    }\n    private void validateName(String name) {\n        validateLength(name);\n    }\n    private void validateLength(String name) {\n        if (name.length() > NAME_MAX_LENGTH) {\n            throw new IllegalArgumentException();\n        }\n    }\n\n    public void move() {\n        if (isMoving()) {\n            position++;\n        }\n    }\n\n    private boolean isMoving() {\n        if (Randoms.pickNumberInRange(MIN_NUMBER_RANGE, MAX_NUMBER_RANGE) >= MOVE_CONDITION) {\n            return true;\n        }\n        return false;\n    }\n} \n```\n\n당장 구현에 문제는 없었지만 Car에 `많은 책임`을 가지고 있지 않은지에 대한 고민과 `단위 테스트 작성` 시 `move 메서드 내부를 제어`할 수 없기 때문에 정상적인 테스트를 작성하는데 제한이 되었다.\n\n그때 `Strategy Pattern`에 대해 공부하게 되었다. `Strategy Pattern`은 `실행 중`에 `알고리즘을 선택`할 수 있게 도와준다.\n\n`Car`에서 `isMoving`을 전략으로 활용하여 `실행 시점`에 `이동 여부를 반환`할 수 있도록 적용하면 좋을 것 같다는 판단을 세우게 되었다.\n\n### Strategy Pattern 적용\n\n#### MovingPolicy\n```java\n@FunctionalInterface\npublic interface MovingPolicy {\n    boolean isMoving();\n}\n```\n\n다양한 `이동 정책`을 적용하기 위한 함수형 인터페이스이다.\n\n#### RandomMovingPolicy\n```java\npublic class RandomMovingPolicy implements MovingPolicy {\n    private static final int MIN_NUMBER_RANGE = 0;\n    private static final int MAX_NUMBER_RANGE = 9;\n    private static final int MOVE_CONDITION = 4;\n\n    @Override\n    public boolean isMoving() {\n        if (Randoms.pickNumberInRange(MIN_NUMBER_RANGE, MAX_NUMBER_RANGE) >= MOVE_CONDITION) {\n            return true;\n        }\n        return false;\n    }\n}\n```\n\n`MovingPolicy`의 구현체로 `RandomMovingPolicy`를 작성하였다. `RandomMovingPolicy`는 랜덤하게 수를 뽑아 이동 조건을 판단하여 이동 유무를 반환하는 `isMoving`메서드를 오버라이딩하였다.\n\n#### 변경된 Car\n\n```java\npublic class Car {\n    private static final int DEFAULT_POSITION = 0;\n    private static final int NAME_MAX_LENGTH = 5;\n\n    private final String name;\n    private final MovingPolicy movingPolicy;\n    private int position = DEFAULT_POSITION;\n\n    public Car(String name, MovingPolicy movingPolicy) {\n        validateName(name);\n        this.name = name;\n        this.movingPolicy = movingPolicy;\n    }\n\n    private void validateName(String name) {\n        validateLength(name);\n    }\n    private void validateLength(String name) {\n        if (name.length() > NAME_MAX_LENGTH) {\n            throw new IllegalArgumentException();\n        }\n    }\n\n    public void move() {\n        if (movingPolicy.isMoving()) {\n            position++;\n        }\n    }\n} \n```\n\n`MovingPolicy`는 `Car` 생성 시점에 전략이 정해진다. 이제 MovingPolicy의 구현체를 다양하게 적용 가능하기 때문에 Car와 Car의 이동에 대한 `결합도`도 낮출 수 있는 결과를 만들었다.\n\n또한 추후에 요구사항 변경에 의해 다른 이동 정책이 추가되면 단순히 `MovingPolicy`를 구현하면 되기 때문에 쉽게 `확장`이 가능하다.\n\n### 유연한 테스트 작성\n\n```java\nclass CarTest {\n    ...\n    @DisplayName(\"movingPolicy의 isMoving이 true이면 position이 1 증가한다.\")\n    @Test\n    void move_IsMovingThenTrue_IncreasePosition() {\n        // given\n        MovingPolicy movingPolicy = () -> true;\n        Car car = new Car(\"pobi\", movingPolicy);\n\n        // when\n        car.move();\n\n        // then\n        assertThat(car.getPosition()).isEqualTo(1);\n    }\n\n    @DisplayName(\"movingPolicy의 isMoving이 false이면 position은 정지한다.\")\n    @Test\n    void move_IsMovingThenFalse_StopPosition() {\n        // given\n        MovingPolicy movingPolicy = () -> false;\n        Car car = new Car(\"pobi\", movingPolicy);\n\n        // when\n        car.move();\n\n        // then\n        assertThat(car.getPosition()).isEqualTo(0);\n    }\n    ...\n}\n```\n\n이제 ``Car``의 `move`를 자유롭게 테스트 가능하다. 테스트 시점에 이동 정책을 생성한 뒤 `move`를 진행하면 반환된 결과에 따라 Car의 `position`이 변하는 것을 확인하였다.\n\n## 5. 캡슐화\n\n객체를 사용하면 변경 가능성이 높은 부분은 내부에 숨기고 외부에는 상대적으로 안정적인 부분만 공개함으로써 변경의 여파를 통제할 수 있다. `캡슐화`는 외부에서 알 필요가 없는 부분을 감춤으로써 대상을 단순화하는 추상화의 종류이다. `캡슐화`는 변경 가능성이 높은 부분을 객체 내부로 숨기는 추상화 기법이다.\n\n아래는 캡슐화를 잘 지키는 것 처럼 보인다. 인스턴스 변수는 `private`를 사용 하였고 해당 변수에 접근하기 위한 `public get/set 메서드`를 가지고 있다.\n```java\npublic class Car {\n    private final String name;\n    private int positon = 0;\n\n    public Car(String name) {\n        this.name = name;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    } \n\n    public int getPosition() {\n        return position;\n    }\n\n    public void setPosition(int position) {\n        this.position = position;\n    }\n}\n```\n\n하지만 `get/set 메서드`들은 객체 내부를 `전혀 보호 하지 못하고 있다.` 오히려 내부의 `상태 정보를 그대로 보여주고 있다.`\n\n객체는 `스스로의 상태를 책임`져야 하며 외부에서는 `인터페이스에 정의된 메서드`를 통해서만 상태에 접근할 수 있어야 한다.\n\n### Car 리스트를 가지는 일급 컬렉션 Cars\n\n레이싱 게임에서 여러 개의 Car list 관리를 위해 `일급 컬렉션` `Cars`를 사용하였다. Cars에서는 Car의 `내부 상태인 position`을 활용하여 `우승자를 선정`하고 `name을 조회`해야 했다. 이것을 구현하기 위해서는 Car의 내부 상태를 드러내는 `get 메서드`가 불가피하게 사용된다.\n\n```java\npublic class Cars {\n    private static final String NEW_LINE = \"\\n\";\n    private static final String WINNER_NAMES_DELIMITER = \", \";\n    private static final int DEFAULT_MAX_POSITION = 0;\n\n    private final List<Car> cars;\n\n    public Cars(List<String> names, MovingPolicy movingPolicy) {\n        this.cars = names.stream()\n            .map(name -> new Car(name, movingPolicy))\n            .collect(toList());\n    }\n\n    public void move() {\n        cars.forEach(Car::move);\n    }\n\n    public String getExecutionResult() {\n        return cars.stream()\n            .map(Car::getStateMessage)\n            .collect(joining(NEW_LINE));\n    }\n\n    public String getWinnersNames() {\n        int maxPosition = getMaxPosition();\n        return cars.stream()\n            .filter(car -> car.isSamePosition(maxPosition))\n            .map(Car::getName) // 불가피한 get 사용\n            .collect(joining(WINNER_NAMES_DELIMITER));\n    }\n\n    private int getMaxPosition() {\n        return cars.stream()\n            .map(Car::getPosition) // 불가피한 get 사용\n            .reduce(DEFAULT_MAX_POSITION, Integer::max);\n    }\n}\n```\n\n결국 이것은 Cars와 Car의 `결합도를 강하게 만드는 원인`이 아닌가 고민하게 되었다. 그렇다고 해당 로직은 Car로 옮기기에는 억지로 책임을 부여하는 듯한 기분이 들었다. \n\n### protected\n\n`protected`는 상속, 같은 패키지 내의 클래스에 접근 가능하도록 하는 접근 제어자 이다. 즉 Cars와 Car를 `같은 패키지`에만 위치 시키면 다른 `외부 패키지`는 Car의 get 메서드에 접근할 수 없다. Cars에서만 사용을 제한시키면 어느정도 `캡슐화로 내부 상태를 지킬 수 있다`는 판단을 하게 되었다.\n\nCar의 메서드는 protected로 접근 제어자를 활용하였다.\n\n```java\npublic class Car {\n    private static final int ZERO_INDEX = 0;\n    private static final String MOVING_STICK = \"-\";\n    ...\n    \n    protected void move() {\n        if (movingPolicy.isMoving()) {\n            position++;\n        }\n    }\n\n    protected String getStateMessage() {\n        StringBuilder stringBuilder = new StringBuilder(String.format(NAME_MESSAGE, name));\n        for (int i = ZERO_INDEX; i < position; i++) {\n            stringBuilder.append(MOVING_STICK);\n        }\n        return stringBuilder.toString();\n    }\n\n    protected String getName() {\n        return name;\n    }\n\n    protected int getPosition() {\n        return position;\n    }\n\n    protected boolean isSamePosition(int maxPosition) {\n        if (this.position == maxPosition) {\n            return true;\n        }\n        return false;\n    }\n}\n```\n\n![](https://user-images.githubusercontent.com/59357153/144742656-7207a192-5d23-4b29-93d8-e80ccf207736.png)\n\n이러한 패키지 구조를 갖기 때문에 외부 다른 패키지에서는 Car의 `protected` 메서드에 접근하지 못한다.\n\n## 6. String의 split 메서드\n\n기능 요구 사항을 살펴보면 자동차 이름은 쉼표(,)를 기준으로 구분하여 사용한다. Java에서 구분자를 통한 문자열을 나누기 위해서는 흔히 `split` 메서드를 활용한다.\n\n### split\n\n```java\npublic final class String\n    implements java.io.Serializable, Comparable<String>, CharSequence {\n    ...\n\n    public String[] split(String regex, int limit) {\n        ...\n    }\n\n    public String[] split(String regex) {\n        return split(regex, 0);\n    }\n    ...\n}\n```\n\n위는 String 클래스의 일부분을 가져온 것이다. split 메서드의 경우 서로 다른 매개변수 리스트를 가진 메서드로 오버로딩 되어 있다. 흔히 사용하는 `spit(String regex)`은 `limit`가 `0`으로 설정되어 반환한다.\n\nlimit 매개변수는 패턴이 적용되는 횟수를 제어한다. n이 0보다 크면 패턴이 최대 n - 1회 적용되고 배열의 길이는 n보다 크지 않으면 배열의 마지막 항목에는 마지막 일치 구분 기호 이후의 모든 문자열이 포함된다. `n이 양수가 아닌 경우 패턴이 최대한 많이 적용되고 배열은 임의의 길이를 가질 수 있다.` n이 0이면 패턴은 가능한 많이 적용되고 배열은 임의의 길이를 가질 수 있으며 후행 빈 문자열은 폐기된다.\n\n여기서 limit에 음수 값을 넣어 나눌 경우 패턴이 최대한 많이 적용되며 빈문자열이 폐기되지 않고 나눠진다. 아래는 0을 넣었을 때와 음수를 넣었을 때의 차이를 비교한 것이다.\n\n```java\nList<String> list = new ArrayList<>();\nlist.add(\"a,b,c,d,e\");\nlist.add(\"a,b,c,d,e,\");\nlist.add(\"a,  ,b\");\nlist.add(\", , , , \");\nlist.add(\",,,,\");\nlist.add(\"a\");\n\nfor (String s : list) {\n    System.out.println(\"나눌 문자열: \" + s);\n    System.out.println(\"limt이  0일 때: \" + Arrays.toString(s.split(\",\")));\n    System.out.println(\"limt이 -1일 때: \" + Arrays.toString(s.split(\",\", -1)));\n    System.out.println();\n}\n```\n\n```bash\n나눌 문자열: a,b,c,d,e\nlimt이  0일 때: [a, b, c, d, e]\nlimt이 -1일 때: [a, b, c, d, e]\n\n나눌 문자열: a,b,c,d,e,\nlimt이  0일 때: [a, b, c, d, e]\nlimt이 -1일 때: [a, b, c, d, e, ]\n\n나눌 문자열: a,  ,b\nlimt이  0일 때: [a,   , b]\nlimt이 -1일 때: [a,   , b]\n\n나눌 문자열: , , , , \nlimt이  0일 때: [,  ,  ,  ,  ]\nlimt이 -1일 때: [,  ,  ,  ,  ]\n\n나눌 문자열: ,,,,\nlimt이  0일 때: []\nlimt이 -1일 때: [, , , , ]\n\n나눌 문자열: a\nlimt이  0일 때: [a]\nlimt이 -1일 때: [a]\n```\n\n가장 큰 차이를 보이는 것은 `a,b,c,d,e,`와 `,,,,`이다. limit이 0일 때는 `후행 빈 문자열이 자동으로 폐기`되는 것을 확인할 수 있었다.\n\n이번 레이싱 게임을 진행하며 자동차의 `이름에 대한 검증`은 모두 `Car`가 책임을 가지도록 하였다. 하지만 자동차의 이름을 `split`하는 것은 `InputView`의 책임으로 설정하였다. 즉 `빈 문자열`이라도 `정확히 나눠서` list로 전달해야 했다. 그래야 온전히 나눠진 문자열 리스트의 요소를 Car에서 검증이 가능하기 때문이다.\n\n### InputView\n\n`InputView`는 레이싱 게임의 모든 입력을 위한 책임을 가지고 있다. 앞서 언급한 것 처럼 빈 문자열까지 정확히 나누기 위해 아래와 같이 작성하였다.\n\n```java\npublic class InputView {\n    private static final String INPUT_NAMES_MESSAGE = \"경주할 자동차 이름을 입력하세요.(이름은 쉼표(,) 기준으로 구분)\";\n    ...\n    private static final String SPLIT_REGEX = \",\";\n    private static final int SPLIT_LIMIT = -1;\n    ...\n\n    public List<String> getNames() {\n        System.out.println(INPUT_NAMES_MESSAGE);\n        String inputNames = Console.readLine();\n        String[] names = inputNames.split(SPLIT_REGEX, SPLIT_LIMIT);\n        return new ArrayList<>(Arrays.asList(names));\n    }\n    ...\n}\n```\n\n`String[] names = inputNames.split(SPLIT_REGEX, SPLIT_LIMIT)`을 활용하여 쉼표(,)를 기준으로 빈 문자열을 포함하여 문자열 리스트를 만들어 반환한다. 이것에 대한 검증은 단위 테스트를 활용하여 검증하였다.\n\n```java\nclass InputViewTest {\n    ...\n    static Stream<Arguments> getNamesMethodSourceProvider() {\n        return Stream.of(\n            arguments(\"pobi,woni,jun\", 3),\n            arguments(\",,,,\", 5),\n            arguments(\",pobi,\", 3),\n            arguments(\" , ,, , \", 5),\n            arguments(\"pobi\", 1)\n        );\n    }\n\n    @DisplayName(\"경주할 자동차 이름을 입력 받으면 쉼표를 기준으로 나눠 리스트를 반환한다.\")\n    @ParameterizedTest\n    @MethodSource(\"getNamesMethodSourceProvider\")\n    void getNames_InputNames_ListReturn(String inputNames, int size) {\n        // given\n        System.setIn(generateStream(inputNames));\n        InputView inputView = generateInputView();\n\n        // when\n        List<String> names = inputView.getNames();\n\n        // then\n        System.out.println(names);\n        assertThat(names).isInstanceOf(List.class);\n        assertThat(names.size()).isEqualTo(size);\n    }\n    ...\n}\n```\n\n## 7. String + 연산자보다 StringBuilder\n\nString은 `불변 객체`이다. `+ 연산자`를 통해 문자열 객체를 수정할 경우 매번 `새로운 인스턴스`를 생성한다. \n\nCar 객체를 살펴보면 자신의 상태 메시지 반환을 위해 해당 position의 개수 만큼 `-`을 그려야 한다. 여기서 단순히 문자열 + 연산자를 사용하기 보다 `가변적인 문자열에 특화된 StringBuilder`에 대해 학습하고 적용하였다.\n\n```java\npackage racingcar.domain.car;\n\nimport static racingcar.domain.error.ErrorMessage.*;\n\npublic class Car {\n    private static final String NAME_MESSAGE = \"%s : \";\n    private static final String MOVING_STICK = \"-\";\n    ...\n    private final String name;\n    private final MovingPolicy movingPolicy;\n    private int position = DEFAULT_POSITION;\n    ...\n\n    protected String getStateMessage() {\n        StringBuilder stringBuilder = new StringBuilder(String.format(NAME_MESSAGE, name));\n        for (int i = ZERO_INDEX; i < position; i++) {\n            stringBuilder.append(MOVING_STICK);\n        }\n        return stringBuilder.toString();\n    }\n    ...\n}\n```\n\n## 8. 모든 원시값과 문자열을 포장하라\n \n> 규칙3: 원시값과 문자열의 포장\n> \n> int 값 하나 자체는 그냥 아무 의미 없는 스칼라 값일 뿐이다. 어떤 메서드가 int 값을 매개변수로 받는다면 그 메서드 이름은 해당 매개변수의 의도를 나타내기 위해 모든 수단과 방법을 가리지 않아야 한다. \n> \n> 원시형 변수로는 컴파일러가 의미적으로 맞는 프로그램 작성을 안내할 수 없다. 객체로라면 아주 사소하더라도 컴파일러와 프로그래머에게 그 값이 어떤 값이며, 왜 쓰고 있는지에 대한 정보를 전하는 셈이다.\n\n*[소트웍스 앤솔러지](http://www.yes24.com/Product/Goods/3290339)를 일부분 발췌한 내용입니다.*\n\n### 원시 타입을 포장해야 하는 이유\n\n#### 자신의 상태를 스스로 관리할 수 있다\n\n아래 코드는 프리코스 제출 코드 일부분을 가져온 것이다.\n\n```java\npublic class TryCount {\n    private int tryCount;\n\n    public TryCount(String inputTryCount) {\n        this.tryCount = Integer.parseInt(inputTryCount);\n    }\n}\n```\n\n`TryCount`는 시도 횟수인 `원시 타입 int`를 가진 클래스이다. 내부에 `tryCount라는 상태`를 가지고 있기 때문에 해당 원시 타입에 대한 검증은 `TryCount 내부`에서 적용 가능하다. \n\n#### 적용\n\n기존에는 시도 횟수를 입력 받으면 `InputView`에서 `모든 검증`을 진행하였다. `getTryCount`는 검증이 진행되고 난 후 단순히 원시 타입 int를 반환하고 있다.\n\n```java\npublic class InputView {\n    private static final String INPUT_TRY_COUNT_MESSAGE = \"시도할 회수는 몇회인가요?\";\n    private static final int ZERO_NUMBER = 0;\n    ...\n\n    public int getTryCount() {\n        System.out.println(INPUT_TRY_COUNT_MESSAGE);\n        String inputTryCount = Console.readLine();\n        validateNumberFormat(inputTryCount);\n\n        int tryCount = Integer.parseInt(inputTryCount);\n        validateNegativeNumber(tryCount);\n        return tryCount;\n    }\n\n    private void validateNumberFormat(String inputTryCount) {\n        try {\n            Integer.parseInt(inputTryCount);\n        } catch (NumberFormatException e) {\n            throw new IllegalArgumentException();\n        }\n    }\n\n    private void validateNegativeNumber(int parseTryCount) {\n        if (parseTryCount < ZERO_NUMBER) {\n            throw new IllegalArgumentException();\n        }\n    }\n} \n```\n\n이제 `TryCount`로 원시 타입을 포장한 뒤 모든 검증을 객체 내부로 이동시켰다. TryCount는 내부 상태에 대한 검증 및 책임을 모두 가지고 있다. 또한 내부 상태를 활용하는 행위가 필요하다면 단순히 추가해주기면 하면 된다.\n\n```java\npublic class TryCount {\n    private static final int ZERO_NUMBER = 0;\n\n    private int tryCount;\n\n    public TryCount(String inputTryCount) {\n        validateNumberFormat(inputTryCount);\n        int tryCount = Integer.parseInt(inputTryCount);\n        validateNegativeNumber(tryCount);\n        this.tryCount = tryCount;\n    }\n\n    private void validateNumberFormat(String inputTryCount) {\n        try {\n            Integer.parseInt(inputTryCount);\n        } catch (NumberFormatException e) {\n            throw new IllegalArgumentException(NUMBER_FORMAT_NOT_VALID.getMessage());\n        }\n    }\n\n    private void validateNegativeNumber(int parseTryCount) {\n        if (parseTryCount < ZERO_NUMBER) {\n            throw new IllegalArgumentException(NEGATIVE_NUMBER_NOT_VALID.getMessage());\n        }\n    }\n    ...\n}\n```\n\n개선된 `InputView`이다. 오직 입력에 대한 책임을 뚜렷하게 나타내기 위해 노력하였다.\n\n```java\npublic class InputView {\n    private static final String INPUT_NAMES_MESSAGE = \"경주할 자동차 이름을 입력하세요.(이름은 쉼표(,) 기준으로 구분)\";\n    private static final String INPUT_TRY_COUNT_MESSAGE = \"시도할 회수는 몇회인가요?\";\n    private static final String SPLIT_REGEX = \",\";\n    private static final int SPLIT_LIMIT = -1;\n\n    public List<String> getNames() {\n        System.out.println(INPUT_NAMES_MESSAGE);\n        String inputNames = Console.readLine();\n        String[] names = inputNames.split(SPLIT_REGEX, SPLIT_LIMIT);\n        return new ArrayList<>(Arrays.asList(names));\n    }\n\n    public TryCount getTryCount() {\n        System.out.println(INPUT_TRY_COUNT_MESSAGE);\n        String inputTryCount = Console.readLine();\n        return new TryCount(inputTryCount);\n    }\n}\n```\n\n## 9. 단위 테스트 명명법\n\n단위 테스트를 진행하며 이름을 짓고 명명법을 통일하기 위해 많은 고민을 하였다. 그러던 중 [7 Popular Unit Test Naming Conventions](https://dzone.com/articles/7-popular-unit-test-naming)을 발견하게 되었다. \n\n크게 7가지 방법을 소개하고 있다. 우선 좋은 명명법 보다 통일성 있는 이름과 단위 테스트의 퀄리티를 올리기 위해 1번을 선택하게 되었다. \n\n1번 방법의 단점으로는 테스트 하고자 하는 `메서드의 이름을 포함하여 이름 짓기 때문에 메서드가 변경되면 단위 테스트 또한 변경을 진행해야 한다.` 덕분에 이러한 단점을 확실히 느낄 수 있는 계기가 되었다.\n\n아래는 실제 작성한 단위 테스트의 일부를 가져온 것이다.\n\n```java\nclass TryCountTest {\n    @DisplayName(\"문자열 시도 횟수가 숫자이고 음수가 아니면 정상적으로 생성된다.\")\n    @ParameterizedTest\n    @ValueSource(strings = {\"1\", \"2\", \"3\", \"4\", \"5\"})\n    void constructor_InputTryCountThenNumberFormatAndNotNegativeNumber_Success(String inputTryCount) {\n        // given & when & then\n        assertThatCode(() -> {\n            new TryCount(inputTryCount);\n        }).doesNotThrowAnyException();\n    }\n\n    @DisplayName(\"문자열 시도 횟수가 숫자가 아니면 예외를 던진다.\")\n    @ParameterizedTest\n    @ValueSource(strings = {\"1a\", \"ab\", \"3a0\", \"4O\", \"s5\"})\n    void constructor_InputTryCountThenNotNumberFormat_ExceptionThrown(String inputTryCount) {\n        // given & when & then\n        assertThatThrownBy(() -> {\n            new TryCount(inputTryCount);\n        }).isInstanceOf(IllegalArgumentException.class);\n    }\n    ...\n}\n```\n\n익숙하지 않은 방식이었고 생성자의 경우 어떤식으로 명명해야 하는지 고민이 많았다. 다양한 코드를 접하며 더 좋은 명명법을 적용하기 위해 노력해야 겠다.\n\n## 10. git rebase\n\n진행 도중 테스트 코드 일부분이 수정되어 main에서 병합을 진행해야 하는 상황이 주어졌다. 관련 방법을 찾던 도중 `rebase`를 활용하여 적용하기로 결정하였다.\n\n## References\n\n### 매직 넘버, 매직 리터럴\n * [magic number 사용을 최대한 자제하자.](https://slipp.net/questions/356)\n * [What is a magic number, and why is it bad?](https://stackoverflow.com/questions/47882/what-is-a-magic-number-and-why-is-it-bad)\n * [1. 의미가 불분명한 매직 넘버를 상수로 선언하라.](https://javabom.tistory.com/28)\n\n### 캡슐화\n * 조영호, 『오브젝트』, 위키북스(2019), p113-132.\n\n### String split\n * [Class String](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#split-java.lang.String-int-)\n\n### 모든 원시값과 문자열을 포장하라\n * [원시 타입을 포장해야 하는 이유](https://tecoble.techcourse.co.kr/post/2020-05-29-wrap-primitive-type/)\n * [[Java] 원시값 포장이란?](https://livenow14.tistory.com/37)\n * [더 나은 소프트웨어를 향한 9단계: 객체지향 생활 체조(4)](https://developerfarm.wordpress.com/2012/01/27/object_calisthenics_4/)\n\n### 테스트 코드 명명법\n * [7 Popular Unit Test Naming Conventions](https://dzone.com/articles/7-popular-unit-test-naming)\n"},{"excerpt":"미션 - 숫자 야구 게임 우아한테크코스 4기 프리코스 1주차 미션을 진행하며 고민한 내용을 정리하고 추가적인 개인 목표를 세워 정리해보았다. 미션 - 숫자 야구 게임 구현 기능 목록 프로젝트를 진행할 때 최초에 모든 기능 목록을 작성하기 보다 작업을 진행하며 추가적인 기능을 지속적으로 업데이트 할 수 있도록 노력하였다. 1부터 9까지 서로 다른 수로 이루…","fields":{"slug":"/precourse-1/"},"frontmatter":{"date":"November 01, 2021","title":"프리코스 1주차","tags":["우아한테크코스","프리코스"]},"rawMarkdownBody":"\n## 미션 - 숫자 야구 게임\n\n우아한테크코스 4기 프리코스 1주차 미션을 진행하며 고민한 내용을 정리하고 추가적인 개인 목표를 세워 정리해보았다.\n\n[미션 - 숫자 야구 게임](https://github.com/woowacourse/java-baseball-precourse)\n\n## 구현 기능 목록\n\n프로젝트를 진행할 때 최초에 모든 기능 목록을 작성하기 보다 작업을 진행하며 추가적인 기능을 지속적으로 업데이트 할 수 있도록 노력하였다.\n\n<details>\n<summary>ver 0.1 기능 목록</summary>\n\n1부터 9까지 서로 다른 수로 이루어진 3자리 수를 맞추는 야구 게임\n\n### 1. 1에서 9까지의 서로 다른 임의의 수를 3개 자동으로 생성한다.\n * 임의의 수는 `camp.nextstep.edu.missionutils`에서 제공하는 `Randoms` API 사용. 값 추출은 `pickNumberInRange()`를 활용한다.\n * 3자리 수는 서로 다른 수 이기 때문에 `중복 여부`를 확인하여 생성한다.\n\n### 2. 사용자에게 3자리 수를 입력 받는다.\n * 상대방(컴퓨터)은 입력 안내 메시지를 제공한다.\n\n### 3. 사용자의 입력을 바탕으로 볼, 스트라이크의 개수를 반환한다.\n * 같은 수만 n개 존재할 경우: `n볼`\n * 같은 수가 같은 자리에 n개 있는 경우: `n스트라이크`\n * 다른 자리에 같은 수가 n개, 같은 수가 같은 자리에 m개 있는 경우: `n볼 m스트라이크` \n * 같은 수가 전혀 없는 경우: `낫싱`\n\n### 4. 게임은 정답을 맞출 때 까지 반복된다.\n * 3스트라이크가 나오면 해당 게임은 종료된다.\n\n### 5. 게임이 종료되면 재시작, 애플리케이션 종료할 수 있다.\n * 사용자가 1을 입력하면 게임은 새로 시작한다.\n * 사용자가 2를 입력하면 게임은 즉시 종료된다. 즉 `애플리케이션이 종료`된다.\n\n### 6. 사용자가 잘못된 값을 입력할 경우 `IllegalArgumentException` 을 발생시킨다.\n * 해당 예외가 발생하면 `애플리케이션을 종료` 시킨다. 즉 게임을 더 이상 진행할 수 없다.\n</details>\n\n<details>\n<summary>ver 0.2 기능 목록</summary>\n\n1부터 9까지 서로 다른 수로 이루어진 3자리 수를 맞추는 야구 게임\n\n### 1. 1에서 9까지의 서로 다른 임의의 수를 3개 자동으로 생성한다.\n * 임의의 수는 `camp.nextstep.edu.missionutils`에서 제공하는 `Randoms` API 사용한다. 값 추출은 `pickNumberInRange()`를 활용한다.\n * 3자리 수는 서로 다른 수 이기 때문에 `중복 여부`를 확인하여 생성한다.\n\n### 2. 사용자에게 3자리 수를 입력 받는다.\n * 상대방(컴퓨터)은 입력 안내 메시지를 제공한다.\n * 3자리가 넘어가면 `IllegalArgumentException`을 던진다. ✚\n\n### 3. 사용자의 입력을 바탕으로 볼, 스트라이크의 개수를 반환한다.\n * 임의의 수와 입력값을 활용하여 볼, 스트라이크의 개수를 계산한다. ✚\n * 같은 수만 n개 존재할 경우: `n볼`\n * 같은 수가 같은 자리에 n개 있는 경우: `n스트라이크`\n * 다른 자리에 같은 수가 n개, 같은 자리에 같은 수가 m개 있는 경우: `n볼 m스트라이크`\n * 같은 수가 전혀 없는 경우: `낫싱`\n * 스트라이크 개수를 기준으로 게임 성공 여부를 반환한다. ✚\n\n### 4. 게임은 정답을 맞출 때 까지 반복된다.\n * 3스트라이크가 나오면 해당 게임은 종료된다.\n\n### 5. 게임이 종료되면 재시작, 애플리케이션 종료할 수 있다.\n * 사용자가 1을 입력하면 게임은 새로 시작한다.\n * 사용자가 2를 입력하면 게임은 즉시 종료된다. 즉 `애플리케이션이 종료`된다.\n\n### 6. 사용자가 잘못된 값을 입력할 경우 IllegalArgumentException 을 발생시킨다.\n * 해당 예외가 발생하면 `애플리케이션을 종료` 시킨다. 즉 게임을 더 이상 진행할 수 없다.\n</details>\n\n<details>\n<summary>ver 0.3 기능 목록</summary>\n\n1부터 9까지 서로 다른 수로 이루어진 3자리 수를 맞추는 야구 게임\n\n### 1. 1에서 9까지의 서로 다른 임의의 수를 3개 자동으로 생성한다.\n * 임의의 수는 `camp.nextstep.edu.missionutils`에서 제공하는 `Randoms` API 사용한다. 값 추출은 `pickNumberInRange()`를 활용한다.\n * 3자리 수는 서로 다른 수 이기 때문에 `중복 여부`를 확인하여 생성한다.\n\n### 2. 사용자에게 3자리 수를 입력 받는다.\n * 상대방(컴퓨터)은 입력 안내 메시지를 제공한다.\n * 잘못된 예외에 대한 예외 처리를 진행한다.\n     * 입력 받은 수가 3자리가 아니면 예외를 던진다. ✚\n     * 입력값이 숫자가 아니면 예외를 던진다. ✚\n     * 입력 받은 수 중 같은 수가 존재하면 예외를 던진다. ✚\n     * 입력 받은 수가 1 ~ 9 범위가 아니면 예외를 던진다. 즉 0이 될 수 없다. ✚\n\n### 3. 사용자의 입력을 바탕으로 볼, 스트라이크의 개수를 반환한다.\n * 임의의 수와 입력값을 활용하여 볼, 스트라이크의 개수를 계산한다. ✚\n * 같은 수만 n개 존재할 경우: `n볼`\n * 같은 수가 같은 자리에 n개 있는 경우: `n스트라이크`\n * 다른 자리에 같은 수가 n개, 같은 자리에 같은 수가 m개 있는 경우: `n볼 m스트라이크`\n * 같은 수가 전혀 없는 경우: `낫싱`\n * 스트라이크 개수를 기준으로 게임 성공 여부를 반환한다. ✚\n\n### 4. 게임은 정답을 맞출 때 까지 반복된다.\n * 3스트라이크가 나오면 해당 게임은 종료된다.\n\n### 5. 게임이 종료되면 재시작, 애플리케이션 종료할 수 있다.\n * 사용자가 1을 입력하면 게임은 새로 시작한다.\n * 사용자가 2를 입력하면 게임은 즉시 종료된다. 즉 `애플리케이션이 종료`된다.\n * 1과 2 이외의 입력이 주어지면 `IllegalArgumentException`을 던진다.\n\n### 6. 사용자가 잘못된 값을 입력할 경우 IllegalArgumentException 을 발생시킨다.\n * 해당 예외가 발생하면 `애플리케이션을 종료` 시킨다. 즉 게임을 더 이상 진행할 수 없다.\n</details>\n\n## 자바 코드 컨벤션 적용\n\n[캠퍼스 핵데이 Java 코딩 컨벤션](https://naver.github.io/hackday-conventions-java/)\n\n이번 프리코스에서는 코드 컨벤션 적용을 위해 위 링크를 참고하였다. 또한 빠른 적용을 위해 xml 파일까지 제공된다.\n\n현재 개발 m1 맥북 + intellij를 활용하여 개발을 진행하고 있다. 위 설정을 그대로 적용하고 git commit을 진행하면 tab size가 8로 적용되는 문제를 확인하였다. \n\n![](https://user-images.githubusercontent.com/59357153/143804973-88a32d76-6019-4cca-b8e2-56fe9ae36560.png)\n\n위 `Use tab character`를 해제하고 다시 commit을 진행하면 tab size가 정상적으로 적용된 것을 확인할 수 있었다.\n\n## 상수 사용\n\n문자열, 정수 등의 값을 하드 코딩하지 않고 static final을 활용하여 적용하였다. 해당 문자열, 숫자에 의도를 나타낼 수 있도록 노력하였다.\n\n```java\nprivate static final int NUMBERS_SIZE = 3;\nprivate static final int RANGE_MIN_NUMBER = 1;\nprivate static final int RANGE_MAX_NUMBER = 9;\n```\n\n## 역할, 책임, 협력에 기반하여 설계하기  \n객체들이 애플리케이션의 기능을 구현하기 위해 수행하는 상호작용을 `협력`이라고 한다. 객체가 협력에 참여하기 위해 수행하는 로직은 `책임`이라고 부른다. 객체들이 협력 안에서 수행하는 책임들이 모여 객체가 수행하는 `역할`을 구성한다. \n\n`오브젝트`를 읽으며 객체에게 적절한 책임을 부여하여 설계하도록 노력하였다.\n\n### BaseballNumbers: 서로 다른 임의의 수를 생성하기 위한 책임\n\n```java\npublic class BaseballNumbers {\n    private static final int NUMBERS_SIZE = 3;\n    private static final int RANGE_MIN_NUMBER = 1;\n    private static final int RANGE_MAX_NUMBER = 9;\n\n    private List<Integer> baseballNumbers = new ArrayList<>();\n\n    public BaseballNumbers() {\n        this.baseballNumbers = new ArrayList<>();\n        generateNumbers();\n    }\n\n    public List<Integer> getNumbers() {\n        return Collections.unmodifiableList(baseballNumbers);\n    }\n\n    private void generateNumbers() {\n        while (validateSize()) {\n            addRandomNumber(Randoms.pickNumberInRange(RANGE_MIN_NUMBER, RANGE_MAX_NUMBER));\n        }\n    }\n\n    private boolean validateSize() {\n        if (baseballNumbers.size() == NUMBERS_SIZE) {\n            return false;\n        }\n        return true;\n    }\n\n    private void addRandomNumber(int randomNumber) {\n        if (validateDuplicate(randomNumber)) {\n            baseballNumbers.add(randomNumber);\n        }\n    }\n\n    private boolean validateDuplicate(int randomNumber) {\n        if (baseballNumbers.contains(randomNumber)) {\n            return false;\n        }\n        return true;\n    }\n}\n```\n\n`BaseballNumbers`는 `1에서 9까지의 서로 다른 임의의 수를 3개 자동으로 생성하는 책임`만 가진다. 랜덤으로 생성된 List는 한 번 생성되면 게임이 진행되는 동안 내부 요소들이 변하지 않아야 한다. 때문에 List를 그대로 외부에 노출하는 것은 큰 리스크를 가지고 있다고 판단하였다. \n\n또한 `1에서 9까지 서로 다른 임의의 수를 3개를 가진 List`는 기존에 제공되는 자료구조가 아니다. 오직 숫자야구 게임이라는 비즈니스에 종속된 자료구조이다. 이러한 자료구조는 `일급 컬렉션`을 활용하여 구현하였다. 일급 컬렉션의 이점과 사용 이유에 대해 학습하는 좋은 계기가 되었다.\n\n### InputView: 사용자에게 입력 받는 책임\n\n```java\npublic class InputView {\n    private static final String INPUT_NUMBERS_MESSAGE = \"숫자를 입력해주세요 : \";\n    private static final String INPUT_RESTART_MESSAGE = \"게임을 새로 시작하려면 1, 종료하려면 2를 입력하세요.\";\n    private static final String INPUT_NUMBERS_DELIMITER = \"\";\n    private static final int INPUT_NUMBERS_SIZE = 3;\n    private static final String INPUT_RESTART_COMMAND = \"1\";\n    private static final String INPUT_END_COMMAND = \"2\";\n    private static final int INPUT_MIN_NUMBER = 1;\n    private static final int INPUT_MAX_NUMBER = 9;\n\n    public List<Integer> getInputNumbers() {\n        System.out.print(INPUT_NUMBERS_MESSAGE);\n        String inputNumbers = Console.readLine();\n        validateSize(inputNumbers.length());\n        validateDigit(inputNumbers);\n\n        List<Integer> numbers = toList(inputNumbers);\n        validateDuplicate(numbers);\n        validateNumberRange(numbers);\n        return numbers;\n    }\n\n    public boolean isRestart() {\n        String command = inputCommand();\n        validateCommand(command);\n\n        if (command.equals(INPUT_RESTART_COMMAND)) {\n            return true;\n        }\n        return false;\n    }\n\n    private void validateSize(int size) {\n        if (size != INPUT_NUMBERS_SIZE) {\n            throw new IllegalArgumentException(INVALID_SIZE.getMessage());\n        }\n    }\n\n    private void validateDigit(String inputNumbers) {\n        try {\n            Integer.parseInt(inputNumbers);\n        } catch (NumberFormatException e) {\n            throw new IllegalArgumentException(INVALID_NUMBER.getMessage());\n        }\n    }\n\n    private List<Integer> toList(String inputNumbers) {\n        return Arrays.stream(inputNumbers.split(INPUT_NUMBERS_DELIMITER))\n            .map(Integer::parseInt)\n            .collect(Collectors.toList());\n    }\n\n    private void validateDuplicate(List<Integer> numbers) {\n        Set<Integer> noneDuplicatedNumbers = new HashSet<>(numbers);\n        if (noneDuplicatedNumbers.size() != INPUT_NUMBERS_SIZE) {\n            throw new IllegalArgumentException(DUPLICATE_NUMBER.getMessage());\n        }\n    }\n\n    private void validateNumberRange(List<Integer> numbers) {\n        long size = numbers.stream()\n            .filter(i -> i >= INPUT_MIN_NUMBER && i <= INPUT_MAX_NUMBER)\n            .count();\n\n        if (size != INPUT_NUMBERS_SIZE) {\n            throw new IllegalArgumentException(INVALID_NUMBER_RANGE.getMessage());\n        }\n    }\n\n    private String inputCommand() {\n        System.out.println(INPUT_RESTART_MESSAGE);\n        return Console.readLine();\n    }\n\n    private void validateCommand(String command) {\n        if (!command.equals(INPUT_RESTART_COMMAND) && !command.equals(INPUT_END_COMMAND)) {\n            throw new IllegalArgumentException(INVALID_INPUT_COMMAND.getMessage());\n        }\n    }\n}\n```\n\n입력과 관련된 모든 책임이 부여된다. 사용자가 잘못된 입력을 시도할 경우 적절한 예외처리를 할 수 있도록 구현하였다. 아쉬운 점은 잘못된 입력에 대한 검증에 대한 책임까지 가지고 있기 때문에 너무 많은 책임을 부여한 것은 아닌지 고민이 되었다. \n\n결국 얻고자 하는 것은 `중복되지 않는 3개의 숫자`인데 이것을 이루기 위해서는 위에서 작성한 BaseballNumbers의 검증 방식과 상당 부분 중복 되고 있었다. `3개의 숫자를 관리하기 위한 책임`을 분리하는 것이 더 좋은지 고민하였지만 너무 세세하게 책임을 나누지 않기로 결정하였다.\n\n중복된 숫자인지 검증하기 위해 `Set`을 사용하였다. 입력된 숫자는 무조건 3자리를 보장해야 한다. 해당 숫자 리스트를 Set으로 변경한 뒤 size가 3보다 작으면 중복된 숫자가 있다고 판단하여 예외 처리를 진행한다.\n\n### BaseballReferee: ball, strike의 개수를 계산하는 책임\n\n```java\npublic class BaseballReferee {\n    private static final int ZERO_COUNT = 0;\n    private static final int START_INDEX = 0;\n    private static final int END_INDEX = 2;\n\n    public BaseballState referee(List<Integer> baseballNumbers, List<Integer> inputNumbers) {\n        int ballCount = calculateBall(baseballNumbers, inputNumbers);\n        int strikeCount = calculateStrike(baseballNumbers, inputNumbers);\n        return new BaseballState(ballCount - strikeCount, strikeCount);\n    }\n\n    private int calculateBall(List<Integer> baseballNumbers, List<Integer> inputNumbers) {\n        int originalSize = baseballNumbers.size() + inputNumbers.size();\n        Set<Integer> noneDuplicateNumbers = new HashSet<>();\n        noneDuplicateNumbers.addAll(baseballNumbers);\n        noneDuplicateNumbers.addAll(inputNumbers);\n        return originalSize - noneDuplicateNumbers.size();\n    }\n\n    private int calculateStrike(List<Integer> baseballNumbers, List<Integer> inputNumbers) {\n        int strikeCount = ZERO_COUNT;\n        for (int i = START_INDEX; i <= END_INDEX; i++) {\n            if (baseballNumbers.get(i).equals(inputNumbers.get(i))) {\n                strikeCount++;\n            }\n        }\n\n        return strikeCount;\n    }\n}\n```\n\n`BaseballReferee`은 이름처럼 `심판의 역할`을 진행한다. `referee` 메서드는 랜덤으로 생성된 baseballNumbers와 입력으로 주어진 inputNumbers를 활용하여 ball과 strike를 계산하여 ball과 strike의 개수를 관리하는 `BaseballState`를 반환한다.\n\nball 계산을 진행할 때 Set을 활용하였다. 중복된 숫자가 존재할 경우 합산한 size가 줄어 들기 때문에 줄어든 size 만큼 ball 개수라고 판단하였다.\n\n### BaseballState: 계산된 ball, strike의 개수를 관리하는 책임\n\n```java\npublic class BaseballState {\n    private static final String BALL = \"%d볼\";\n    private static final String STRIKE = \"%d스트라이크\";\n    private static final String BALL_AND_STRIKE = \"%d볼 %d스트라이크\";\n    private static final String NOTTING = \"낫싱\";\n    private static final int ZERO_COUNT = 0;\n    private static final int SUCCESS_STRIKE_COUNT = 3;\n\n    private final int ballCount;\n    private final int strikeCount;\n\n    public BaseballState(int ballCount, int strikeCount) {\n        this.ballCount = ballCount;\n        this.strikeCount = strikeCount;\n    }\n\n    public boolean isSuccess() {\n        if (strikeCount == SUCCESS_STRIKE_COUNT) {\n            return true;\n        }\n        return false;\n    }\n\n    public String getMessage() {\n        if (ballCount == ZERO_COUNT && strikeCount == ZERO_COUNT) {\n            return NOTTING;\n        }\n\n        if (ballCount == ZERO_COUNT) {\n            return String.format(STRIKE, strikeCount);\n        }\n\n        if (strikeCount == ZERO_COUNT) {\n            return String.format(BALL, ballCount);\n        }\n\n        return String.format(BALL_AND_STRIKE, ballCount, strikeCount);\n    }\n}\n```\n\n계산된 Ball, Strike의 개수를 관리하기 위한 책임을 가진 `BaseballState`이다. 단순히 `ballCount`, `strikeCount`를 get으로 반환하여 내부 특성을 노출하지 않도록 노력하였다. \n\n즉 외부에서 해당 특성을 활용한 비즈니스 로직을 사용하지 않고 모두 BaseballState `내부에서 처리`하도록 구현하였다. ballCount와 strikeCount 라는 특성을 활용하여 게임 성공 여부와 메시지를 생성하는 메서드를 제공한다. \n\n### GameMachine: 게임을 성공적으로 진행할 책임\n\n```java\npublic class GameMachine {\n    private final BaseballReferee baseballReferee;\n    private final InputView inputView;\n    private final OutputView outputView;\n\n    public GameMachine(BaseballReferee baseballReferee, InputView inputView, OutputView outputView) {\n        this.baseballReferee = baseballReferee;\n        this.inputView = inputView;\n        this.outputView = outputView;\n    }\n\n    public void run() {\n        BaseballNumbers baseballNumbers = new BaseballNumbers();\n        while (true) {\n            BaseballState state = baseballReferee.referee(baseballNumbers.getNumbers(), inputView.getInputNumbers());\n            outputView.outputRefereeResult(state.getMessage());\n\n            if (state.isSuccess()) {\n                outputView.outputSuccess();\n                restart();\n                break;\n            }\n        }\n    }\n\n    private void restart() {\n        if (inputView.isRestart()) {\n            run();\n        }\n    }\n}\n```\n\n게임을 진행할 책임을 가진 `GameMachine`이다. GameMachine은 다양한 객체에게 `메시지`를 보내며 `협력`을 이루고 있다. 한 예시로는 baseballState에게 ball, strike 계산을 위해 `referee` 라는 메시지를 전송하여 객체 간의 통신을 진행한다. 앞서 작성한 책임을 가지는 객체들이 모두 협력을 이루며 `하나의 숫자 야구 게임`을 이루는 중심축이 되었다.\n\n게임 반복을 위해서는 `while`을 활용한 반복문을 사용하였다.\n\n### OutputView: 출력을 담당하는 책임\n\n```java\npublic class OutputView {\n    private static final String END_MESSAGE = \"3개의 숫자를 모두 맞히셨습니다! 게임 종료\";\n\n    public void outputRefereeResult(String message) {\n        System.out.println(message);\n    }\n\n    public void outputSuccess() {\n        System.out.println(END_MESSAGE);\n    }\n}\n```\n\n최초에는 GameMachine에서 출력까지 모든 부분을 담당하였다. 하지만 `GameMachine`에게 오직 실행을 위한 책임을 갖도록 하기 위해 출력을 위한 책임을 분리하였다.\n\n## 테스트 코드 작성\n\n![](https://user-images.githubusercontent.com/59357153/143803451-e479ae65-f562-4e2c-877e-9cd9aaa6a889.png)\n\n`given-when-then` 패턴을 적용하여 단위 테스트를 진행하였다. 최대한 모든 코드를 커버할 수 있도록 꼼꼼하게 작성하려 노력했다. \n\n```java\nclass InputViewTest {\n\n    private static InputStream generateStream(String input) {\n        return new ByteArrayInputStream(input.getBytes());\n    }\n\n    @DisplayName(\"숫자를 입력하면 List를 반환한다.\")\n    @Test\n    void inputNumbersThenToList() {\n        // given\n        System.setIn(generateStream(\"123\"));\n        InputView inputView = new InputView();\n\n        // when\n        List<Integer> numbers = inputView.getInputNumbers();\n\n        // then\n        assertThat(numbers).isInstanceOf(List.class);\n    }\n\n    @DisplayName(\"입력한 숫자의 길이가 4이상이면 IllegalArgumentException을 던진다.\")\n    @Test\n    void sizeOverThrowIllegalArgumentException() {\n        // given\n        System.setIn(generateStream(\"1234\"));\n        InputView inputView = new InputView();\n\n        // when & then\n        assertThatThrownBy(() -> {\n            inputView.getInputNumbers();\n        }).isInstanceOf(IllegalArgumentException.class);\n    }\n    ...\n}\n```\n\n테스트 메서드 이름은 전부 `CamelCase`를 활용 했지만 가독성 측면에서 좋지 못하였다. 해당 테스트의 의도를 정확히 전달하기 위해 `@DisplayName` 애노테이션을 활용하여 가독성이 떨어지는 이름을 보완하려 노력하였다. \n\n## Refernces\n\n * 조영호, 『오브젝트』, 위키북스(2019), p73-96.\n\n### 코딩 컨벤션\n * [hackday-conventions-java](https://naver.github.io/hackday-conventions-java/)\n * [코딩 컨벤션 적용](https://hodol.dev/journal/coding-convention/)\n\n### 일급 컬렉션\n * [일급 컬렉션을 사용하는 이유](https://tecoble.techcourse.co.kr/post/2020-05-08-First-Class-Collection/)\n * [일급 컬렉션의 소개와 써야할 이유](https://jojoldu.tistory.com/412)\n\n### 테스트 코드\n * [System.in과 System.out에 대한 테스트](https://sakjung.tistory.com/33)\n * [[TDD] 단위 테스트(Unit Test) 작성의 필요성 (1/3)](https://mangkyu.tistory.com/143)\n"}]}},"pageContext":{}},"staticQueryHashes":[],"slicesMap":{}}