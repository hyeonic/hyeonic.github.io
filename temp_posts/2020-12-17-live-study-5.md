---
title: "5주차 과제: 클래스"
# excerpt: "GitHub Blog 서비스인 github.io 블로그 시작하기로 했다."

categories:
  - Java
  - Live-study
tags:
  - java
  - livestudy
  - 클래스
  - 객체
  - 메소드
  - this
  - super

last_modified_at: 2020-12-11 23:00:00 +0900
---

## 목표

자바의 Class에 대해 학습하세요.

---

## 학습할 것

 - 1. 클래스 정의하는 방법
 - 2. 객체 만드는 방법(new 키워드 이해하기)
 - 3. 메소드 정의하는 방법
 - 4. 생성자 정의하는 방법
 - 5. this 키워드 이해하기
 - 6. 과제 (optional) 

---

### 클래스, 객체

&nbsp; 5주차에서는 Java의 클래스 정의, 객체 생성 방법 등 클래스에 관하여 다루는 과제이다. 클래스는 간단히 말하면 객체를 만드는 틀이다. 객체라는 개념은 어떻게 생겨나게 되었는지 찾아보았다.

&nbsp; 객체를 주로 사용하는 객체 지향 프로그래밍 이전에는 코드를 위에서 부터 내려오며 실행되는 절차 지향 프로그래밍을 사용하였다. 하지만 이 절차 지향 프로그래밍은 많은 문제점을 야기 했다. 코드의 재사용성이 매우 떨어지고, 코드의 양이 길어 질 수록 유지 보수에 매우 취약해진다.

&nbsp; 이전의 개발자들은 절차 지향의 한계를 극복하기 위해 함수라는 개념을 도입하였다. 같은 로직을 가진 코드를 모아서 parameter를 전달하여 값을 반환 받는 형태로 만들었다.

&nbsp; 하지만 함수만으로도 한계가 있었다. 함수도 결국 코드의 양이 늘어나게 되면 많은 함수들이 뒤섞여 유지 보수에 어려움을 만들기 때문이다. 

&nbsp; 과거에는 수학계산이나 통계 처리 과정 같은 계산의 절차가 중요하였다. 현대에 와서는 실세계에서 발생하는 일을 프로그래밍으로 구현하는 일이 많아졌다. 실세계를 절차로 표현하는 것은 한계가 있었다.

&nbsp; 이렇게 기존의 프로그래밍 방식을 보완하여 실세계를 이루는 모든 물체, 객체라는 개념이 탄생하게 되었다. 객체는 데이터와 로직이 함께 구성되어 있는 실체이다. 객체의 데이터와 로직, 즉 속성과 행위는 객체 사이의 상호 작용을 표현하는데 매우 효과적이다. 

&nbsp; 절차 지향과 객체 지향을 자주 사용하는 스마트 폰에 비유해서 그림으로 표현하였다. 

&nbsp; 객체 지향 프로그래밍은 이러한 객체를 사용하여 작성된다. 객체 지향 프로그래밍에서는 추상화, 상속, 다형성 이라는 개념을 도입하였기 때문에 재사용성이 매우 높아졌다. 또한 객체를 캡슐로 감싸서 그 내부를 보호하여 데이터에 접근할 수 없게 만든다(정보의 은닉화). 몇몇의 함수, 메소드 만이 상호작용한다.

---

### 1. 클래스 정의하는 방법

#### 1.1 클래스란?

&nbsp; 클래스를 간단하게 정의하면 객체를 만들어 내는 틀이다. 그렇다면 객체는 무엇일까?

&nbsp; 객체란 상태와 동작을 가진 실체이다. Java는 클래스라는 틀 혹은 설계도를 가지고 객체를 생성해서 사용한다. 이러한 클래스와 객체를 사용하는 프로그래밍 방식을 객체 지향 프로그래밍이라고 한다.

&nbsp; Java에서 클래스는 상태를 나타내는 필드(field)와 행동을 나타내는 메소드(method)로 이루어져 있다. 필드는 클래스에 포함된 변수를 의미하고, 메소드는 특정 작업을 수행하는 명령문들의 집합이다.

#### 1.2 객체 object

&nbsp; Java에서 클래스를 사용하기 위해서는 클래스 타입 객체를 선언해야한다. Java에서 클래스로부터 객체를 선언하는 과정을 클래스의 인스턴스화 라고 한다. 이렇게 선언된 해당 클래스 타입의 객체를 인스턴스라고 한다. 

#### 1.3 객체 vs 인스턴스

&nbsp; 객체에 대해서 조사 하던 중 인스턴스 라는 용어가 자주 등장했다. 객체와 인스턴스의 차이가 궁금하여 찾아보았다. 

```java
public class Person {
    public Person() { }
}

public class Main {
    public static void main(String[] args) {
        Person kiHyeon; // 객체, 객체에 대한 레퍼런스 변수 kiHyeon 선언

        // 객체의 인스턴스화
        kiHyeon = new Person(); // 인스턴스, kiHyeon은 Person class의 인스턴스이다.
                                // 객체를 메모리에 할당
    }
}
```

__객체(object) 란__
 - 소프트웨어 세계에 구현할 대상
 - 클래스에 선언된 모양 그대로 생성된 실체

__인스턴스(instance) 란__
 - 설계도를 바탕으로 소프트웨어 세계에 구현된 구체적인 실체
 - 즉, 객체를 소프트웨어에 실체화 하면 그것을 인스턴스라고 부른다.
 - 실체화된 인스턴스는 메모리에 할당된다.

&nbsp; 객체지향 프로그래밍 관점에서 정리하면, 클래스의 타입 래퍼런스 변수로 선언되었을 때는 객체라 부르고, 그 객체가 메모리에 할당되어 실제 사용될 때는 인스턴스라고 부른다. 인스턴스는 객체에 포함되는 개념이라고 볼 수 있다. 객체는 클래스의 인스턴스이다. 객체는 실체에 초점을 맞추고, 인스턴스는 관계에 초점을 맞춘다.

&nbsp; 이러한 특징을 가지고 있지만 결국 클래스라는 설계도에서 구현된 대상들을 객체 혹은 인스턴스라고 구별 없이 사용되고 있다. 

참고 : [https://gmlwjd9405.github.io/2018/09/17/class-object-instance.html](https://gmlwjd9405.github.io/2018/09/17/class-object-instance.html)

#### 1.4 클래스 정의

&nbsp; 객체의 개념에 대해 이해가 되었으니, 객체를 생성하기 위한 설계도를 작성해보자. Java에서 클래스를 선언하기 위해서는 class라는 키워드가 사용된다.

&nbsp; C++에서는 클래스의 구성요소로 멤버 변수, 멤버 함수로 이루어져 있다 Java에서 클래스는 멤버 변수인 field와 멤버 함수인 method로 이루어져 있다. 이 글에서는 통일성을 주기위해 field와 method로 작성하였다. 

&nbsp; 밑의 코드는 간단하게 동물을 정의한 Animal 클래스이다.

```java
public class Animal { 
    private String name;
    private int age;

    public Animal() { }
    public Animal(String name, int age) {
        this.name = name; // java에서는 this 키워드가 생략 가능하다.
        this.age = age;
    }

    public String getName() {
        return this.name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return this.age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}
```

```java
(1)public (2)class (3)Animal 
```

 1. 클래스에 대한 접근 권한이 public임을 의미한다. public은 다른 클래스들이 Animal 클래스를 사용하고 접근할 수 있다는 의미이다.
 2. Animal이 클래스임을 의미하는 키워드이다.
 3. 클래스의 이름을 의미한다.

__field (필드)__
```java
private String name;
private int age;
```
 - 해당 클래스의 멤버변수, 즉 field를 의미한다. 객체 지향에서 상태를 나타내는데 사용된다.
 - private 키워드는 public과는 다르게 자신의 field와 method를 제외하고는 접근하거나 사용이 불가능하다.

__constructor (생성자)__
```java
public Animal() { }
public Animal(String name, int age) {
    this.name = name;
    this.age = age;
}
```

 - 클래스의 이름과 동일한 method를 생성자라고 한다. 생성자는 객체가 생성될 때만 호출되는 특수한 메소드이다. 생성자도 결국 method의 일종이다. 클래스 작성 시 생성자를 생략할 수 있다. 명시되어 있지 않으면 컴파일 시 자동적으로 default 생성자가 해당 클래스에 작성된다. defualt 생성자는 아무 일도 하지 않는다.

__method (메소드)__
```java
public String getName() {
    return this.name;
}

public void setName(String name) {
    this.name = name;
}

public int getAge() {
    return this.age;
}

public void setAge(int age) {
    this.age = age;
}
```

 - method는 실행 가능한 함수이고, 행위를 표현하는데 사용한다. public은 앞서 이야기한 접근 지정자와 동일하다. public 이 후 나오는 것은 해당 method의 return 타입을 의미한다. 기본 자료형 뿐만 아니라 클래스 타입 또한 가능하다.

---

### 2. 객체 만드는 방법(new 키워드 이해하기)

#### 2.1 객체의 생성과 레퍼런스 변수

&nbsp; 위의 Animal 클래스를 사용해서 객체를 생성하였다.

```java
Animal lion;
Animal dog = new Animal();
Animal cat = new Animal("nabi", 1);
```
 -- 그림 삽입

__래퍼런스 변수__

&nbsp; Animal 클래스의 레퍼런스 변수 선언
```java
Animal lion;
```
&nbsp; 레퍼런스 변수는 말그대로 객체를 가리키는 참조 변수이다. C++에서는 객체가 실제로 생성되고 lion 자체가 객체가 된다. 하지만 **Java에서 lion은 Animal 객체를 참조할 수 있는 변수이다.**

&nbsp; 현재는 어떤 객체도 가리키고 있지 않기 때문에 사용할 수 없다. 해당 객체를 사용하기 위해서는 **new 연산자를 통해 객체를 생성해야 한다.**


__객체 생성__

&nbsp; Animal 클래스의 레퍼런스 변수 선언 및 객체 생성
```java
Animal dog = new Animal();
Animal cat = new Animal("nabi", 1);
```

&nbsp; dog와 cat 모두 앞서 언급한 생성자와 new 연산자를 통하여 객체를 생성하고 레퍼런스 변수에 각각 대입한 것이다. 

&nbsp; new 연산자를 통하여 객체가 생성되는 과정을 정리하였다.
 - Animal 타입의 객체 메모리 공간을 확보한다. 
 - 생성자를 통하여 생성한다. 이때 작성한 생성자의 매개변수 타입에 따라 field 값을 초기화할 수 있다.
 - 대입 연산자를 통하여 레퍼런스 변수에 대입한다.

&nbsp; 각 객체를 출력하게 되면 레퍼런스 변수이기 때문에 해당 객체를 가리키는 실제 메모리 주소가 출력되는 것을 알 수 있다. lion의 경우 선언만 되어 있는 상태이기 때문에 사용할 수 없다. 혹은 아무것도 가리키지 않는 것을 의미하는 null을 대입하면 사용은 가능하다.

```java
lion = null;
System.out.println(lion);
System.out.println(dog);
System.out.println(cat);
```

```shell
null
me.hyeonic.week05.Animal@7f63425a
me.hyeonic.week05.Animal@36d64342 
```

#### 더 알아보기 stack 영역과 heap 영역

///////////////

#### 2.2 객체의 field와 method에 대한 접근

&nbsp; 객체의 field와 method에 접근하기 위해서는 . 연산자를 사용한다.

```java
System.out.println("dog.getName() : " + dog.getName());
System.out.println("dog.getAge() : " + dog.getAge());

System.out.println("cat.getName() : " + cat.getName());
System.out.println("cat.getAge() : " + cat.getAge());
```

```shell
dog.getName() : null
dog.getAge() : 0
cat.getName() : nabi
cat.getAge() : 1
```

&nbsp; dog의 경우 default 생성자를 통하여 생성된 객체이기 때문에 name과 age의 값이 설정되어 있지 않다. name 같은 경우 String 클래스 이기 때문에 기본적으로 null을 가리킨다. 기본 자료형 중 int는 앞서 배운 defualt 값인 0이 대입되어 있다.

&nbsp; cat의 경우 생성자에서 field의 값을 초기화 시켜주었기 때문에 값이 잘 들어 있는 것을 알 수 있다.

#### 2.3 객체 배열

&nbsp; 객체도 기본 배열처럼 배열 선언과 생성이 가능하다.

```java
Animal[] animals; // 객체 배열에 대한 레퍼런스 변수 선언
animals = new Animals[3]; // 크기가 3인 배열 생성. 배열의 원소는 객체에 대한 레퍼런스
```
```java
for (Animal animal : animals) {
    System.out.println(animal);
}
```
```shell
null
null
null
```
&nbsp; 현재 animals 배열의 각 객체는 아무것도 가리키고 있지 않는 상태이다. 추가적으로 객체를 대입하여 사용할 수 있다.

&nbsp; 생성된 배열을 사용하기 위해 초기화 해보자.

```java
for (int i = 0; i < animals.length; i++) {
    animals[i] = new Animal("mini", i);
    System.out.println("name : " + animals[i].getName());
    System.out.println("age : " + animals[i].getAge());
}
```
```shell
name : mini
age : 0
name : mini
age : 1
name : mini
age : 2
```

---

### 3. 메소드 정의하는 방법

#### 3.1 메소드의 형식

```java
public String getName() {
    return this.name;
}

public void setName(String name) {
    this.name = name;
}
```
&nbsp; Java에서 메소드는 접근 지정자, 리턴 타입, 메소드 이름, 매개 변수, 메소드 body 부분의 코드로 이루어져 있다.

 - 접근 지정자에는 public, protected, private와 생략된 경우 default로 scope에 따라 각자의 특성이 나뉜다. 간단하게 정리해보면,

 |접근 지정자|기능|
 |---|---|
 |public|클래스 내부와 외부에서 모두 호출 가능하다.|
 |protected|클래스 내부에서 메소드 호출이 가능하다. 외부에서 호출하기 위해서는 해당 클래스를 상속받은 서브 클래스만 가능하다.|
 |private|클래스 내부에서만 메소드 호출이 가능하다.|
 |defualt|접근 지정자가 생략된 형태이고, 동일한 패키지 내의 모든 클래스에서 호출이 가능하다.| 

 - 리턴 타입에는 해당 메소드가 연산을 통하여 나온 값을 반환할 때의 타입을 명시한다. 간단한 예시로 String의 경우 문자열을 반환해야 하고, void는 아무 것도 반환하지 않음을 의미한다.

 - 메소드의 이름은 임의로 작성이 가능하다. Java에서는 camelCase 표기법을 따른다. 소문자로 시작해야 하고 행위를 나타내는 동사로 작성하는 것을 권장한다. 

 - 메소드 코드는 메소드의 기능을 구현한 Java 코드가 들어 있다.

#### 3.2 값을 전달하는 call-by-value

&nbsp; 기본 타입의 자료형의 경우, 메소드의 인자로 값이 복사되어서 전달된다. 그렇기 때문에 원본 값은 영향을 주지 않는다.

```java
public static void increaseNumber(int a, int b) {
    ++a;
    ++b;
}

public static void main(String[] args) {

    int a = 1;
    int b = 2;

    increaseNumber(a, b);

    System.out.println("a : " + a);
    System.out.println("b : " + b);

} 
```
```shell
a : 1
b : 2
```

&nbsp; a와 b의 값이 1이 증가될 것을 기대 했지만 그대로 출력된다. 

#### 3.3 레퍼런스를 전달하는 call-by-reference

&nbsp; 메소드의 인자로 객체나 배열이 전달되는 경우에는 해당 객체나 배열을 가리키는 레퍼런스 값이 복사되어 전달된다. 객체의 주소가 전달되는 것 이기 때문에 인자와 파라미터 변수가 가리키는 객체는 같은 객체가 된다.

```java
public static class NewInt {
    int number;
}

public static void increaseNumber(NewInt a, NewInt b) {
    ++a.number;
    ++b.number;
}

public static void main(String[] args) {

    NewInt a = new NewInt();
    NewInt  b = new NewInt();

    System.out.println("a : " + a.number);
    System.out.println("b : " + b.number);

    increaseNumber(a, b);

    System.out.println("a : " + a.number);
    System.out.println("b : " + b.number);

}
```
```shell
a : 0
b : 0
a : 1
b : 1
```

&nbsp; 객체의 주소가 전달되었기 때문에 값이 증가하는 것을 알 수 있다. 배열의 경우에도 동일한 상황을 연출할 수 있다.

#### 3.4 메소드 오버로딩

&nbsp; 메소드 오버로딩이란 이름은 같지만 메소드의 인자의 타입과 개수, 반환 타입은 서로 다르지만 이름은 같은 메소드를 여러개 정의할 수 있다.

```java
public int getSum(int a, int b) {
    return a + b;
}

public double getSum(double a, double b) {
    return a + b;
}

public int getSum(int a, int b, int c) {
    return a + b + c;
}
```

---

### 4. 생성자 정의하는 방법

#### 4.1 생성자

&nbsp; 생성자는 객체가 생성될 때 초기화를 위해 실행되는 메소드의 한 종류이다. 생성자는 객체가 생성되는 시점에 자동적으로 호출된다. 메소드의 기능으로는 객체에 필요한 초기화를 수행하는 코드들이 들어있다.

&nbsp; 생성자의 특징으로는,
 - 클래스의 이름과 동일하다.
 ```java
 public Animal() {...}
 ```
 - new 연산자를 통하여 객체를 생성할 때 호출된다.
 ```java
 Animal dog = new Animal();
 ```
 - 메소드이기 때문에 오버로딩이 가능하다.
 ```java
 public Animal() {...}
 public Animal(String name, int age) {...} 
 ```
 - 반환타입을 지정할 수 없다. 하지만 값을 반환하지 않는 void와는 다르다.
 ```java
 public Animal(String name, int age) {
    this.name = name; 
    this.age = age;
 }
 ```

&nbsp; 생성자는 field를 초기화하는데 매우 유용하다. 객체를 생성하면 메모리 공간은 할당되지만 field의 값을 가지고 있지 않다. 생성자 오버로딩을 통하여 특정 field들을 초기화할 수 있다.

```java
public Animal(String name, int age) {
    this.name = name; 
    this.age = age;
}
```

&nbsp; name과 age값을 초기화 할 수 있는 생성자이다.

#### 4.2 생성자 사용 시 주의사항

&nbsp; 클래스에 생성자를 따로 정의하지 않으면 컴파일러로 인하여 default 생성자가 생성된다. 하지만 직접 생성자를 적게되면 defualt 생성자를 만들지 않는다. 

```java
public class Animal {
    public Animal(String name, int age) {...}
}
```
```java
Animal dog = new Animal();
```
&nbsp; 그렇기 때문에 위처럼 인자를 아무것도 전달하지 않는 default 형태로 생성 한다면 정상적으로 실행되지 않는 점을 유의해야 한다. 

&nbsp; 해결방안으로는 명시적으로 default 생성자를 명시적으로 작성해주면 된다.
```java
public class Animal {
    public Animal() {...}
    public Animal(String name, int age) {...}
}
```

#### 4.3 this()

&nbsp; this()는 클래스 내에서 다른 생성자를 호출할 때 사용된다.

```java
public class Animal {
    private String name;
    private int age;

    public Animal() {
        System.out.println("기본 생성자");
    }
    public Animal(String name, int age) {
        this();
        this.name = name; 
        this.age = age;
    }
}
```

```java
public class Main {

    public static void main(String[] args) {
        Animal lion = null;
        Animal dog = new Animal();
        Animal cat = new Animal("nabi", 1);
    }
}
```
```shell
기본 생성자
기본 생성자
```

&nbsp; 출력이 두번 나오는 것을 알 수 있다. 인자를 가진 생성자의 this()가 실행되는 것을 알 수 있다.

&nbsp; this()의 주의사항으로는,
 - this()는 생성자 코드내에서만 사용이 가능하다.
 - this()는 반드시 생성자 코드내에서 가장 먼저 사용되어야 한다.
 ```java
 public Animal() {
    System.out.println("기본 생성자");
 }
 public Animal(String name, int age) {
    this.name = name; 
    this.age = age;
    this(); // 컴파일 오류가 발생한다.
 } 
 ``` 

#### 4.4 delete?

&nbsp; Java에서는 C++과는 다르게 소멸자는 존재하지 않는다. 그렇기 때문에 개발자가 할당받은 메모리를 해제하기 위해서 소멸자를 작성할 필요가 없다. Java에서는 new로 할당받은 후 내부 알고리즘을 통해 사용하지 않는다고 판단한 객체를 JVM의 가비지 컬렉터(garbage collector)가 자동으로 해제시킨다.

&nbsp; 가비지 컬렉터(garbage collector)는 JVM내에서 자동으로 가비지 값들을 회수하여 메모리 공간을 늘린다. 이를 가비지 컬렉션(garbage collection)이라고 한다. 가비지 컬렉터(garbage collector)는 이를 수행하는 주체이고 JVM에서는 가비지 컬렉션 스레드(garbage collection thread)가 가비지 컬렉터(garbage collector)의 일을 담당한다. 

```java
Animal dog = new Animal();
Animal cat = new Animal();

dog = cat;
```

&nbsp; cat이 가리키던 객체는 더이상 아무도 참조하지 않기 때문에 가비지 콜렉터가 메모리를 회수한다.

```java
System.gc();
```
&nbsp; Java에서 가비지 컬렉션(garbage collection)을 강제로 수행하기 위해서는 위 처럼 작성하면 된다. 하지만 JVM에게 제안을 하는 것이고 즉시 가비지 컬렉션(garbage collection)이 실행되는 것은 아니다.

---

### 5. this 키워드 이해하기

&nbsp; this는 객체 자신을 가리킨다.

```java
public String getName() {
    return this.name;
}
```
&nbsp; this는 현재 객체에 대한 레퍼런스이고, this.name은 자신의 field인 name에 접근한 것이다.

```java
public String getName() {
    return name;
}
```
&nbsp; 동일한 이름의 변수가 존재하지 않으면 this가 생략가능하고, name은 this.name을 가리키게 된다.

```java
public void setName(String name) {
    this.name = name;
}
```
&nbsp; 위의 코드의 경우 인자로 들어온 name과 혼동될 것을 우려하여 this 키워드를 사용하여 자신의 field와 인자를 구분할 수 있다.

&nbsp; this는 자신의 래퍼런스 그 자체를 의미한다.
```java
Animal dog = new Animal("mini", 1);
Animal cat = new Animal("nabi", 2);

dog.setAge(2);
cat.setAge(3);
```
&nbsp; dog의 this는 자신의 age를 1에서 2로 변경하고, cat 또한 자신의 age를 2에서 3으로 변경한다. 

---

### 6. 과제 (optional) 

__요구 사항__
 - int 값을 가지고 있는 이진 트리를 나타내는 Node 라는 클래스를 정의하세요.
 - int value, Node left, right를 가지고 있어야 합니다.
 - BinrayTree라는 클래스를 정의하고 주어진 노드를 기준으로 출력하는 bfs(Node node)와 dfs(Node node) 메소드를 구현하세요.
 - DFS는 왼쪽, 루트, 오른쪽 순으로 순회하세요.

#### 6.1 이진 탐색 트리 (Binary Search Tree)

 - 각 노드는 키 값을 하나씩 가지며 값은 유일하다.
 - 최상위 레벨에 root node가 존재하고, 각 node는 이진 트리이기 때문에 최대 두개의 자식을 가진다.
 - 각 node의 키 값은 자신의 왼쪽 자식 node의 키 값보다 크고, 오른쪽 자식의 키값보다 작다.

&nbsp; 위의 전제 조건을 가지고 BinaryTree를 작성하였다.

/// 사진 첨부



#### 6.2 BFS Breadth First Search 너비 우선 탐색

 - 시작점부터 가까운 node부터 탐색한다. 즉 넓이를 우선적으로 탐색한다.
/// 사진 첨부

&nbsp; BFS는 Queue를 이용하여 구현한다. Queue는 FIFO(First In First Out)이다.  

#### 6.3 DFS Depth First Search 깊이 우선 탐색

 - root node에서 최대한 깊은 node를 탐색하고 반복한다. 즉 깊이를 우선적으로 탐색한다.
/// 사진 첨부

&nbsp; DFS는 Stack을 이용하여 구현한다. Stack은 LIFO(Last In First Out)이다.

