---
title: 다형성
tags: ['Java', '객체 지향의 4개 특성', '다형성']
---

# 다형성

객체 지향에서 `다형성`은 `오버라이딩`과 `오버로딩`이라고 할 수 있다. `상위 클래스와 하위 클래스 사이에서의 다형성`과 `인터페이스와 구현 클래스 사이의 다형성`을 이야기할 수도 있지만 가장 기본이 되는 것은 `오버라이딩`과 `오버로딩`이다.

::: tip
오버로딩은 다형성인지 아닌지에 대한 이견을 가지고 있다.
:::

## 오버라이딩

메서드 오버라이딩은 `상위 클래스`와 `하위 클래스` 사이에서 발생한다. 상위 클래스의 메서드를 동일한 이름으로 하위 클래스에 작성할 때 발생한다. 하위 클래스에 메서드를 `오버라이딩` 한 후 실행하게 되면 `동적 바인딩`이 일어나 상위 클래스의 메서드는 무시된다.

### Method Overriding 조건

 1. 메서드 오버라이딩은 상위 클래스의 메서드와 완전히 `동일한 메서드를 재정의`해야 한다. `메서드 이름`, `반환 타입`, `매개 변수`가 모두 같아야 한다.
 2. 메서드 오버라이딩 시 부모 클래스 메서드의 접근 지정자보다 범위가 좁아질 수 없다. `public` 메서드 인 경우 private, protected가 아닌 반드시 `public`으로 작성해야 한다.
 3. static, private, final로 선언된 메서드는 오버라이딩 될 수 없다.

### Overriding 예시

**Figure.java**
```java
// 도형 클래스
public class Figure { 

    private int x;
    private int y;

    public Figure() {
        System.out.println("Figure 생성자");
    }

    public Figure(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public int getX() {
        return this.x;
    }

    public void setX(int x) {
        this.x = x;
    }

    public int getY() {
        return this.y;
    }

    public void setY(int y) {
        this.y = y;
    }

    public void print() {
        System.out.println("Figure의 print");
    }
}
```

**Cycle.java**
```java
// 도형 클래스를 상속 받는 원 클래스
public class Cycle extends Figure { 

    private int radius;

    public Cycle() {
        super();
        System.out.println("cycle 생성자");
    }

    public Cycle(int x, int y, int radius) {
        super(x, y);
        this.radius = radius;
    }

    public int getRadius() {
        return this.radius;
    }

    public void setRadius(int radius) {
        this.radius = radius;
    }

    @Override 
    public void print() { // Figure 클래스의 print 메소드 오버라이딩
       System.out.println("Cycle의 print");
    }
}
```

## 오버로딩

이름은 같지만 `메서드의 인자의 타입과 개수`, `반환 타입`이 서로 다른 메서드를 여러개 정의할 수 있다. 컴파일러는 `메서드 시그니처`를 기반으로 메서드 오버로딩을 판단한다.

::: tip 메서드 시그니처
메서드의 이름 + 매개변수 리스트

반환 타입은 메서드 시그니처에 포함되지 않는다. 그렇기 때문에 서로 다른 반환 타입을 가져도 동일한 시그니처인 경우 메서드 오버로딩이 불가능하다.
:::

### Overloading 예시
```java
public int add(int a, int b) {
    return a + b;
}

public double add(double a, double b) {
    return a + b;
}

public int add(int a, int b, int c) {
    return a + b + c;
}
```

## 다형성이 가져오는 이점

다형성을 지원하지 않는 언어에서 두 숫자를 더해서 반환하는 메서드가 있다고 가정한다. 

```java
int add(int a, int b);
```

추가로 정수와 부동소수점 수를 더해서 반환하는 메서드가 필요해졌다고 가정하면 다른 메서드명을 활용하여 추가적인 메서드를 선언해야 한다.

```java
double addIntDouble(int a, double b);
```

Java에는 정수 자료형과 부동소수점 수 자료형을 합치면 7가지가 된다. 이 중 두 개의 형식을 조합하면 49가지가 된다. 만약 두 수를 더하는 모든 경우를 만족시키기 위해서는 49개의 메서드를 만들어야 한다.

또한 `오버라이딩`을 할 경우 하위 클래스의 메서드를 `자동으로 호출`해주기 때문에 깔끔한 코드를 유지 할 수 있다.

`다형성`을 활용하면 개발자들에게 많은 부분에서 `사용편의성`을 가져다 준다.

## References

김종민, 『스프링 입문을 위한 자바 객체 지향의 원리와 이해』, 위키북스(2015), p128-135.

<TagLinks />