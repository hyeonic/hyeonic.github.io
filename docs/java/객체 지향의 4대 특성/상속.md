---
title: 상속
tags: ['Java', '객체 지향의 4개 특성', '상속']
---

# 상속

## 객체 지향에서의 상속

보통 상속이라는 단어를 접하면 부모-자식 간의 상속 관계를 떠올리곤 한다. 하지만 객체 지향에서의 상속은 전혀 다른 의미를 가지고 있다.

<p align=center>
    <img src=https://user-images.githubusercontent.com/59357153/142366770-aac9fb64-7bb3-45fa-8c24-efbe69bf428b.png>
</p>

동물은 포유류와 조류의 부모가 아니다. 고래와 박쥐의 부모도 포유류는 아니다. 동물이라는 `분류`를 세분화하면 포유류가 나오고 포유류를 더 분류하면 고래, 박쥐가 나온다. `객체 지향에서의 상속`은 `상위 클래스의 특성을 하위 클래스에서 상속`하고 거기에 `필요한 특성을 추가`하여 사용할 수 있다는 것을 의미한다.

클래스의 `특성을 상속`하는 것이지 클래스를 상속한다고 받아들이면 부모-자식 관계로 인식하여 오해할 수 있다. 실제로 Java에서도 클래스 상속을 위해서는 `inheritance(상속)`라는 키워드가 아니라 `extends(확장)`라는 키워드를 사용하고 있다. 즉 필요한 특성을 추가하여 확장한다는 의미를 내포하고 있다.

보통 `상위 클래스`로 갈 수록 `추상화, 일반화`되었다고 표현하고, `하위 클래스`로 갈수록 `구체화, 특수화`되었다고 표현한다.

또한 객체 지향의 상속은 조직도나 계층도가 아닌 `분류도`로 생각하는 것이 바람직하다. 즉 아래와 같이 벤 다이어그램을 활용하면 확실히 이해할 수 있을 것이다.

<p align=center>
    <img src=https://user-images.githubusercontent.com/59357153/142368576-8b45c932-40c6-49fc-9bc3-c5037b72a2c4.png>
</p>

즉, `객체 지향의 상속`은 일반적인 부모-자식 간의 상속보다 `재사용과 확장`으로 이해하는 것이 바람직하다.

## 하위 클래스는 상위 클래스다.

객체 지향에서 상속 관계는 반드시 만족해야 하는 문장이 있다. 그것은 바로 `하위 클래스는 상위 클래스다.` 

부모-자식 관계를 예시로 들면 아래와 같다.
```
아버지는 아들이다.
어머니는 아들이다.
```

알다시피 아버지와 어머니는 아들이 아니다. 즉 문장이 `어색함`을 가지고 있다.

분류도를 기준으로 예시를 들면 아래와 같다.
```
포유류는 동물이다.
고래는 포유류다.
```

자연스러운 문장이 완성된다. 

## is a kind of 관계

상속은 흔히 `is a 관계`를 만족해야 한다고 한다. 이것을 기반으로 위의 분류도를 활용한 예시를 들어보면 아래와 같다.

```
펭귄 is 동물. 펭귄은 한 마리 동물이다.
```

하지만 여기서 펭귄도 `클래스`이고 동물도 `클래스`이다. 하지만 한 마리 동물은 `객체`이다. 즉 위 문장은 아래와 같이 변경 가능하다.

```
하위 클래스는 하나의 상위 클래스이다.
```

앞서 언급했듯이 하나의 상위 클래스는 객체이다. 다시 한 번 변경하면 아래와 같다.

```
하위 클래스는 하나의 객체이다?
```

즉 앞서 언급한 클래스와 객체 간의 관계를 설명하기에는 부족한 표현 방법이다.

### 더 명확한 표현

상속 관계를 더 명확하게 표현하기 위해서는 `is a kind of` 관계이다. 

```
펭귄 is a kind of 조류. 펭귄은 조류의 한 분류다.
```

전달하고자 하는 의도를 정확히 표현하였다. 펭귄이라는 조류라는 상위 분류의 한 분류일 뿐이다.

## 다중 상속

Java는 다중 상속을 지원하지 않는다. 다중 상속을 지원하지 않는 이유는 `다이아몬드 문제`를 야기하기 때문에 과감히 제외하엿다. 대신 인터페이스를 도입하여 다중 상속의 득을 취하고 있다.

::: tip 다이아몬드 문제
만약 스파이더맨이 사람과 거미를 상속했다고 가정하면 `걷다`라는 행위를 한다고 할 때 스파이더맨은 사람처럼 걸어야 할지 거미 처럼 걸어야 할지 고민하게 된다. 이러한 문제를 `다이아몬드 문제`라고 한다.
:::

## 인터페이스

Java에서는 인터페이스를 아래와 같이 사용한다. 

```
구현 클래스 is able to 인터페이스. 구현 클래스는 인터페이스 할 수 있다.
```

<p align=center>
    <img src=https://user-images.githubusercontent.com/59357153/142376315-9a46eb0a-264b-4de2-ad44-3ed228b21bc0.png>
</p>

```
고래는 헤엄칠 수 있다.
펭귄은 헤엄칠 수 있다.
```

인터페이스는 `~을 할 수 있는` 이라는 표현 형태로 만드는 것이 좋다. `Java API`에도 이러한 형식의 인터페이스를 볼 수 있다. 

```
Serializable: 직렬화할 수 있는
Cloneable: 복제할 수 있는
Comparable: 비교할 수 있는
Runnable: 실행할 수 있는
```

## 상속과 조합

### 상속

상속은 코드를 재사용하는 강력한 수단이지만 항상 최선의 방법은 아니다. 객체 사이의 관계를 너무 복잡하게 만들지만 근본적인 원인은 상속이 아니다. 상속을 완전히 배제하고 사용하지 않는 것 보다 `올바르게 사용`하는 것이 중요하다.

이러한 상속은 반드시 하위 클래스가 상위 클래스의 진짜 하위 타입인 상황에서만 쓰여야 한다.



### 조합

기존 클래스를 확장하는 대신 새로운 클래스를 만들고 private 필드로 기존 클래스의 인스턴스를 참조하게 한다. 

### 상속이 적절한 경우

상속이란 `코드의 재활용`을 위한 즉 `재사용`을 위한 개념은 아니다. 상속은 `연관된 일련의 클래스들에 공통적인 규약을 정의`하기 위해 사용하는 것이고 재사용의 관점보다는 `기능의 확장(extends)의 관점`이다. 따라서 명확한 IS-A 관계이고, 상위 클래스의 기능을 확장해 나가는 경우 사용하면 좋다. 하지만 처음 상속을 적용 했음에도 향후에 `상속의 단점`들이 보이게 된다면 그 때 리팩토링 과정을 통해 조합으로 전환한다.

더 나아가 상속이 더욱 적절한 경우는 클래스의 행동을 `확장(extend)`하는 것이 아니라 `정제(refine)할 때`이다. 확장이란 새로운 행동을 덧 붙여 기존의 행동을 부분적으로 보완하는 것을 의미하고 정제란 부분적으로 불 완전한 행동을 완전하게 만드는 것을 의미한다.

객체 지향 초기에 가장 중요하게 여긴 개념은 재사용성(reusability)였지만, 지금은 워낙 시스템이 방대해지고 잦은 변화가 발생하다 보니 `유연성(fexiblity)`이 더 중요한 개념이 되었다.

## References

김종민, 『스프링 입문을 위한 자바 객체 지향의 원리와 이해』, 위키북스(2015), p107-128.

<TagLinks />