{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"작성에 사용된 예제 코드는 testcontainers에서 확인해볼 수 있다. 대부분의 애플리케이션 서비스는 다른 서비스의 의존성을 가지고 운영된다. 간단한 예시로 데이터 저장을 위한 DB, 소셜 로그인을 위한 서버 호출 등을 통해 유기적으로 이루워져 있다.\n즉 하나의 독립적인 서버 환경에서는 원할한 서비스를 운영하는 것은 어려운 일이다.\n이러한 외부 의존…","fields":{"slug":"/testcontainers/"},"frontmatter":{"date":"March 18, 2024","title":"testcontainers","tags":["통합 테스트","testcontainers"]},"rawMarkdownBody":"\n> 작성에 사용된 예제 코드는 [testcontainers](https://github.com/hyeonic/blog-code/tree/main/testcontainers)에서 확인해볼 수 있다.\n\n대부분의 애플리케이션 서비스는 다른 서비스의 의존성을 가지고 운영된다. 간단한 예시로 데이터 저장을 위한 DB, 소셜 로그인을 위한 서버 호출 등을 통해 유기적으로 이루워져 있다.\n즉 하나의 독립적인 서버 환경에서는 원할한 서비스를 운영하는 것은 어려운 일이다.\n이러한 외부 의존성들은 애플리케이션 개발에 많은 편의성을 제공해주지만 우리가 제어할 수 없는 영역이 늘어날수록 통합 테스트에 대한 편의성은 줄어든다.\n\n> 통합 테스트란?\n>\n> 애플리케이션의 모든 구성 요소가 예상대로 작동하는지 확인하는 유형의 테스트이다.\n\n만약 우리가 `RDBMS` 중 하나인 `MySQL`을 활용하여 서비스의 데이터를 관리한다고 가정한다. 통합 테스트를 진행하려면 우리 서비스에 연동된 MySQL에 데이터를 CRUD 할 수 있어야 한다.\n이러한 DB 연동 방법에는 여러가지가 있는데 몇 가지 방법을 추려보았다.\n\n### 실제 운영 중인 DB에 직접 접근하여 통합 테스트\n\n실제 운영 중인 서비스에서 달성할 수 있는 가장 간단한 방법이다. 안정적으로 운영 중인 서버로 DB 드라이버를 연동하고 그대로 테스트 코드를 작성하면 된다.\n다만 이 방식의 가장 큰 단점은 실제 운영 데이터에 통합 테스트 중 발생한 데이터가 섞이게 되는 것이다.\n또한 테스트는 여러 번 수행 되더라도 동일한 결과를 보여줘야 하기 때문에 `멱등성`을 잘 지키는 것이 중요하다.\n\n> 멱등성\n>\n> 수학이나 전산학에서 연산의 한 성질을 나타내는 것으로, 연산을 여러 번 적용하더라도 결과가 달라지지 않는 성질\n\n이 멱등성을 지키기 위해서는 테스트 중 변경된 사항을 찾아 테스트 이전 상태로 바꿔줘야 한다. 이 작업은 DB 모델링에 따라 매우 복잡한 작업이 될 수 있다.\n또한 운영 중인 서비스 데이터에 직접적인 영향이 생길 수 있기 때문에 추천하지 않는 방법이다.\n\n### 임베디드 형태의 DB 활용\n\n일부 DB는 임베디드 형태의 테스트를 제공하기도 한다.\n\n* [h2database](https://github.com/h2database/h2database)\n* [wix-embedded-mysql](https://github.com/wix-incubator/wix-embedded-mysql)\n\n이러한 임베디드 형태의 DB는 스프링 서버와 라이프 사이클을 공유하기 때문에 `멱등성`을 지키기가 쉽다. 단순히 테스트를 진행할 때마다 DB 안에 모든 데이터를 초기화하면 되기 때문이다.\n또한 여러 명이서 한 프로젝트를 진행할 경우 추가적인 설정 없이 바로 서버 실행 및 테스트가 가능 하다는 장점이 있다.\n\n하지만 임베디드 형태의 DB의 경우 DB의 버전 변경에 적절히 대응해야 하지만 실제 DB 서버와는 차이가 있기 때문에 한계가 존재한다.\n실제 서비스에서 운영 중인 DB와 버전, 동작 방식이 다를 수 있기 때문에 실제와 유사한 환경에서 테스트하는데 한계가 있다.\n같은 결과가 나오길 기대 했지만 내부 동작 방식에 대한 차이로 인해 서로 다른 결과가 나올 가능성이 있기 때문이다.\n[wix-embedded-mysql](https://github.com/wix-incubator/wix-embedded-mysql) 문서를 살펴보면 지원이 중단된 것을 확인할 수 있다.\n\n![](./1.png)\n\n### 로컬에서 동일 버전 DB 설치\n\n다음은 로컬 환경에 운영 중인 DB 서버와 동일한 버전을 설치해서 연동하는 것이다. 서버를 직접 설치도 가능하고 도커와 같은 컨테이너 기술을 통해 실행하는 것도 가능하다.\n이 방식의 가장 큰 장점은 실제 운영 DB 서버와 동일한 환경에서 테스트할 수 있다는 것이다. 또한 로컬에서 수행되기 때문에 DB 테이블에 대한 조작을 자유롭게 할 수 있다.\n\n하지만 이에 대한 단점은 해당 프로젝트를 개발하는 모든 팀원이 개별적으로 설치하고 관리해야 한다는 것이다. 그나마 도커 컨테이너를 사용하면 도커 이미지를 통해 이러한 단점을 어느정도 상쇄시킬 수 있다.\n\n![](./2.png)\n\n### testcontainers 활용한 통합 테스트 환경 구성\n\n[testcontainers](https://testcontainers.com/)는 테스트 환경을 도커 컨테이너로 제공하는 라이브러리이다. 데이터베이스, 웹 서버, 카프카 등\n다양한 종류의 컨테이너를 코드 레벨에서 제공해준다. 이러한 컨테이너는 테스트를 실행하는 동안 초기화되고, 완료되면 자동으로 제거된다.\n즉 테스트 진행과 동일한 라이프사이클을 가지고 동작한다. 이를 통해 테스트 환경의 일관성을 유지하여 멱등성을 잘 지킬 수 있도록 도와준다.\n\n![](./3.png)\n\n간단한 예시 작성을 위해 아래와 같은 환경에서 진행하였다.\n\n* Spring Boot 3.2.2\n* Java 17\n* Testcontainers\n* Spring Data JPA\n* MySQL Driver\n* Spring Web\n\n![](./4.png)\n\n아래는 프로젝트 생성 이후 `build.gradle.kts` 파일을 가져온 것이다.\n\n```kotlin\nimport org.jetbrains.kotlin.gradle.tasks.KotlinCompile\n\nplugins {\n    id(\"org.springframework.boot\") version \"3.2.2\"\n    id(\"io.spring.dependency-management\") version \"1.1.4\"\n    kotlin(\"jvm\") version \"1.9.22\"\n    kotlin(\"plugin.spring\") version \"1.9.22\"\n    kotlin(\"plugin.jpa\") version \"1.9.22\"\n}\n\ngroup = \"c.hyeoni\"\nversion = \"0.0.1-SNAPSHOT\"\n\njava {\n    sourceCompatibility = JavaVersion.VERSION_17\n}\n\nrepositories {\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"org.springframework.boot:spring-boot-starter-data-jpa\")\n    implementation(\"org.springframework.boot:spring-boot-starter-web\")\n    implementation(\"com.fasterxml.jackson.module:jackson-module-kotlin\")\n    implementation(\"org.jetbrains.kotlin:kotlin-reflect\")\n\n    runtimeOnly(\"com.mysql:mysql-connector-j\")\n\n    testImplementation(\"org.springframework.boot:spring-boot-starter-test\")\n    testImplementation(\"org.springframework.boot:spring-boot-testcontainers\")\n    testImplementation(\"org.testcontainers:mysql\")\n    testImplementation(\"org.testcontainers:junit-jupiter\")\n}\n\ntasks.withType<KotlinCompile> {\n    kotlinOptions {\n        freeCompilerArgs += \"-Xjsr305=strict\"\n        jvmTarget = \"17\"\n    }\n}\n\nallOpen {\n    annotation(\"jakarta.persistence.Entity\")\n    annotation(\"jakarta.persistence.Embeddable\")\n    annotation(\"jakarta.persistence.MappedSuperclass\")\n}\n\ntasks.withType<Test> {\n    useJUnitPlatform()\n}\n```\n\n`Spring Boot`에서 `testcontainers`의 대한 지속적인 지원으로 편리하게 의존성을 추가하여 진행할 수 있다.\n특히 `Spring Boot 3.1` 이후 버전 부터는 `testcontainers`에 대한 지원이 더욱 향상되어 간단한 애노테이션 추가만으로 서버 구성이 가능해졌다.\n\n이제 통합 테스트를 진행하기 위해 MySQL 서버에 대한 세팅을 진행한다.\n\n```kotlin\n@ActiveProfiles(\"testcontainers\")\n@TestConfiguration(proxyBeanMethods = false)\nclass ContainersConfig {\n\n    @Bean\n    @ServiceConnection\n    fun mysqlContainer(): MySQLContainer<*> {\n        return MySQLContainer(DockerImageName.parse(\"mysql:latest\"))\n            .withDatabaseName(\"test-example\")\n            .withUsername(\"test\")\n            .withPassword(\"test\")\n            .withReuse(true)\n    }\n}\n\nfun main(args: Array<String>) {\n    fromApplication<TestcontainersApplication>()\n        .with(ContainersConfig::class)\n        .run(*args)\n}\n```\n\n이제 익숙하지 않은 몇 가지 설정을 살펴본다.\n\n* `@ActiveProfiles(\"testcontainers\")`: `testcontainers`와 관련된 설정을 모아두기 위해 `profile`을 분리하여 지정하였다.\n* `@ServiceConnection`: 해당 설정을 통해 `@Bean` 메서드에 컨테이너에서 실행 중인 서비스에 대한 연결을 자동으로 설정하도록 도와준다. 해당 애노테이션 덕분에 더욱 편리하게 설정이 가능해졌다.\n* `MySQLContainer`: 도커 이미지를 활용하여 `MySQL`을 손쉽게 조작하기 위한 용도이다. DB 접근을 위한 다양한 설정 정보를 기입할 수 있다.\n\n참고로 `testcontainers profile` 설정 정보는 아래와 같다.\n\n```yaml\nspring:\n  config:\n    activate:\n      on-profile: testcontainers\n\n  jpa:\n    open-in-view: false\n    hibernate:\n      ddl-auto: create-drop\n    properties:\n      hibernate:\n        format_sql: true\n    show-sql: true\n```\n\n이제 테스트를 위한 준비는 모두 마무리 되었다. 간단하게 해당 컨테이너를 활용하여 통합 테스트를 작성해본다.\n\n아래는 특정 멤버를 관리하기 위한 `Member Entity`이다. 간단한 검증을 위해 `id`, `name` 프로퍼티만을 가지고 있다.\n\n```kotlin\n@Entity\nclass Member(\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    var id: Long = 0L,\n    var name: String\n)\n```\n\n```kotlin\ninterface MemberRepository : JpaRepository<Member, Long>\n```\n\n`@DataJpaTest`를 활용하여 `Repository`에 대한 슬라이스 테스트를 진행한다. 간단히 `member`를 생성해본다.\n\n```kotlin\n@DataJpaTest\n@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)\n@Import(ContainersConfig::class)\n@ActiveProfiles(\"testcontainers\")\nclass MemberRepositoryIntegrationTest {\n\n    @Autowired\n    private lateinit var memberRepository: MemberRepository\n\n    @Test\n    fun saveTest() {\n        val member = Member(name = \"hyeonic\")\n\n        assertThatCode { memberRepository.save(member) }.doesNotThrowAnyException()\n    }\n}\n```\n\n* `@DataJpaTest`: JPA와 관련된 요소만 빈으로 등록한다.\n* `@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)`: `@DataJpaTest`를 사용하면 별도 설정 없이 자체적으로\n  생성된 임베디드 DB를 활용한다. 하지만 우리는 실제 도커 컨테이너에서 동작하는 MySQL에 접근하여 테스트해야 하므로 해당 설정을 변경한다.\n* `@Import(ContainersConfig::class)`: 별도 설정한 `Config`를 import한다. 앞서 언급한 것 처럼 `@DataJpaTest`는 JPA와 관련된 EntityManager,\n  Repository 등만 빈 등록 대상으로 활용한다.\n* `@ActiveProfiles(\"testcontainers\")`: 앞서 작성한 `application-testcontainers.yml`에 명시한 설정을 사용하기 위한 목적이다.\n\n`testcontainers`는 도커 컨테이너를 활용하여 테스트 환경을 구성한다. `도커 데스크탑`을 활용하여 `testcontainers`가 어떻게 MySQL 컨테이너를 활용하는지 확인해본다.\n\n![](./5.png)\n\n요상한 이름을 가진 두 개의 컨테이너가 자동으로 실행된 것을 확인할 수 있다. `mysql:latest`는 MySQL 컨테이너인 것을 알겠는데 `testcontainers/ryuk`은 무엇일까?\n\n`ryuk`의 주요 역할은 테스트가 완료된 후에 사용된 모든 리소스를 자동으로 정리한다. `ryuk`는 `testcontainers`가 시작될 때 함께 실행되며(예시에서는 테스트가 수행될\n때), `testcontainers`와 함께 생성된 모든 것들을 관리한다. 테스트 종료되면, `ryuk`는 해당 정보를 바탕으로 생성된 모든 리소스를 안전하게 정리하고 삭제한다.\n\n테스트가 완료된 후 도커 데스크탑을 확인해보면 깔끔하게 정리된 것을 확인할 수 있을 것이다. 물론 테스트도 성공한다!\n\n![](./6.png)\n\n## 마무리\n\n지금까지 `testcontainers`를 활용하여 통합 테스트 환경을 구축하는 방법에 대해 알아보았다. 해당 기술을 활용하면 실제 운영 중인 데이터베이스에 접근하지 않고도, 업데이트가 원할하게 되지 않는 임베디드\n데이터베이스를 활용하기 않고도 운영 환경과 동일하게 세팅하여 멱등성을 지키며 원할하게 테스트를 진행할 수 있다. 데이터베이스 뿐만 아니라 실제 연동하고 있는 웹 서버, 카프카 등에 대한 테스트도 도커 컨테이너를\n활용하여 별다른 서버 세팅 없이 편리하게 진행할 수 있다.\n\n다만 도커 컨테이너를 활용할 수 없거나 도커 레지스트리에 접근이 제한되는 환경인 경우 이미지를 원할하게 사용하지 못할 수 있다. 결국 사용하고자 하는 이미지가 접근 가능한 형태로 제공 되어야 한다는\n것이다. 결국 `testcontainers`는 도커라는 의존성을 활용한 테스트임을 인지하여야 한다.\n\n## References.\n\n* [멱등법칙](https://ko.wikipedia.org/wiki/%EB%A9%B1%EB%93%B1%EB%B2%95%EC%B9%99)\n* [improved-testcontainers-support-in-spring-boot-3-1](https://spring.io/blog/2023/06/23/improved-testcontainers-support-in-spring-boot-3-1)\n"},{"excerpt":"Spring Data JPA Auditing 작성에 사용된 예제 코드는 jpa-auditing에서 확인해볼 수 있다. 언어는 kotlin으로 작성하였다. Spring Data는 엔티티를 하거나 과 를 투명하게 추적할 수 있는 정교한 지원을 제공한다.\n해당 기능을 사용하기 위해서는 애노테이션을 사용하거나 인터페이스를 구현하여 정의할 수 있는 auditing…","fields":{"slug":"/jpa-auditing/"},"frontmatter":{"date":"March 08, 2023","title":"Spring Data JPA Auditing","tags":["kotlin","jpa","auditing"]},"rawMarkdownBody":"\n## Spring Data JPA Auditing\n\n> 작성에 사용된 예제 코드는 [jpa-auditing](https://github.com/hyeonic/blog-code/tree/main/jpa-auditing)에서 확인해볼 수 있다. 언어는 kotlin으로 작성하였다.\n\nSpring Data는 엔티티를 `생성`하거나 `변경한 사람`과 `변경이 발생한 시기`를 투명하게 추적할 수 있는 정교한 지원을 제공한다.\n해당 기능을 사용하기 위해서는 애노테이션을 사용하거나 인터페이스를 구현하여 정의할 수 있는 auditing metadata를 제공해야 한다.\n\n아래는 간단한 예시를 위한 Member 엔티티이다.\n\n```kotlin\n@Entity\nclass Member(\n    name: String\n) : BaseEntity() {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    var id: Long? = null\n        protected set\n\n    @Column\n    var name: String = name\n        protected set\n}\n```\n\n사용 방법은 정말 간단하다. 애노테이션만 몇 개 추가해주면 자동으로 생성과 수정 시점에 따라 값이 수정된다.\n\n```kotlin\n@EntityListeners(AuditingEntityListener::class)\n@Entity\nclass Member(\n    name: String\n) : BaseEntity() {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    var id: Long? = null\n        protected set\n\n    @Column\n    var name: String = name\n        protected set\n\n    @CreatedDate\n    @Column(nullable = false, updatable = false)\n    var createdDate: LocalDateTime = LocalDateTime.MIN\n        protected set\n\n    @LastModifiedDate\n    @Column(nullable = false)\n    var lastModifiedDate: LocalDateTime = LocalDateTime.MIN\n        protected set\n\n    @CreatedBy\n    @Column(nullable = false, updatable = false)\n    var createdBy: String = DEFAULT_MEMBER_NAME\n        protected set\n\n    @LastModifiedBy\n    @Column(nullable = false)\n    var lastModifiedBy: String = DEFAULT_MEMBER_NAME\n        protected set\n\n    companion object {\n        const val DEFAULT_MEMBER_NAME = \"default\"\n    }\n}\n```\n\n> 이번 글에서는 Auditing 기능에만 집중할 예정이므로 Kotlin과 JPA와 관련한 내용은 생략한다.\n\n* `@EntityListeners(AuditingEntityListener::class)`: Spring Data JPA는 auditing 정보 캡처를 트리거할 때 사용할 수 있는 `EntityListener`와\n  함께 제공된다. 사용할 엔티티에 `AuditingEntityListener`를 등록한다. 자세한 동작과정은 이후 살펴본다. 우선 auditing 기능을 위해서는 리스너를 등록해야 한다는 것만 알아두자.\n* `@CreatedDate`: 엔티티가 생성되어 저장될 때 시간이 자동으로 저장된다.\n* `@LastModifiedDate`: 엔티티가 변경되면 시간이 자동으로 수정된다.\n* `@CreatedBy`: 엔티티를 생성한 사람을 자동으로 넣을 수 있다. 해당 기능이 정상 작동하기 위해서는 `AuditorAware`를 빈으로 등록해야 한다. 자세한 사용 방법은 이후 살펴본다.\n* `@LastModifiedDate`: 엔티티가 변경되면 변경한 사람이 자동으로 수정된다. 정상 작동 방법은 `@CreatedBy`와 동일하게 이후 작성한다.\n\n엔티티마다 Auditing 기능을 위해 `createdDate`, `lastModifiedDate` 등을 매번 작성하는 것은 중복된 코드를 야기한다. 이것은 상속을 통해 개선이 가능하다.\n\n```kotlin\n@MappedSuperclass\n@EntityListeners(AuditingEntityListener::class)\nclass BaseEntity {\n\n    @CreatedDate\n    @Column(nullable = false, updatable = false)\n    var createdDate: LocalDateTime = LocalDateTime.MIN\n        protected set\n\n    @LastModifiedDate\n    @Column(nullable = false)\n    var lastModifiedDate: LocalDateTime = LocalDateTime.MIN\n        protected set\n\n    @CreatedBy\n    @Column(nullable = false, updatable = false)\n    var createdBy: String = DEFAULT_MEMBER_NAME\n        protected set\n\n    @LastModifiedBy\n    @Column(nullable = false)\n    var lastModifiedBy: String = DEFAULT_MEMBER_NAME\n        protected set\n\n    companion object {\n        const val DEFAULT_MEMBER_NAME = \"default\"\n    }\n}\n```\n\n```kotlin\n@Entity\nclass Member(\n    name: String\n) : BaseEntity() {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    var id: Long? = null\n        protected set\n\n    @Column\n    var name: String = name\n        protected set\n}\n```\n\n`BaseEntity()`를 상속하여 Member 엔티티가 더욱 간단해진 것을 확인할 수 있다. 이제 마지막으로 Auditing 기능을 활성화해준다.\n\n```kotlin\n@Configuration\n@EnableJpaAuditing\nclass JpaConfig\n```\n\n보통 Configuration 파일은 각 역할에 맞게 분리하여 관리한다. 이러한 방식의 장점은 슬라이스 테스트를 진행할 때 필요한 설정 빈만 활용하여 테스트를 진행할 수 있다. 자세한\n이유는 [8.3.33. User Configuration and Slicing](https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.testing.spring-boot-applications.user-configuration-and-slicing)\n에서 확인할 수 있다.\n\n아래는 간단한 repository와 service이다.\n\n**MemberRepository.kt**\n\n```kotlin\ninterface MemberRepository : JpaRepository<Member, Long>\n```\n\n**MemberService.kt**\n\n```kotlin\n@Service\nclass MemberService(\n    private val memberRepository: MemberRepository\n) {\n\n    @Transactional\n    fun save(member: Member): Member {\n        return memberRepository.save(member)\n    }\n}\n```\n\n간단한 테스트 코드를 작성한다.\n\n```kotlin\n@SpringBootTest\nclass MemberServiceTest @Autowired constructor(\n    private val memberService: MemberService\n) {\n\n    @Test\n    fun `member를 저장한다`() {\n        val name = \"hyeoni\"\n        val savedMember = memberService.save(Member(name))\n\n        val result = memberService.getOne(savedMember.id!!)\n\n        println(result)\n    }\n}\n```\n\n```console\nMember(id=1, name=hyeoni, createdDate=2023-03-06T22:21:16.911, lastModifiedDate=2023-03-06T22:21:16.911, createdBy='default', lastModifiedBy='default')\n```\n\n`createdDate`와 `updatedDate`를 살펴보면 테스트 시작 시간이 잘 등록된 것을 확인할 수 있다. 추가로 `createdBy`와 `lastModifiedBy`에는 생성 및 수정이 일어날 때\nmember의 name이 기록해야 하는 요구사항이 있다고 가정한다. 현재는 무슨 이유인지 모르겠지만 `Member Entity`에 기본적으로 설정된 값이 출력되는 것을 확인할 수 있다.\n\n```kotlin\n@SpringBootTest\nclass MemberServiceTest @Autowired constructor(\n    private val memberService: MemberService\n) {\n\n    @Test\n    fun `member를 저장한다 createdBy와 lastModifiedBy는 member의 name과 같다`() {\n        val name = \"hyeoni\"\n        val savedMember = memberService.save(Member(name))\n\n        val result = memberService.getOne(savedMember.id!!)\n\n        assertAll(\n            { assertThat(result.createdBy).isEqualTo(name) },\n            { assertThat(result.lastModifiedBy).isEqualTo(name) }\n        )\n    }\n}\n```\n\n![](./0.png)\n\n위 테스트는 실패한다. 가정한 요구사항을 수행하기 위해서는 추가적인 설정이 필요하다.\n\n## AuditorAware\n\n이것은 `AuditorAware`의 구현체를 `Bean`으로 등록하여 해결할 수 있다. 요구사항에 맞춰 해당 채워 넣을 값을 세팅한다. 보통은 `Spring Security`의 `Authentication`\n이나 `Session` 등 을 활용하여 구현하곤 한다. 아래는 실제 공식 문서에 있는 간단한 활용 예시이다.\n\n```java\nclass SpringSecurityAuditorAware implements AuditorAware<User> {\n\n    @Override\n    public Optional<User> getCurrentAuditor() {\n        return Optional.ofNullable(SecurityContextHolder.getContext())\n                .map(SecurityContext::getAuthentication)\n                .filter(Authentication::isAuthenticated)\n                .map(Authentication::getPrincipal)\n                .map(User.class::cast);\n    }\n}\n```\n\n간단한 예제를 위해 스레드별로 요청한 Member의 name을 저장하기 위해 `ThreadLocal`를 가진 `RequestContext`을 활용한다.\n\n```kotlin\nclass RequestContext {\n\n    companion object {\n        private val currentAuditorStore = ThreadLocal<String?>()\n\n        var currentAuditor: String\n            get() = currentAuditorStore.get() ?: \"default\"\n            set(currentAuditor) {\n                currentAuditorStore.remove()\n                return currentAuditorStore.set(currentAuditor)\n            }\n    }\n}\n```\n\n정말 간단한 예시이다. 자 이제 service 쪽도 저장하기 직전에 `RequestContext`에 값을 채워둔다.\n\n```kotlin\n@Service\n@Transactional(readOnly = true)\nclass MemberService(\n    private val memberRepository: MemberRepository\n) {\n\n    @Transactional\n    fun save(member: Member): Member {\n        RequestContext.currentAuditor = member.name\n        return memberRepository.save(member)\n    }\n}\n```\n\n이제 `RequestContext`에 저장된 `name`을 활용하여 `AuditorAware`를 구현하고 빈으로 등록한다.\n\n```kotlin\n@Configuration\nclass JpaConfig {\n\n    @Bean\n    fun auditorProvider(): AuditorAware<String> {\n        return AuditorAware {\n            Optional.of(RequestContext.currentAuditor)\n        }\n    }\n}\n```\n\n자 이제 아래 테스트를 다시 수행한다.\n\n```kotlin\n@SpringBootTest\nclass MemberServiceTest @Autowired constructor(\n    private val memberService: MemberService\n) {\n\n    @Test\n    fun `member를 저장한다 createdBy와 lastModifiedBy는 member의 name과 같다`() {\n        val name = \"hyeoni\"\n        val savedMember = memberService.save(Member(name))\n\n        val result = memberService.getOne(savedMember.id!!)\n\n        assertAll(\n            { assertThat(result.createdBy).isEqualTo(name) },\n            { assertThat(result.lastModifiedBy).isEqualTo(name) }\n        )\n    }\n}\n```\n\n![](./1.png)\n\n정상적으로 통과하는 것을 확인할 수 있다.\n\n## [번외] AuditingEntityListener\n\nAuditing 기능이 정상적으로 동작하기 위해서는 `@EntityListeners(AuditingEntityListener::class)`를 통해 리스너를 등록해야 한다. 엔티티의 메서드는 특정 엔티티 라이프\n사이클 이벤트의 알림을 수신하기 위한 콜백 메서드(e.g. `@PrePersist` 등)로 지정될 수 있다. 다만 클래스 단위로 범용적인 사이클 적용을 위해서는 리스너를 활용할 수 있다.\n\n실제 `AuditingEntitiyListener`를 살펴보자.\n\n```java\n\n@Configurable\npublic class AuditingEntityListener {\n    // ...\n    @PrePersist\n    public void touchForCreate(Object target) {\n        Assert.notNull(target, \"Entity must not be null!\");\n        if (handler != null) {\n            AuditingHandler object = handler.getObject();\n            if (object != null) {\n                object.markCreated(target);\n            }\n        }\n    }\n\n    @PreUpdate\n    public void touchForUpdate(Object target) {\n        Assert.notNull(target, \"Entity must not be null!\");\n        if (handler != null) {\n            AuditingHandler object = handler.getObject();\n            if (object != null) {\n                object.markModified(target);\n            }\n        }\n    }\n}\n```\n\n특정 시점에 `@PrePersist`와 `@PreUpdate`애노테이션이 명시된 메서드를 수행하는 것을 확인할 수 있다.\n\n## 정리\n\n지금까지 JPA Auditing 필요성과 사용 방법에 대해 알아보았다. 날짜와 관련한 필드는 `@CreatedDate`와 `@LastModifiedDate` 애노테이션을 통해 정말 빠르게 적용이 가능하다.\n다만 `@CreatedBy`와 `@LastModifiedBy`는 추가적으로 `AditorAware`를 빈으로 등록해야 한다.\n\n엔티티의 라이프 사이클 이벤트 알림을 수신하기 위한 애노테이션을 사용할 수 있다. 여러 엔티티에서 사용하는 것은 리스너를 생성하여 `@EntityListeners`에 등록한 뒤 사용할 수 있다.\n\n## References.\n\n* [5.1.9. Auditing](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#auditing)<br>\n* [Chapter 6. Entity listeners and Callback methods](https://docs.jboss.org/hibernate/stable/entitymanager/reference/en/html/listeners.html)<br>\n"},{"excerpt":"2022년은 내게 조금은 특별한 해이다. 단순히 기술적인 성장을 넘어 한 사람으로서의 가치관을 형성할 수 있었던 시기였다. 회고를 통해 지난 1년을 뒤돌아보며 점검할 수 있는 회고를 적어보려 한다. 우아한테크코스 2022년의 시작은 대부분의 시간을 할애한 우테코를 빼놓고 이야기할 수 없을 것 같다. 정말 하고 싶었던 교육이었기 때문에 2021년은 대부분의…","fields":{"slug":"/2022-retrospect/"},"frontmatter":{"date":"January 12, 2023","title":"조금 늦은 2022년 회고","tags":["회고"]},"rawMarkdownBody":"\n2022년은 내게 조금은 특별한 해이다. 단순히 기술적인 성장을 넘어 한 사람으로서의 가치관을 형성할 수 있었던 시기였다. 회고를 통해 지난 1년을 뒤돌아보며 점검할 수 있는 회고를 적어보려 한다.\n\n## 우아한테크코스\n\n2022년의 시작은 대부분의 시간을 할애한 우테코를 빼놓고 이야기할 수 없을 것 같다. 정말 하고 싶었던 교육이었기 때문에 2021년은 대부분의 시간을 개발자로의 성장보다 우테코에 지원하기 위한 기반을 다지는 시간이 대부분이었던 것 같다. 당장 내가 몰입하고 있다는 것을 증명해야 했기 때문에 깃허브와 블로그 관리에 큰 노력을 쏟았던 것 같다.\n\n![](./1.png)\n\n정말 운이 좋게 내가 했던 노력과 방향성이 우테코와 잘 맞아떨어져서 합격하게 되었다. 2022년은 시작이 좋다고 생각했다. 시작하는 2월까지는 정말 기쁜 마음으로 열심히 놀았다. 10개월을 지속해서 몰입해야 했기 때문에 마지막으로 놀 수 있는 순간이라고 생각했던 것 같다. 부끄럽게도 합격 이후부터 시작하기 전까지 내 커밋 그래프는 텅 비어있다.\n\n![](./2.png)\n\n## 지식을 재정립하는 시간들\n\n나는 전역 이후 비교적 이른 시기에 웹 백엔드 개발자의 진로를 결정했다. 정말 우연히 많고 많은 언어와 프레임워크 중에 java와 spring을 선택했다. 이러한 선택들로 우아한테크코스 시작 이전 부터 java와 spring에 대한 지식들을 꾸준히 쌓고 있었다. 물론 강의를 따라 했던 수준이지만 언어에 대한 사용법 정도는 알고 있었다.\n\n우테코 기간은 대부분의 시간을 기존에 알고 있던 지식을 다시 재정립하는 시간이었다. 단순히 알고 사용하는 것을 넘어 왜 등장했고, 어떠한 원리로 동작하는 지 등 원론적인 고민을 주로 했던 것 같다. 단순히 이야기하면 내가 작성한 코드에 근거를 만들기 위해 끊임없이 고민했다.\n\n가장 좋았던 것은 미션 위주의 코드 리뷰를 통한 방식을 꼽을 수 있을 것 같다. 누군가에게 내 코드를 리뷰 받는 다는 것은 굉장히 부끄러웠다. 하지만 실제 현업에 계신 분들이 직접 해주신다는 것을 듣고 굉장히 기대가 되었다. 더 좋았던 것은 단순히 정답을 알려주기보다 나의 의견을 먼저 물어 자연스럽게 내가 작성한 코드의 근거를 이끌어주셨다. \n\n![](./2022-restrospect/3.png)\n\n우테코는 가고자 하는 길을 잃어 방황하던 시절 적절한 타이밍에 길을 안내 해줄 나침반 같았다. 근거 없이 닥치는 대로 공부하던 과거와는 달리 항상 배움에는 근거가 있었고, 그 근거를 나눌 수 있는 환경을 만난 것이다. 그렇기에 2022년은 더욱 특별하게 기억되고 있다.\n\n## 몰아치는 새로운 인연들\n\n코로나 이후 대학도 대부분 비대면으로 진행했기 때문에 사람들과 대화하고 소통하는 기회가 많지 않았다. 특히 전역 이후 대부분의 아는 사람들과 지냈기 때문에 새로운 인연을 만들 기회가 많지 않았다. 그렇기 때문에 교육 초반 레벨 1 브리조, 연극, 페어 등 계속해서 새로운 사람들과 대화하는 자리가 끊임없이 이어져서 조금은 힘들었다. 아마 이때가 우테코 기간 중 가장 힘들었던 시기가 아니었나 싶다. 물론 사람 때문에 힘든 것이 아니라 그냥 오랜만에 이런 환경에 던져진 것이 익숙하지 않았다. 나는 이것을 극복하는 것이 올해의 가장 큰 목표로 자리 잡게 되었다.\n\n특히 불특정 다수 앞에서 이야기하는 것이 굉장히 두려웠기 때문에 이것을 가장 먼저 극복하고 싶었다. 우테코를 수료하기 위해서는 교육 기간 중 무조건 테코톡을 진행해야 했기 때문에 나에겐 많은 연습이 필요했다.\n\n가장 먼저 시도한 것은 토론회를 주최한 것이다. 또 누군가에게 찰떡같은 이름 까지 추천 받아 약 두 달간 [아고라](https://hyeonic.github.io/about/#%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8C%E1%85%A1%E1%84%83%E1%85%B3%E1%86%AF%E1%84%8B%E1%85%B4-%E1%84%8B%E1%85%B2%E1%84%8F%E1%85%AB%E1%84%87%E1%85%A1%E1%86%AF%E1%84%85%E1%85%A1%E1%86%AF-%E1%84%90%E1%85%A9%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%AC-%E1%84%8B%E1%85%A1%E1%84%80%E1%85%A9%E1%84%85%E1%85%A1)를 진행할 수 있었다. 다양한 주제에 대해 많은 이야기를 나눌 수 있었고, 이를 통해 내가 가진 지식이 결코 정답이 아님을 다시 한번 깨닫게 되었다. \n\n무엇보다 가장 크게 도움 된 것은 **내가 가진 생각을 잘 정돈해서 전달할 수 있는 역량**이다. 지금도 완벽한 것은 아니지만 어느 정도 두려움을 극복한 것 같다.\n\n![](./4.png)\n\n항상 찾아와서 함께 의견을 나눠준 크루들에게 고마웠다. 사실 남에게 자신의 시간을 할애하여 의견을 나누는 것은 쉽지 않은 일이라 생각된다. 그런데도 항상 찾아와 참여한 크루들과 먼저 나서서 발표를 준비해준 많은 크루들에게 감사한 마음을 가지고 있다.\n\n![](./5.png)\n\n우테코가 끝날쯤에는 한 크루가 토론 형식에서 세미나 형식으로 변경하여 운영해보는 것은 어떤지 제안했다. 급하게 진행되었지만 많은 크루들의 도움으로 잘 마무리할 수 있었다. 매주 진행할 때마다 생각보다 많은 크루들이 참여해줘서 굉장히 기쁘고 고마웠던 기억이 남는다. 어쩌면 쉽게 하지 못할 경험을 정말 많이 하고 떠난 것 같아서 굉장히 뿌듯한 시간이었다. 이번 회고를 통해 다시 한번 **감사한 마음을 전달**하고 싶다.\n\n## 협업에 임하는 자세\n\n2021년, 처음 진행했던 팀 프로젝트와 협업은 정말 미숙했다. 누군가와 의견을 나누며 함께 코드를 작성하는 것도 어려웠고, 별다른 근거도 없지만 그냥 내 의견을 강하게 주입하기도 했다. 또한 높은 목표 때문에 팀원들을 강하게 몰아치기도 했다. 물론 팀원과의 사이가 나쁜 것은 아니었지만(지금도 가끔 연락하면서 잘 지내고 있다) 지금 생각해보면 썩 좋은 팀원은 아닌 것 같아 미안한 감정이 크게 다가온다. 그렇기 때문에 2022년에 내가 만나는 페어와 팀원들을 위해 협업에 임하는 자세를 개선하고 싶었다.\n\n최대한 상대방의 의견을 잘 이끌어내기 위해 노력했다. 페어 혹은 팀원과 함께 액션 플랜을 세우고 그것을 달성하기 위해 노력했다. 혹여나 이전처럼 행동하지 않을지 우려되어 매일 회고도 진행했다. 형식적인 회고도 의식적으로 연습하다 보면 자연스럽게 솔직함을 표현하는 나를 발견할 수 있었다. 1년 전의 나를 생각하면 항상 포장하기 급급했는데, 정말 많은 부분이 바뀐 것을 실감할 수 있었다.\n\n운이 좋게도 페어로 매칭된 크루들과 달록 팀원들은 내가 하고자 한 것들을 대부분 실현할 수 있도록 도와주었다. 기술적으로는 특정 문제에 대해 다양한 이야기를 나눌 수 있어서 좋았다. 내가 가진 의견을 전달하기 위해 근거를 고민하는 시간도 좋았다. 특히 협업에 대한 가치관이 정말 많이 바뀌었다. 형식적인 대화를 나누며 코드를 선택하는 것이 아니라 함께 하는 사람과 지식을 치열하게 나누며 적절한 조화를 이룰 방법을 고민했다. 또한 내가 가진 지식이 잘못된 것일까 두려워 질문을 꺼리던 행동들과 대충 알고 있지만 어물쩍 넘어가는 등 안 좋던 습관들을 마주할 수 있었고, 의식적으로 고치기 위해 노력했다. 내게 페어와 팀 프로젝트는 **단순히 무언가를 함께 하는 것을 넘어 내가 가진 단점들을 마주하고 개선할 수 있는 기회**를 마련해주었다.\n\n![](./6.png)\n\n특히 달록 팀원들에게 항상 고마운 마음이 크다. 서로에 대한 장점과 개선점을 편하게 나눌 수 있는 환경도 좋았고, 그것을 빠르게 극복하기 위해 노력하는 부분들도 느껴졌기 때문에 프로젝트 기간 개발자로서의 성장과 나에 대한 성장을 함께 이룰 수 있었다. 당연히 안 맞는 부분도 있었다. 우연한 기회로 서로 다른 가치관을 가진 6명의 사람이 만났는데, 성향이 맞지 않는 것은 어찌 보면 당연한 일이다. 그럼에도 **서로가 안 맞는 부분은 우리가 함께 감당할 수 있는 부분**이기 때문에 더욱 특별하게 다가왔다.\n\n## 나를 있는 그대로 바라보기\n\n지금까지 항상 타인에게 비춰진 나를 고민하며 살아왔다. 특정 행동을 했을 때 나의 기분보다 타인의 기분을 먼저 신경 쓰곤 했다. 이런 성격 때문에 정작 내가 무엇을 할 때 행복하고, 무엇을 할 때 몰입하는지 알지 못했다. 정확히는 내 감정을 숨긴 채 외면하곤 했다.\n\n취업을 위해 인성 면접을 준비하는데 질문에 대한 답변을 포장하기 급급했다. 당연히 내가 가진 약점을 숨기는 것은 중요하지만 나라는 사람의 본질마저 숨긴 채 그저 그런 특색 없는 사람으로 만들어버린다. 내가 무엇을 할 때 가장 몰입하는지, 어떤 성향인 사람과 일을 할 때 더욱 좋은 시너지가 나오는 지 등은 중요하지 않고 그냥 좋은 사람처럼 비춰지도록 나를 설명했다. 결국 나는 어디에나 한 명쯤 존재하는 무색무취의 사람처럼 느껴졌다.\n\n한 크루의 조언으로 단순히 질문에 대한 답변을 작성하기보다 진짜 했던 경험과 느꼈던 감정들을 잘 나열해보라는 조언을 들을 수 있었다. 적다 보니 생각 보다 많은 경험을 했던 것을 그제야 알 수 있었고, 내가 무엇을 할 때 행복한지 고민해보는 시간도 가질 수 있었다. 나름 개성도 가지고 있더라. 내가 가진 지식을 공유할 때 행복한 나를 발견할 수 있었다. 단순히 공유를 넘어 다양한 이야기를 통해 내가 가진 근거를 구체화하는 과정이 너무 재밌게 느껴졌다. 그렇게 나는 **무언가를 나누며 함께 자라는 것을 좋아하는, 항상 배움에 목말라 있는 개발자**가 되었다.\n\n## 아쉬운 점\n\n가장 아쉬운 점은 우테코 후반에 끊임없이 이어지는 면접 일정으로 깊이 있는 공부를 많이 하지 못한 것이 가장 아쉽다. 단순히 문제와 정답을 외우기 위해 노력했기 때문에 금방 휘발되는 지식으로 남았다. 매주 꾸준하게 작성하던 블로그 글도 점차 주기가 길어졌다. 주기만 길어지면 다행이지, 퀄리티까지 떨어지는 것이 느껴졌다. 올해에는 좀 더 진득하게 잘 정돈된 글을 작성하고 싶다는 생각이 들었다.\n\n그 다음은 술을 너무 많이 마신 것이다. 오랜만에 오프라인 환경에서 다양한 사람들을 만나니 자연스럽게 술자리가 늘었다. 워낙에 술을 좋아하기도 하고, 사람들과 어울리는 것을 좋아하는 성격 탓에 정말 많은 술을 마셨다. 때문에 건강과 돈을 잃었지만 좋은 인연들을 만들어서 큰 후회는 없다. 다만 올 한해는 술을 취하려고 먹기보다 즐기면서 먹는 방법을 찾아보고 싶다. \n\n마지막은 운동이다. 원래도 운동을 썩 좋아하는 편은 아니었지만 그래도 전역 이후 꾸준히 즐겨왔다. 취준을 시작한 이후로 바쁘다는, 관리 포인트를 줄인다는 이유로 운동을 등한시했다. 결국 늘어가는 건 내 뱃살뿐이었다. 올해에는 내가 좋아하는 운동을 찾고 꾸준히 지속해보고 싶다. 미뤄둔 다이어트도 다시 시작해봐야겠다. \n\n## 올해의 계획\n\n2022년은 기술적인 성장과 함께 앞으로 어떤 개발자가 되고 싶은지 많이 고민할 수 있는 한해였다. 올해부터는 이제 내가 세운 장기적인 목표를 위해 시작하는 첫걸음과 같다.\n\n**회사에 잘 적응하고 기여하기**\n\n먼저 올해부터 몸담게 되는 회사에서 여러가지 기여를 하고 싶다. 10개월간 배웠던 다양한 지식과 소통 능력을 바탕으로 빠르게 적응하여 기여하는 것이 가장 큰 목표이다.\n\n**2022년 동안 했던 우테코 활동 리마인드**\n\n지난 10개월 동안 너무나 다양한 지식을 빠르게 훓고 지나갔다. 놓친 것은 없는지 차근차근 정리하며 내 것으로 만드는 시간이 필요하다.\n\n**매달 회고 적기**\n\n솔직함을 잘 나타내자. 꾸미지 않고 한 달간 느꼈던 감정을 잘 털어놓는 습관을 만들자. 나를 있는 그대로 바라보는 습관을 들여 내가 좋아하는 것과 싫어하는 것을 잘 정리하고 구체화 시켜 나만의 색깔을 꾸준히 만들어가자.\n\n**자체 블로그 만들기**\n\n어딘가 종속된 것이 아닌 내가 직접 만들고 꾸밀 수 있는 블로그를 만들고 싶다. 다만 프론트에 대한 지식이 부족하기도 하고, 디자인적 감각이 떨어져 쉽지 않을 것 같긴 하다. 그럼에도 꼭 상반기 안에는 만들고 싶다.\n\n...\n\n이 외에도 다양한 목표가 있지만 전부 달성하는 것은 힘들 것 같다. 최대한 우선순위를 잘 정돈해서 1년 뒤에 부끄럽지 않은 계획이 되었으면 좋겠다.\n\n## 마무리\n\n정말 오랜만에 회고다운 회고를 작성했다. 항상 바쁘다는 핑계로 나를 돌아볼 시간을 미뤄왔다. 이 회고 또한 써야지 써야지 하며 결국 1월 중순이 되어서야 마무리되었다.\n\n2022년은 개발자가 되기 위해 치열하게 고민했다. 2023년은 이제 진짜 개발자가 되어 치열하게 생존해야 한다. 무엇보다 **나를 가장 잘 아는 내가 되어 긍정적인 영향력을 펼치며 함께 일하고픈 개발자**가 되는 것이 올해의 가장 큰 목표이다.\n"},{"excerpt":"Java는 객체지향 언어이기 때문에 기본적으로 제공하는 이 아닌 경우 모두 로 구성되어 있다. 이것은 문자열도 마찬가지다. 다만 은 여타 다른 객체와 차이점을 가지고\n있다. 그것은 바로 을 지원한다는 것이다. 문자열 생성 방법 Java에서 문자열을 생성하는 방법에는 두 가지가 있다. 생성자를 활용한 방식 문자열 리터럴을 활용한 방식 생성자를 활용한 방식 …","fields":{"slug":"/java-string/"},"frontmatter":{"date":"December 11, 2022","title":"문자열 생성 방식 비교하기","tags":["Java","문자열"]},"rawMarkdownBody":"\nJava는 객체지향 언어이기 때문에 기본적으로 제공하는 `Primitive Type`이 아닌 경우 모두 `객체`로 구성되어 있다. 이것은 문자열도 마찬가지다. 다만 `문자열`은 여타 다른 객체와 차이점을 가지고\n있다. 그것은 바로 `문자열 리터럴`을 지원한다는 것이다.\n\n## 문자열 생성 방법\n\nJava에서 문자열을 생성하는 방법에는 두 가지가 있다.\n\n* 생성자를 활용한 방식\n* 문자열 리터럴을 활용한 방식\n\n### 생성자를 활용한 방식\n\n```java\nString name1 = new String(\"hyeonic\");\n```\n\n다른 객체 생성 방식과 동일하게 new 키워드를 통해 String 객체를 생성한다. 메모리 또한 Heap 영역에 할당된다.\n\n![](./1.png)\n\n생성자를 활용한 방식은 동일한 문자열로 생성하여도 heap 영역에 새롭게 할당된다.\n\n```java\nString name1 = new String(\"hyeonic\");\nString name2 = new String(\"hyeonic\");\n```\n\n![](./2.png)\n\n### 문자열 리터럴을 활용한 방식\n\n리터럴을 활용할 경우 heap 영역에 특수하게 존재하는 `String Constant Pool` 영역에 할당되게 된다.\n\n```java\nString name3 = \"hyeonic\";\nString name4 = \"hyeonic\";\n```\n\n![](./3.png)\n\n리터럴로 생성할 경우 동일한 문자열이면 `String Constant Pool`에 동일한 객체를 바라본다.\n\n## 문자열 비교\n\n생성자를 통해 생성한 문자열과 리터럴로 생성한 문자열을 비교해보자.\n\n```java\npublic class StringTest {\n    @Test\n    void 문자열을_비교한다() {\n        String name1 = new String(\"hyeonic\");\n        String name2 = \"hyeonic\";\n\n        assertThat(name1.equals(name2)).isTrue();\n        assertThat(name1 == name2).isFalse();\n    }\n}\n```\n\n`equals()` 메서드는 주로 동등성 비교를 위해 사용된다. 생성자로 생성했던 리터럴로 생성했던 문자열의 내용만 같다면 `true`를 반환한다. 실제 String이 재정의한 `equals()`를 살펴보면 그에\n대한 해답을 쉽게 찾을 수 있다.\n\n```java\npublic final class String\n        implements java.io.Serializable, Comparable<String>, CharSequence {\n    // ...\n    public boolean equals(Object anObject) {\n        if (this == anObject) {\n            return true;\n        }\n        if (anObject instanceof String) {\n            String aString = (String) anObject;\n            if (coder() == aString.coder()) {\n                return isLatin1() ? StringLatin1.equals(value, aString.value)\n                        : StringUTF16.equals(value, aString.value);\n            }\n        }\n        return false;\n    }\n    // ...\n}\n```\n\n우선 참조 주소를 비교하여 같다면 `true`를 반환한다. 아니라면 동일한 문자 시퀀스인지 확인한다.\n\n생성자를 통한 방식과 리터럴을 활용한 방식이 heap 영역에 서로 다른 객체를 바라보기 때문에 참조 주소를 비교하여 동일성을 확인하는 `==`는 `false`가 반환된다.\n\n## 문자열 리터럴은 어떻게 생성될까?\n\n문자열 리터럴을 사용할 경우 내부적으로 `String`의 `intern()` 메서드를 활용하게 된다.\n\n```java\npublic final class String\n        implements java.io.Serializable, Comparable<String>, CharSequence {\n    // ...\n    public native String intern();\n    // ...\n}\n```\n\n`intern()` 메서드가 호출될 때 풀에 `equals()` 메서드에 의해 결정된 대로 이 String 객체와 동일한 문자열이 포함되어 있으면 풀의 문자열이 반환된다. 그렇지 않으면 이 String 객체가 풀에\n추가되고 String 객체에 대한 참조가 반환된다.\n\n## 그렇다면 hashCode()는?\n\n같은 값을 가지는 생성자 방식의 문자열과 리터럴 방식의 문자열의 `hashCode()`를 비교하면 어떤 결과가 나올까? 바로 확인해보자.\n\n```java\npublic class StringTest {\n    @Test\n    void hashCode를_비교한다() {\n        String name1 = new String(\"hyeonic\");\n        String name2 = \"hyeonic\";\n\n        assertThat(name1.hashCode() == name2.hashCode()).isTrue();\n    }\n}\n```\n\n같은 문자열 값을 가진 두 문자열의 `hashCode()`를 비교할 경우 같다는 결과가 나온다. 추측컨데 두 문자열 모두 값을 기반으로 `hashCode()`를 생성하기 때문에 이러한 결과가 나온 것으로 판단한다.\n\n실제 String에 `hashCode()` 구현부를 살펴보면 재정의한 것을 확인할 수 있다. 핵심은 같은 문자열인 경우 같은 `hashCode()`를 반환할 수 있다는 것을 의미한다.\n\n```java\npublic final class String\n        implements java.io.Serializable, Comparable<String>, CharSequence {\n    // ...\n    public int hashCode() {\n        int h = hash;\n        if (h == 0 && value.length > 0) {\n            hash = h = isLatin1() ? StringLatin1.hashCode(value)\n                    : StringUTF16.hashCode(value);\n        }\n        return h;\n    }\n    // ...\n}\n```\n\n```java\nfinal class StringLatin1 {\n    // ...\n    public static int hashCode(byte[] value) {\n        int h = 0;\n        for (byte v : value) {\n            h = 31 * h + (v & 0xff);\n        }\n        return h;\n    }\n    // ...\n}\n```\n\n```java\nfinal class StringUTF16 {\n    // ...\n    public static int hashCode(byte[] value) {\n        int h = 0;\n        int length = value.length >> 1;\n        for (int i = 0; i < length; i++) {\n            h = 31 * h + getChar(value, i);\n        }\n        return h;\n    }\n    // ...\n}\n```\n\n> 두 가지 타입으로 구분된 이유는 Jdk 9부터 새롭게 도입된 Compact String으로 인해 바이트 배열 기반으로 구현되어 있기 때문이다. 문자열에 따라 Latin-1 혹은 UTF-16으로 인코딩된 문자를\n> 저장한다. 자세한 내용은 따로 다룰 예정이다.\n\n그렇다면 문자열이 실제로 저장되는 주소 값을 어떻게 확인할 수 있을까? String이 저장된 실제 주소값을 확인하는 방법은 `System.identityHashCode()`를 사용하는 것이다.\n\n```java\npublic class StringTest {\n    @Test\n    void 실제_주소를_비교한다() {\n        String name1 = new String(\"hyeonic\");\n        String name2 = \"hyeonic\";\n\n        assertThat(System.identityHashCode(name1) != System.identityHashCode(name2)).isTrue();\n    }\n}\n```\n\n실제로 두 주소는 같지 않다. 즉 두 String 객체가 별도로 저장되는 것을 확인할 수 있는 부분이다.\n\n## 정리\n\n지금까지 문자열 생성 방식에 따른 차이를 확인하였다. 생성자를 활용할 경우 매번 새롭게 heap 영역을 할당한다. 리터럴를 활용할 경우 heap 영역에 String Constant Pool에서 관리되기 때문에 같은\n값을 가진 문자열인 경우 기존의 주소를 공유해서 사용한다. 리터럴로 생성한 문자열은 기본적으로 공유된다. 그렇기 때문에 String은 Java의 대표적인 불변 객체이다.\n\n정리하면 문자열 리터럴 사용 시 메모리 측면에 많은 이점을 가져올 수 있다. 만약 같은 문자열 값을 가진 String을 100만 개 생성한다고 가정해본다. 생성자를 사용할 경우 100만 개의 문자열 객체가 생성되는\n것이지만 리터럴은 단 1개의 문자열만 생성하고 공유한다. 문자열 생성은 리터럴를 적극 활용하자!\n\n## References.\n\n[Class String](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html)<br>\n[자바의 String 객체와 String 리터럴](https://madplay.github.io/post/java-string-literal-vs-string-object)<br>\n[소소한 백엔드 개발 이야기 97](https://brunch.co.kr/@springboot/704)<br>\n[[번역] Compact Strings in Java 9](https://xlffm3.github.io/java/compact-string/)\n"},{"excerpt":"작성에 사용된 예제 코드는 spring-transaction에서 확인해볼 수 있다. 이전 시간에 트랜잭션 추상화를 통해 여러 데이터 접근 기술 변경에 유연한 구조를 만들었다. 또한 트랜잭션 동기화를 통해 멀티 스레드 환경에서도 별도의 커넥션 객체를 사용하여 독립적으로 트랜잭션이 적용될 수 있도록 구현하였다.  이번 시간에는 템플릿 콜백 패턴을 활용한 과 …","fields":{"slug":"/spring-transaction-2/"},"frontmatter":{"date":"December 10, 2022","title":"스프링이 개선한 트랜잭션 (2)","tags":["스프링","트랜잭션"]},"rawMarkdownBody":"\n> 작성에 사용된 예제 코드는 [spring-transaction](https://github.com/hyeonic/blog-code/tree/main/spring-transaction)에서 확인해볼 수 있다.\n\n이전 시간에 트랜잭션 추상화를 통해 여러 데이터 접근 기술 변경에 유연한 구조를 만들었다. 또한 트랜잭션 동기화를 통해 멀티 스레드 환경에서도 별도의 커넥션 객체를 사용하여 독립적으로 트랜잭션이 적용될 수 있도록 구현하였다. \n\n이번 시간에는 템플릿 콜백 패턴을 활용한 `TransactionTemplate`과 스프링 AOP를 활용한 선언적 트랜잭션인 `@Transactional`을 활용한 트랜잭션 로직 분리에 대해 알아보려 한다.\n\n## TransactionTemplate\n\n프로그래밍 방식의 트랜잭션 구분 및 트랜잭션 예외 처리를 단순화하는 템플릿 클래스이다. `execute()` 메서드에 `TransactionCallback` 인터페이스를 구현한 구현체를 전달하여 트랜잭션을 수행할 수\n있다.\n\n```java\npublic class AccountService {\n    // ...\n    public void withdraw(final Account account, final Long amount) {\n        transactionTemplate.executeWithoutResult(\n                transactionStatus -> jdbcAccountRepositoryV3.update(generateAccount(account, amount))\n        );\n    }\n    // ...\n}\n```\n\n> `executeWithoutResult()`는 return이 존재하지 않는 `execute()`이다. `TransactionOperations` 인터페이스에 `default` 메서드로 명시되어 있다.\n\n`TransactionTemplate` 덕분에 트랜잭션 시작과 커밋, 롤백에 대한 로직이 전부 제거되었다. `execute()` 메서드를 간단히 요약하면 아래와 같다.\n\n```java\npublic class TransactionTemplate extends DefaultTransactionDefinition\n        implements TransactionOperations, InitializingBean {\n    // ...\n    public <T> T execute(TransactionCallback<T> action) throws TransactionException {\n        // ...\n        T result;\n        try {\n            result = action.doInTransaction(status);\n        } catch (RuntimeException | Error ex) {\n            // Transactional code threw application exception -> rollback\n            rollbackOnException(status, ex);\n            throw ex;\n            // ...\n            this.transactionManager.commit(status);\n            return result;\n        }\n        // ...\n    }\n    // ...\n}\n```\n\n실제 코드는 더 복잡하게 되어있지만 핵심은 매개변수로 전달된 구현체의 메서드 `action.doInTransaction(status)`를 수행한다. 구현체 내부에는 우리가 작성한 비즈니스 로직이 담겨 있다. 만약\n로직 수행 중 예외가 터질 경우 롤백한다. 정상적으로 수행되면 커밋한다.\n\n하지만 아직도 비즈니스 로직과 트랜잭션 기능이 하나의 클래스에 존재하고 있다. 어떻게하면 트랜잭션에 대한 의존성을 최소화할 수 있을까? 어떻게하면 service 계층에 비즈니스 로직만 순수하게 남길 수 있을까?\n\n## 트랜잭션 AOP\n\nservice 계층에 비즈니스 로직만 순수하게 남길 수 있는 방법은 트랜잭션이라는 부가기능을 프록시로 분리하는 것이다.\n\n```java\npublic interface AccountService {\n\n    void withdraw(final Account account, final Long amount);\n}\n```\n\n먼저 행위를 명시해둔 AccountService 인터페이스이다. 실제 비즈니스 로직 명시를 위한 구현체를 추가한다.\n\n```java\n\n@Service\npublic class AppAccountService implements AccountService {\n\n    private final JdbcAccountRepository jdbcAccountRepositoryV4;\n\n    public AppAccountService(final JdbcAccountRepository jdbcAccountRepositoryV4) {\n        this.jdbcAccountRepositoryV4 = jdbcAccountRepositoryV4;\n    }\n\n    public void withdraw(final Account account, final Long amount) {\n        jdbcAccountRepositoryV4.update(generateAccount(account, amount));\n    }\n\n    private Account generateAccount(final Account account, final Long amount) {\n        return new Account(account.getId(), account.getHolder(), account.getAmount() - amount);\n    }\n}\n```\n\n트랜잭션에 대한 부가기능을 추가하기 위해 프록시 객체를 추가한다.\n\n```java\n\n@Service\npublic class AccountServiceProxy implements AccountService {\n\n    private final TransactionTemplate transactionTemplate;\n    private final AccountService accountService;\n\n    public AccountServiceProxy(final PlatformTransactionManager platformTransactionManager,\n                               final AccountService accountService) {\n        this.transactionTemplate = new TransactionTemplate(platformTransactionManager);\n        this.accountService = accountService;\n    }\n\n    @Override\n    public void withdraw(final Account account, final Long amount) {\n        transactionTemplate.executeWithoutResult(transactionStatus -> accountService.withdraw(account, amount));\n    }\n}\n```\n\n이제 실제 사용 측은 프록시 객체를 활용하면 되기 때문에 두 관심사를 비즈니스 로직을 담은 객체와 프록시 객체로 나눌 수 있게 되었다. 하지만 매번 트랜잭션 적용을 위해 프록시 객체를 매번 생성하는 것은 매우 고된\n일이다.\n\n스프링은 AOP를 활용하여 매우 편리하게 프록시를 적용할 수 있다. 또한 스프링이 트랜잭션과 관련된 AOP를 이미 만들어두었기 때문에 우리는 편리하게 가져다 사용하기만 하면 된다.\n\n### @Transactional\n\n개별 메서드 또는 클래스에 대한 트랜잭션 특성을 설명한다. 이 애노테이션이 클래스 수준에 선언되면 선언 클래스 및 해당 하위 클래스의 모든 메서드에 기본값으로 적용된다. 개별적인 트랜잭션 처리가 필요한\n곳에 `@Transactional`만 활용하면 트랜잭션 AOP가 이 애노테이션을 인식하여 자동으로 트랜잭션 프록시를 적용해준다.\n\n```java\n\n@Service\npublic class AccountService {\n    // ...\n    @Transactional\n    public void withdraw(final Account account, final Long amount) {\n        jdbcAccountRepositoryV5.update(new Account(account.getId(), account.getHolder(), account.getAmount() - amount));\n    }\n}\n```\n\n`@Transactional` 애노테이션을 통해 선언적 트랜잭션을 적용하기 위해서는 AOP와 Spring에서 제공하는 AOP에 대한 전반적인 지식이 필요하다. 이 부분은 추가적인 학습 이후 별도의 포스팅을 남길\n예정이다.\n\n## 정리\n\n지금까지 service 계층에 있는 비즈니스 로직과 트랜잭션과 관련된 두 가지 관심사를 분리하기 위해 스프링이 어떤 방법을 활용했는지 알아보았다. 인터페이스를 활용한 추상화와 스레드 별도의 저장소인 스레드 로컬,\nAOP 등 다양한 기술 덕분에 우리는 `@Transactional` 애노테이션을 통해 복잡한 트랜잭션을 편리하게 활용할 수 있었다.\n\n편리한 만큼 내부 구조를 이해하는 것은 매우 까다로운 과정이다. 추후 AOP에 대한 개념, 적용 방법, 이것을 편리하게 적용하기 위한 스프링의 노력들을 추가적으로 학습한 뒤 트랜잭션이 적용된 클래스 및 메서드를\n감지하고 부가기능을 도입하는 과정을 알아보려 한다.\n\n## References.\n\n[Interface PlatformTransactionManager](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/PlatformTransactionManager.html)<br>\n이일민 지음, 『토비의 스프링 3.1 Vol. 1 스프링의 이해와 원리』, 에이콘(2012), p349-399.<br>\n[스프링 DB 1편 - 데이터 접근 핵심 원리](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-db-1/dashboard)<br>\n[[Spring] 트랜잭션에 대한 이해와 Spring이 제공하는 Transaction(트랜잭션) 핵심 기술 - (1/3)](https://mangkyu.tistory.com/154)\n"},{"excerpt":"작성에 사용된 예제 코드는 spring-transaction에서 확인해볼 수 있다. 트랜잭션은 논리적인 작업 셋을 모두 완벽하게 처리하거나, 처리하지 못할 경우 원래 상태로 복구하여 작업의 일부만 적용되는 현상(Partial update)을 막아준다. 또한 트랜잭션은 하나의 논리적인 작업 셋의 쿼리 개수와 관계없이 논리적인 작업 셋 자체가 전부 적용(CO…","fields":{"slug":"/spring-transaction-1/"},"frontmatter":{"date":"December 09, 2022","title":"스프링이 개선한 트랜잭션 (1)","tags":["스프링","트랜잭션"]},"rawMarkdownBody":"\n> 작성에 사용된 예제 코드는 [spring-transaction](https://github.com/hyeonic/blog-code/tree/main/spring-transaction)에서 확인해볼 수 있다.\n\n트랜잭션은 논리적인 작업 셋을 모두 완벽하게 처리하거나, 처리하지 못할 경우 원래 상태로 복구하여 작업의 일부만 적용되는 현상(Partial update)을 막아준다.\n\n또한 트랜잭션은 하나의 논리적인 작업 셋의 쿼리 개수와 관계없이 논리적인 작업 셋 자체가 전부 적용(COMMIT)되거나 아무것도 적용되지 않는 것(ROLLBACK)을 보장해주는 것이다. 결국 트랜잭션은 여러 개의\n변경 작업을 수행하는 쿼리가 조합 됐을 때만 의미 있는 개념은 아니다.\n\n트랜잭션은 시작과 끝이 존재하는 절차(script)이다. 트랜잭션은 이러한 절차의 시작과 끝을 단위화하는 것이다. 단위화된 트랜잭션은 반드시 원자성이 보장되어야 한다.\n\n여러 작업 셋을 하나의 트랜잭션으로 처리하기 위해서는 같은 커넥션 내에서 동작해야 한다. 이것을 구현하는 방법은 아래와 같이 매개변수를 통해 커넥션 객체를 전달하는 것이다.\n\n```java\npublic class JdbcAccountRepository {\n    // ...\n    public Account save(final Connection connection, final Account account) throws SQLException {\n        var sql = \"INSERT INTO account(holder, amount) VALUES (?, ?)\";\n        try (var preparedStatement = connection.prepareStatement(sql)) {\n\n            preparedStatement.setString(1, account.getHolder());\n            preparedStatement.setLong(2, account.getAmount());\n            preparedStatement.executeUpdate();\n\n            return findByHolder(connection, account.getHolder())\n                    .orElseThrow(NoSuchElementException::new);\n        }\n    }\n    // ...\n}\n```\n\n또한 트랜잭션과 관련된 처리가 마무리된 후 커넥션을 닫아야 한다. 위 repository보다 상위 계층에서 커넥션을 생성하고 닫는 생명 주기에 대한 책임까지 가지게 된다. 보통 service 계층은 애플리케이션의\n핵심 비즈니스 로직을 처리하기 위한 계층이다. 하지만 데이터베이스 접근을 위한 커넥션에 대한 책임까지 가지게 되는 문제가 발생한다.\n\n```java\n\n@Service\npublic class AccountService {\n    // ...\n    public void withdraw(final Account account, final Long amount) throws SQLException {\n        var connection = dataSource.getConnection();\n        try {\n            connection.setAutoCommit(false);\n            accountRepository.update(connection,\n                    new Account(account.getId(), account.getHolder(), account.getAmount() - amount));\n            connection.commit();\n        } catch (final SQLException e) {\n            connection.rollback();\n            throw new RuntimeException(e);\n        }\n    }\n    // ...\n}\n```\n\n개발자가 매번 일련의 트랜잭션을 보장하기 위해 커넥션 객체를 생성하고 반납하는 등의 로직을 관리하는 것은 매우 귀찮은 일이다. 또한 service 계층에서 처리해야 할 비즈니스 로직에 JDBC와 관련된 의존성(\nSQLException 등)을 가지게 되기 때문에 변경에 유연하지 못한 구조를 가져온다. 스프링에서는 이러한 불편함을 해결하기 위해 `트랜잭션 추상화`와 `트랜잭션 동기화` 기능을 제공한다.\n\n## 트랜잭션 추상화\n\n현재 service 계층은 dataSource를 통해 커넥션 객체를 획득하고 있다. 또한 커넥션 객체의 `setAutoCommit()` 메서드를 통해 트랜잭션을 시작하고 있다. 만약 다른 데이터 접근 기술로\n변경된다면 어떻게 될까? 실제로 순수한 JPA를 사용할 경우 아래와 같은 과정을 거쳐 트랜잭션을 시작할 수 있다.\n\n```java\nEntityTransaction entityTransaction = entityManager.getTranaction();\nentityTransaction.begin();\n```\n\n데이터 접근 기술의 변경은 비즈니스 로직인 service 계층의 수정까지 야기하게 된다. 스프링은 이것을 트랜잭션의 행위들을 명시한 인터페이스를 통해 극복했다.\n\n```java\npublic interface PlatformTransactionManager extends TransactionManager {\n\n    TransactionStatus getTransaction(@Nullable TransactionDefinition definition) throws TransactionException;\n\n    void commit(TransactionStatus status) throws TransactionException;\n\n    void rollback(TransactionStatus status) throws TransactionException;\n}\n```\n\n`PlatformTransactionManager`은 스프링의 명령형 트랜잭션 인프라의 중앙 인터페이스이다.\n\n* `getTransaction(TransactionDefinition definition)`: 지정된 전파 동작에 따라 현재 활성 트랜잭션을 반환하거나 새 트랜잭션을 만든다.\n* `commit(TransactionStatus status)`: 상태와 관련하여 주어진 트랜잭션을 커밋한다.\n* `rollback(TransactionStatus status)`: 주어진 트랜잭션의 롤백을 수행한다.\n\n이러한 트랜잭션 매니저 덕분에 특정 데이터 접근 기술에 의존하지 않고 추상화된 인터페이스를 의존하여 변경에 유연하게 대처할 수 있게 된다. 아래는 추상화된 트랜잭션 매니저 인터페이스를 활용하여 개선한 service\n계층이다.\n\n```java\n\n@Service\npublic class AccountService {\n    // ...\n    public void withdraw(final Account account, final Long amount) {\n        var transactionStatus = platformTransactionManager.getTransaction(new DefaultTransactionDefinition());\n        try {\n            accountRepository.update(new Account(account.getId(), account.getHolder(), account.getAmount() - amount));\n            platformTransactionManager.commit(transactionStatus);\n        } catch (final Exception e) {\n            platformTransactionManager.rollback(transactionStatus);\n            throw new RuntimeException(e);\n        }\n    }\n}\n```\n\n이전에 JDBC에 강하게 의존하던 코드들은 사라지고 추상화된 인터페이스에만 의존하고 있다. 이제 스프링의 의존성 주입을 활용하여 데이터 접근 기술에 맞는 트랜잭션 매니저를 적절히 선택하여 활용할 수 있게 되었다.\n\n* `getTransaction(new DefaultTransactionDefinition())`: 트랜잭션을 시작한다. `TransactionStatus`를 반환한다. 현재 트랜잭션에 대한 정보를 포함한다. 이러한\n  정보를 바탕으로 이후 트랜잭션 커밋 혹은 롤백을 진행할 수 있다.\n* `new DefaultTransactionDefinition()`: 트랜잭션과 관련된 옵션을 지정한다. 전부 기본 설정을 활용한다.\n* `commit(transactionStatus)`: 트랜잭션을 커밋한다.\n* `rollback(transactionStatus)`: 트랜잭션을 롤백한다.\n\n트랜잭션 매니저 사용 이전에는 메서드 수행 시 매개변수로 커넥션 객체를 전달해서 같은 커넥션을 유지할 수 있도록 만들었다. 그렇다면 트랜잭션 매니저는 어떻게 같은 커넥션 내에서 동작하도록 보장하는 걸까?\n\n## 트랜잭션 동기화\n\n트랜잭션 동기화는 트랜잭션을 시작하기 위한 커넥션 객체를 특별한 저장소에 보관해 두고 필요할 때 꺼내 쓸 수 있도록 하는 기술이다. 트랜잭션 동기화 저장소는 스레드마다 커넥션 객체를 `독립적`으로 관리하므로 멀티 스레드 환경에서 충돌이 발생하지 않는다. `트랜잭션 매니저`는 `트랜잭션 동기화 매니저`를 통해 이것을 구현했다.\n\n아래는 트랜잭션 매니저가 관리하는 커넥션을 획득하고 반납하는 로직이 반영된 repository이다. dataSource에서 획득하던 이전과 다르게 `DataSourceUtils`를 통해 커넥션을 획득하고 반납한다.\n\n```java\n\n@Repository\npublic class JdbcAccountRepository {\n    // ...\n    public Account save(final Account account) {\n        var connection = DataSourceUtils.getConnection(dataSource);\n        var sql = \"INSERT INTO account(holder, amount) VALUES (?, ?)\";\n        try (var preparedStatement = connection.prepareStatement(sql)) {\n            preparedStatement.setString(1, account.getHolder());\n            preparedStatement.setLong(2, account.getAmount());\n            preparedStatement.executeUpdate();\n\n            return findByHolder(account.getHolder())\n                    .orElseThrow(NoSuchElementException::new);\n        } catch (final SQLException e) {\n            throw new RuntimeException(e);\n        } finally {\n            DataSourceUtils.releaseConnection(connection, dataSource);\n        }\n    }\n    // ...\n}\n```\n\n* `DataSourceUtils.getConnection(dataSource)`: `TransactionSynchronizationManager`가 관리하는 커넥션이 있다면 획득하고 없다면 새롭게 생성하여\n  반환한다.\n* `DataSourceUtils.releaseConnection(connection, dataSource)`: 커넥션을 `close()`를 통해 닫으면 유지할 수 없다. 커넥션은 이후 로직에도 계속 살아 있어야\n  한다. 해당 메서드는 커넥션을 바로 닫는 것이 아니라 트랜잭션 매니저가 관리하지 않을 때 해당 커넥션을 닫는다.\n\n### DataSourceUtils.getConnection(dataSource)\n\n먼저 커넥션을 획득하는 로직을 차근차근 살펴보자.\n\n```java\npublic abstract class DataSourceUtils {\n    // ...\n    public static Connection getConnection(DataSource dataSource) throws CannotGetJdbcConnectionException {\n        try {\n            return doGetConnection(dataSource);\n        } catch (SQLException ex) {\n            throw new CannotGetJdbcConnectionException(\"Failed to obtain JDBC Connection\", ex);\n        } catch (IllegalStateException ex) {\n            throw new CannotGetJdbcConnectionException(\"Failed to obtain JDBC Connection\", ex);\n        }\n    }\n    // ...\n}\n```\n\n주어진 DataSource에서 Connection을 획득한다. `SQLException`을 `UncheckedException`으로 변환하여 호출부를 단순화하고 발생하는 예외를 의미 있게 만든다.\n\n```java\npublic abstract class DataSourceUtils {\n    // ...\n    public static Connection doGetConnection(DataSource dataSource) throws SQLException {\n        Assert.notNull(dataSource, \"No DataSource specified\");\n\n        ConnectionHolder conHolder = (ConnectionHolder) TransactionSynchronizationManager.getResource(dataSource);\n        if (conHolder != null && (conHolder.hasConnection() || conHolder.isSynchronizedWithTransaction())) {\n            conHolder.requested();\n            if (!conHolder.hasConnection()) {\n                logger.debug(\"Fetching resumed JDBC Connection from DataSource\");\n                conHolder.setConnection(fetchConnection(dataSource));\n            }\n            return conHolder.getConnection();\n        }\n        // Else we either got no holder or an empty thread-bound holder here.\n\n        logger.debug(\"Fetching JDBC Connection from DataSource\");\n        Connection con = fetchConnection(dataSource);\n\n        if (TransactionSynchronizationManager.isSynchronizationActive()) {\n            try {\n                // Use same Connection for further JDBC actions within the transaction.\n                // Thread-bound object will get removed by synchronization at transaction completion.\n                ConnectionHolder holderToUse = conHolder;\n                if (holderToUse == null) {\n                    holderToUse = new ConnectionHolder(con);\n                } else {\n                    holderToUse.setConnection(con);\n                }\n                holderToUse.requested();\n                TransactionSynchronizationManager.registerSynchronization(\n                        new ConnectionSynchronization(holderToUse, dataSource));\n                holderToUse.setSynchronizedWithTransaction(true);\n                if (holderToUse != conHolder) {\n                    TransactionSynchronizationManager.bindResource(dataSource, holderToUse);\n                }\n            } catch (RuntimeException ex) {\n                // Unexpected exception from external delegation call -> close Connection and rethrow.\n                releaseConnection(con, dataSource);\n                throw ex;\n            }\n        }\n\n        return con;\n    }\n    // ...\n}\n```\n\n실제로 주어진 DataSource에서 Connection을 획득한다. `doGetConnection()` 메서드는 Connection 객체를 생성해줄 뿐만 아니라 트랜잭션 동기화에 사용할수 있도록 특별한 저장소에 바인딩해준다. 트랜잭션이 동기화된 채로 사용하면 이후 커넥션을 획득할 때 동기화 시킨 데이터베이스 커넥션을 사용하게 된다.\n\n`트랜잭션 추상화`를 적절히 활용하면 JDBC API와 강하게 의존하던 부분도 제거할 수 있다. 또한 `트랜잭션 동기화`를 통해 매번 전달하던 Connection 객체에 대한 의존성도 제거할 수 있게 된다.\n\n```java\n\n@Service\npublic class AccountService {\n    // ...\n    public void withdraw(final Account account, final Long amount) {\n        var transactionStatus = platformTransactionManager.getTransaction(new DefaultTransactionDefinition());\n        try {\n            accountRepository.update(new Account(account.getId(), account.getHolder(), account.getAmount() - amount));\n            platformTransactionManager.commit(transactionStatus);\n        } catch (final Exception e) {\n            platformTransactionManager.rollback(transactionStatus);\n            throw new RuntimeException(e);\n        }\n    }\n}\n```\n\n하지만 아직 몇 가지 문제가 남아 있다. service 계층은 언급한 것 처럼 애플리케이션의 비즈니스 로직이 위치하는 곳이다. 위 코드를 보면 아직도 트랜잭션에 대한 의존성이 남아 있게 된다. 이것을 어떻게 개선할 수 있을까? \n\n다음 시간에는 템플릿 콜백 패턴을 활용한 `TransactionTemplate`과 스프링 AOP를 활용한 선언적 트랜잭션인 `@Transactional`을 활용한 트랜잭션 로직 분리에 대해 알아보려 한다.\n\n## References.\n\n[Interface PlatformTransactionManager](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/PlatformTransactionManager.html)<br>\n이일민 지음, 『토비의 스프링 3.1 Vol. 1 스프링의 이해와 원리』, 에이콘(2012), p349-399.<br>\n[스프링 DB 1편 - 데이터 접근 핵심 원리](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-db-1/dashboard)<br>\n[[Spring] 트랜잭션에 대한 이해와 Spring이 제공하는 Transaction(트랜잭션) 핵심 기술 - (1/3)](https://mangkyu.tistory.com/154)\n"},{"excerpt":"동시성 이슈를 해결하기 위해서는 다양한 방법이 존재한다. 예를 들면 Java의 , 비관적 락과 낙관적 락, 분산 락 등이 존재한다. 이번에는 충돌이 발생하지 않는다고 낙관적으로 가정한 뒤 락을 처리하는 낙관적 락에 대해 알아보려 한다. 작성에 사용된 예제 코드는 optimistic-locking에서 확인해볼 수 있다. 낙관적 락 트랜잭션 충돌이 발생하지 …","fields":{"slug":"/optimistic-locking/"},"frontmatter":{"date":"December 03, 2022","title":"낙관적 락과 동시성 테스트","tags":["optimisitc-locking","낙관적 락"]},"rawMarkdownBody":"\n동시성 이슈를 해결하기 위해서는 다양한 방법이 존재한다. 예를 들면 Java의 `synchronized`, 비관적 락과 낙관적 락, 분산 락 등이 존재한다. 이번에는 충돌이 발생하지 않는다고 낙관적으로 가정한 뒤 락을 처리하는 낙관적 락에 대해 알아보려 한다.\n\n> 작성에 사용된 예제 코드는 [optimistic-locking](https://github.com/hyeonic/blog-code/tree/main/optimistic-locking)에서 확인해볼 수 있다.\n\n## 낙관적 락\n\n트랜잭션 충돌이 발생하지 않는다고 낙관적으로 가정한다. 추가적인 `version`을 기반으로 충돌할 경우 롤백을 진행한다.  가장 큰 장점은 충돌이 일어나지 않는다고 가정하기 때문에 동시 처리에 대한 이점이 많다.\n\n## @Version\n\n낙관적 락을 사용하는 방법은 여러가지가 있지만 대표적으로는 `@Version` 애노테이션을 사용하는 방법이다. `@Version`은 낙관적 락 값으로 사용되는 엔터티 클래스의 버전 필드 또는 속성을 지정한다. 이 버전은 병합 작업을 수행할 때 무결성을 보장하고 낙관적 동시성 제어를 위해 사용 된다. `@Version`은 클래스당 하나의 속성 또는 필드만 사용해야 한다. 둘 이상의 버전 또는 속성 필드를 사용할 수 없다.\n\n![](./version.png)\n\n`@Version`은 엔티티 클래스의 기본 테이블에 매핑되어야 한다. 기본 테이블이 아닌 다른 테이블에 매핑할 수 없다. `@Version`이 지원되는 type은 `int`, `Integer`, `short`, `Short`, `long`, `Long`, `java.sql.Timestamp`이다. `@Version`이 사용된 엔티티는 수정될 때 자동으로 버전이 증가하며 수정할 때 조회 시점과 버전이 다른 경우 예외가 발생한다.\n\n![](./version-transaction.png)\n\n이러한 버전은 엔티티 수정 시점에 최신화되며 JPA에 의해 자동적으로 관리된다.\n\n```sql\nupdate\n    member\nset name=?,\n    version=?\nwhere id = ?\n  and version = ?\n```\n\n만약 WHERE 조건에 의해 수정할 대상이 없는 경우 버전이 증가 했다고 판단하여 예외를 던진다.\n\nSpring Data JPA를 사용할 경우 JPA에 대한 구현체는 기본적으로 hibernate를 사용하게 된다. 이 예외는 기본적으로 hibernate에서 던지는 `StaleStateException` 예외를 Spring이 `HibernateJpaDialect`의 `convertHibernateAccessException()` 메서드를\n통해 `org.springframework.dao` 계층에서 적절한 예외(DataAccessException 타입)로 변환된다.\n\n```java\npackage org.springframework.orm.jpa.vendor;\n\n// ...\npublic class HibernateJpaDialect extends DefaultJpaDialect {\n    // ...\n    protected DataAccessException convertHibernateAccessException(HibernateException ex) {\n        // ...\n        if (ex instanceof StaleStateException) {\n            return new ObjectOptimisticLockingFailureException(ex.getMessage(), ex);\n        }\n        // ...\n    }\n}\n```\n\n### 적용\n\n먼저 Version 칼럼을 사용하기 위한 `Member` 엔티티이다.\n\n```java\n@Entity\npublic class Member {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    @Column\n    private String name;\n\n    @Version\n    private Long version;\n\n    protected Member() {\n    }\n\n    public Member(final String name) {\n        this.name = name;\n    }\n\n    public void changeName(final String name) {\n        this.name = name;\n    }\n\n    // getter..\n}\n```\n\n고유한 `id`와 이름을 나타내는 `name`을 가지고 있다. `@Version`을 통해 엔티티의 버전을 명시하기 위한 칼럼을 추가한다. 위 엔티티를 기반으로 자동으로 생성되는 테이블 DDL을 살펴보면 아래와 같다.\n\n```sql\ncreate table member\n(\n    id      bigint not null auto_increment,\n    name    varchar(255),\n    version bigint,\n    primary key (id)\n)\n```\n\n`version`이라는 칼럼이 추가적으로 생성되어 테이블이 생성된다. 이러한 Version 정보를 사용하면 최초에 적용된 커밋만 반영되고 나머지는 무시된다.\n\n## 주의\n\n`@Version`으로 추가한 필드는 JPA가 직접 관리한다. 그렇기 때문에 개발자가 임의로 수정하지 않도록 주의해야 한다. 단 `벌크 연산`의 경우에는 버전 증가를 위해 강제로 증가시켜야 한다.\n\n> 벌크 연산이란?\n> \n> 여러 건의 데이터를 한 번에 수정(update)하거나 삭제(delete)하는 것을 말한다. (hibernate는 insert도 지원한다.)\n> \n\n## 테스트로 검증하기\n\n낙관적 락이 잘 작동하는지 확인하기 위해서는 동시성 관련 테스트를 진행해야 한다. 이때 대표적으로 사용할 수 있는 방법 중 하나는 `CountDownLatch`를 사용하는 것이다.\n\n### CountDownLatch\n\n다른 스레드에서 수행 중인 일련의 작업이 완료될 때 까지 하나 이상의 스레드가 대기할 수 있도록 하는 동기화 지원이다.\n\n`CountDownLatch`는 지정된 `count`로 초기화된다. `countDown()` 메서드의 호출로 인해 현재 카운트가 0에 도달할 때 까지 `await()` 메서드는 차단되며, \n그 후 대기 중인 모든 스레드가 해제되고 후속 `await()` 호출이 즉시 반환된다. 이것은 일회성 현상으로 카운트를 재설정할 수 없다. 카운트 재설정하는 버전이 필요할 경우 `CyclicBarrier` 사용을 고려한다.\n\n자세한 사용 방법은 별도의 게시글로 작성할 예정이다.\n\n이제 `CountDownLatch`를 활용하여 간단한 동시성 테스트를 진행해보자.\n\n먼저 테스트 진행을 위한 `Member` 엔티티이다.\n\n```java\n@Entity\npublic class Member {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    @Column\n    private String name;\n\n    @Version\n    private Long version;\n\n    protected Member() {\n    }\n\n    public Member(final String name) {\n        this.name = name;\n    }\n\n    public void changeName(final String name) {\n        this.name = name;\n    }\n\n    // getter..\n}\n```\n\nMember 엔티티 관리를 위한 `MemberRepository`이다.\n\n```java\npublic interface MemberRepository extends JpaRepository<Member, Long> {\n}\n```\n\nMember의 비즈니스 로직을 담당하는 `MemberService`이다. 동시성 테스트를 진행할 메서드의 대상이다.\n\n```java\n@Service\n@Transactional(readOnly = true)\npublic class MemberService {\n\n    private final MemberRepository memberRepository;\n\n    public MemberService(final MemberRepository memberRepository) {\n        this.memberRepository = memberRepository;\n    }\n\n    @Transactional\n    public Member save(final Member member) {\n        return memberRepository.save(member);\n    }\n\n    public Member findById(final Long id) {\n        return getMember(id);\n    }\n\n    @Transactional\n    public void changeName(final Long id, final String name) {\n        Member foundMember = getMember(id);\n        foundMember.changeName(name);\n    }\n\n    private Member getMember(final Long id) {\n        return memberRepository.findById(id)\n                .orElseThrow(NoSuchElementException::new);\n    }\n}\n```\n\n자 이제 동시성 테스트를 진행해보자.\n\n```java\n@SpringBootTest\nclass MemberServiceTest {\n    \n    private final MemberService memberService;\n\n    @Autowired\n    MemberServiceTest(final MemberService memberService) {\n        this.memberService = memberService;\n    }\n    \n    @Test\n    void member를_동시에_수정한다() throws InterruptedException {\n        Member member = memberService.save(new Member(\"version 0\"));\n\n        ExecutorService executorService = Executors.newFixedThreadPool(2);\n        CountDownLatch countDownLatch = new CountDownLatch(2);\n\n        AtomicInteger count = new AtomicInteger(0);\n        for (int i = 0; i < 2; i++) {\n            executorService.execute(() -> {\n                try {\n                    memberService.changeName(member.getId(), \"version change\");\n                } catch (final ObjectOptimisticLockingFailureException e) {\n                    count.incrementAndGet();\n                } finally {\n                    countDownLatch.countDown();\n                }\n            });\n        }\n\n        countDownLatch.await();\n\n        Member actual = memberService.findById(member.getId());\n\n        assertAll(() -> {\n            assertThat(count.get()).isEqualTo(1);\n            assertThat(actual.getName()).isEqualTo(\"version change\");\n        });\n    }\n}\n```\n\n * `ExecutorService executorService = Executors.newFixedThreadPool(2)`: 제한된 개수의 스레드 풀을 관리한다. \n * `CountDownLatch countDownLatch = new CountDownLatch(2)`: 스레드 대기를 위한 CountDownLatch이다.\n * `AtomicInteger count = new AtomicInteger(0)`: 여러 스레드에서 동시에 엑세스할 수 있는 환경에서 동시성을 보장하기 위한 Wrapper 클래스이다. 낙관적 락에서 던진 예외를 catch하고 count하기 위해 사용한다.\n * `countDownLatch.countDown()`: countDownLatch에서 명시한 count를 차감한다. `finally`에 정한 이유는 `countDown()`가 무조건 실행되어야 하기 때문이다. 만약 차감하지 않을 경우 무한정 기다리게 된다.\n * `countDownLatch.await()`: countDownLatch에서 명시한 count가 0이 되길 기다린다. 0이면 이후 스레드가 실행한다.\n\n왜 `countDownLatch.await()`를 활용하여 모든 동시 요청을 기다려야 할까? 이유는 동시 요청 이후 메인 스레드는 지속해서 작업을 진행하기 때문이다. 테스트를 진행하는 메인 스레드는 동시 요청과 동시에 나머지 작업을 진행한다. `await()`를 통해 기다리지 않으면 동시 요청에 대한 응답도 받기 이전에 테스트 메인 스레드가 마무리 될 것이다.\n\n## 정리\n\n지금까지 낙관적 락을 활용한 동시성 제어에 대해 알아보았다. JPA에서 제공하는 편리한 애노테이션 덕분에 아주 간단하게 적용할 수 있다. 낙관적 락은 동시에 접근하는 상황에서 최초에 커밋된 것만 반영된다. 만약 동시 요청이 와도 모든 작업이 반영되야 하는 상황에서는 예외 상황에서 추가적인 핸들링이 필요해진다. 낙관적 락은 단순히 충돌을 감지할 뿐이다.\n\n이러한 낙관적 락은 단일 데이터베아스 환경에서는 직접적인 락을 걸지 않기 때문에 성능적인 측면에서 이점이 많다. 또한 다중 애플리케이션 환경에서도 단순히 데이터베이스의 버전 칼럼을 활용하여 동시성을 제어하기 때문에 스케일 아웃한 환경에서도 적용이 가능할 것으로 추측한다.\n\n## References.\n\n[Annotation Type Version](https://docs.oracle.com/javaee/7/api/javax/persistence/Version.html)<br>\n[Class CountDownLatch](https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CountDownLatch.html)<br>\n김영한 지음, 『자바 ORM 표준 JPA 프로그래밍』, 에이콘(2015), p697-700.\n"},{"excerpt":"SimpleJpaRepository의 save()는 어떻게 새로운 엔티티를 판단할까? 를 사용하면 JPA 기반의 repository를 쉽게 구현할 수 있다. 대표적으로 를 통해 보다 더 정교한 기능들을 제공한다. 이를 통해 개발자는 데이터 접근 계층을 손쉽게 구현할 수 있다.  SimpleJpaRepository 는  인터페이스의 기본 구현이다. 이것은 …","fields":{"slug":"/save-persist-merge/"},"frontmatter":{"date":"November 21, 2022","title":"SimpleJpaRepository의 save()는 어떻게 새로운 엔티티를 판단할까?","tags":["우아한테크코스","JPA","save","persist","merge"]},"rawMarkdownBody":"\n## SimpleJpaRepository의 save()는 어떻게 새로운 엔티티를 판단할까?\n\n`Spring Data JPA`를 사용하면 JPA 기반의 repository를 쉽게 구현할 수 있다.\n\n대표적으로 `SimpeJpaRepository`를 통해 `EntityManager`보다 더 정교한 기능들을 제공한다. 이를 통해 개발자는 데이터 접근 계층을 손쉽게 구현할 수 있다. \n\n## SimpleJpaRepository\n\n`SimpleJpaRepository`는 `org.springframework.data.repository.CrudRepository` 인터페이스의 기본 구현이다. 이것은 일반 `EntityManager` 보다 더 정교한 인터페이스를 제공한다. 먼저 엔티티를 영속 시키기 위한 `save()` 메서드를 중점적으로 살펴보려한다. 예시를 살펴보기 위해 먼저 Member 엔티티를 선언한다.\n\n```java\n@Entity\npublic class Member {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    private String name;\n\n    protected Member() {\n    }\n\n    public Member(final Long id, final String name) {\n        this.id = id;\n        this.name = name;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public String getName() {\n        return name;\n    }\n}\n```\n\n간단한 테스트를 통해 동작 방식을 확인해보자.\n\n```java\n@DataJpaTest\n@DisplayNameGeneration(DisplayNameGenerator.ReplaceUnderscores.class)\nclass MemberRepositoryTest {\n\n    private final MemberRepository memberRepository;\n\n    @Autowired\n    MemberRepositoryTest(final MemberRepository memberRepository) {\n        this.memberRepository = memberRepository;\n    }\n\n    @Test\n    void 식별자가_없는_member를_저장한다() {\n        Member member = new Member(null, \"매트\");\n\n        Member actual = memberRepository.save(member);\n\n        assertAll(() -> {\n            assertThat(actual.getId()).isNotNull();\n            assertThat(actual.getName()).isEqualTo(\"매트\");\n        });\n    }\n}\n```\n\n`new Member(null, \"매트\")`를 저장하는 테스트이다. `save()`를 따라가보자.\n\n```java\n@Repository\n@Transactional(readOnly = true)\npublic class SimpleJpaRepository<T, ID> implements JpaRepositoryImplementation<T, ID> { \n    // ...\n    @Transactional \n    @Override \n    public <S extends T> S save(S entity) {\n        \n        Assert.notNull(entity, \"Entity must not be null.\");\n        \n        if (entityInformation.isNew(entity)) {\n            em.persist(entity);\n            return entity;\n        } else {\n            return em.merge(entity);\n        }\n    }\n    // ...\n}\n```\n\n로직을 살펴보면 `entityInformation.isNew(entity)`를 통해 해당 `entity`가 `new`인지 확인한다.\n * `entityInformation.isNew(entity)`가 `true`이면 `em.persist(entity)`한다.\n * `entityInformation.isNew(entity)`가 `false`이면 `em.merge(entity)`한다.\n\n그렇다면 `isNew()`는 어떻게 새로운 `entity`인지 확인할까? 구현 코드를 살펴보자.\n\n```java\npublic class JpaMetamodelEntityInformation<T, ID> extends JpaEntityInformationSupport<T, ID> {\n    // ...\n    @Override\n    public boolean isNew(T entity) {\n\n        if (!versionAttribute.isPresent()\n                || versionAttribute.map(Attribute::getJavaType).map(Class::isPrimitive).orElse(false)) {\n            return super.isNew(entity);\n        }\n\n        BeanWrapper wrapper = new DirectFieldAccessFallbackBeanWrapper(entity);\n\n        return versionAttribute.map(it -> wrapper.getPropertyValue(it.getName()) == null).orElse(true);\n    }\n    // ...\n}\n```\n\n`JpaMetamodelEntityInformation`는 JPA Metamodel을 사용하여 도메인 클래스의 id 필드를 찾는 `org.springframework.data.repository.core.EntityInformation` 구현체이다. 해당 클래스의 `isNew()`를 살펴보면 `super.isNew(entity)`을 호출하고 있다.\n\n```java\npublic abstract class AbstractEntityInformation<T, ID> implements EntityInformation<T, ID> {\n    // ...\n    public boolean isNew(T entity) {\n\n        ID id = getId(entity);\n        Class<ID> idType = getIdType();\n\n        if (!idType.isPrimitive()) {\n            return id == null;\n        }\n\n        if (id instanceof Number) {\n            return ((Number) id).longValue() == 0L;\n        }\n\n        throw new IllegalArgumentException(String.format(\"Unsupported primitive id type %s\", idType));\n    }\n    // ...\n}\n```\n\n`AbstractEntityInformation`는 `EntityInformation`의 구현을 위한 기본 클래스이다. `getId(Object)`가 null을 반환하거나 식별자가 `Java primitive`이고 `getId(Object)`가 0을 반환할 때마다 새로운 엔티티로 간주한다.\n\n먼저 `getId()`를 통해 제네릭으로 명시한 `ID`를 반환한다.\n\n```java\npublic class JpaMetamodelEntityInformation<T, ID> extends JpaEntityInformationSupport<T, ID> {\n    // ...\n    @Override\n    @Nullable\n    @SuppressWarnings(\"unchecked\")\n    public ID getId(T entity) {\n\n        // check if this is a proxy. If so use Proxy mechanics to access the id.\n        PersistenceProvider persistenceProvider = PersistenceProvider.fromMetamodel(metamodel);\n\n        if (persistenceProvider.shouldUseAccessorFor(entity)) {\n            return (ID) persistenceProvider.getIdentifierFrom(entity);\n        }\n\n        // if not a proxy use Spring mechanics to access the id.\n        BeanWrapper entityWrapper = new DirectFieldAccessFallbackBeanWrapper(entity);\n\n        if (idMetadata.hasSimpleId()) {\n            // 실제 반환하는 부분\n            return (ID) entityWrapper.getPropertyValue(idMetadata.getSimpleIdAttribute().getName());\n        }\n\n        BeanWrapper idWrapper = new IdentifierDerivingDirectFieldAccessFallbackBeanWrapper(idMetadata.getType(), metamodel);\n        boolean partialIdValueFound = false;\n\n        for (SingularAttribute<? super T, ?> attribute : idMetadata) {\n            Object propertyValue = entityWrapper.getPropertyValue(attribute.getName());\n\n            if (propertyValue != null) {\n                partialIdValueFound = true;\n            }\n\n            idWrapper.setPropertyValue(attribute.getName(), propertyValue);\n        }\n\n        return partialIdValueFound ? (ID) idWrapper.getWrappedInstance() : null;\n    }\n    // ...\n}\n```\n\n실제 디버깅을 진행해보면 `idMetadata.hasSimpleId()`를 통해 simpleId 유무를 확인하고 `(ID)`를 통해 명시한 타입으로 변환하고 있다. `Java primitive type`인 경우 제네릭으로 표현할 수 없기 때문에 그에 해당하는 `Wrapper Class`으로 변환하는 것으로 추측한다.\n\n정리하면 `save()` 시점에 `isNew()` 내부에 `getId(Object)`가 null을 반환하거나 식별자가 `Java primitive`이고 `getId(Object)`가 0을 반환할 때마다 새로운 엔티티로 간주한다. 새로운 엔티티로 간주된 것은 `em.persist(entity)`를 통해 처리된다.\n\n이 밖에도 새로운 엔티티를 식별하는 방법은 여러가지가 있다. `@Version`를 활용한 방법, 엔티티 클래스에 `Persistable<ID>` 인터페이스를 구현하는 것 등이 있다. 자세한 구현 방법은 따로 다루지 않겠다. \n\n### [번외] 엔티티 id, primitive type vs Wrapper Class\n\n`Wrapper Class`는 객체이므로 `null` 대입이 가능하다. 반면 primitive type은 null을 대입할 수 없다. \n실제 hibernate 공식 문서를 살펴보면 `Wrapper Class`를 추천하고 있다.\n\n> We recommend that you declare consistently-named identifier attributes on persistent classes and that you use a nullable (i.e., non-primitive) type.\n> \n> 영속 클래스에는 일관되게 명명된 식별자 속성을 선언하고 null 가능한(즉, 원시가 아닌) 유형을 사용하는 것이 좋다.\n\n## persist() vs merge()\n\n지금 까지 `isNew()`를 통해 내부적으로 어떻게 새로운 엔티티로 간주하는지 알아보았다. 새로운 엔티티로 간주된 것과 아닌 것의 `save()` 로직에 대해 살펴보자. `persist()`는 Member 데이터를 기반으로 `insert`를 호출한다.\n\n```java\n@DataJpaTest\n@DisplayNameGeneration(DisplayNameGenerator.ReplaceUnderscores.class)\nclass MemberRepositoryTest {\n    // ...\n    @Test\n    @Rollback(value = false)\n    void 식별자가_없는_member를_저장한다() {\n        Member member = new Member(null, \"매트\");\n\n        Member actual = memberRepository.save(member);\n\n        assertAll(() -> {\n            assertThat(actual.getId()).isNotNull();\n            assertThat(actual.getName()).isEqualTo(\"매트\");\n        });\n    }\n    // ...\n}\n```\n\n * `Rollback(value = false)`: 롤백하지 않고 insert하여 실행되는 쿼리를 확인한다.\n\n```\nHibernate: insert into member (name, id) values (?, ?)\n```\n\n다음은 임의의 식별자를 명시한 뒤 `save()`한다.\n\n```java\n@DataJpaTest\n@DisplayNameGeneration(DisplayNameGenerator.ReplaceUnderscores.class)\nclass MemberRepositoryTest {\n    // ...\n    @Test\n    @Rollback(value = false)\n    void 식별자를_1로_지정한_member를_저장한다() {\n        Member member = new Member(1L, \"매트\");\n\n        Member actual = memberRepository.save(member);\n\n        assertAll(() -> {\n            assertThat(actual.getId()).isNotNull();\n            assertThat(actual.getName()).isEqualTo(\"매트\");\n        });\n    }\n    // ...\n}\n```\n\n위와 같이 준영속 상태에서 저장할 경우 `merge()`가 발생한다. `merge()`는 `select`를 통해 엔티티가 존재하는지 확인한 뒤 없으면 `insert`를 진행한다.\n\n```\nHibernate: select member0_.id as id1_0_0_, member0_.name as name2_0_0_ from member member0_ where member0_.id=?\nHibernate: insert into member (name, id) values (?, ?)\n```\n\n## 정리\n\n지금까지 `SimpleJpaRepository`의 `save()`를 통해 `persist()`와 `merge()`의 차이에 대해 알아보았다. `save()`는 `isNew()` 통해 새로운 엔티티인지를 판별한다. 예를들어 `Long`을 활용할 경우 `null`이거나 `0L`일 때 `true`를 반환하게 된다.\n\n그 밖에도 다양한 방식을 통해 새로운 엔티티로 인식될 수 있다. 핵심은 `merge()`로 인식될 되기 이전에 엔티티는 영속성 컨텍스트에서 관리되지 않는 준영속 상태이기 때문에 `Dirty Checking`과 같은 이점을 활용할 수 없다. 이것을 잘 고려하여 엔티티의 id를 설정해야 한다.\n\n## References.\n\n[Spring Data JPA](https://spring.io/projects/spring-data-jpa) <br>\n김영한 지음, 『자바 ORM 표준 JPA 프로그래밍』, 에이콘(2015), p115.\n"},{"excerpt":"OSIV OSIV는 Open Session In View의 준말로, 영속성 컨텍스트를 뷰까지 열어둔다는 것을 의미이다. 영속성 컨텍스트가 유지된다는 의미는 뷰에서도 과 같이 영속성 컨텍스트의 이점을 누릴 수 있다는 것이다. 요청 당 트랜잭션 OSIV의 핵심은 뷰에서도 이 가능하도록 하는 것이다. 가장 단순한 방법은 요청이 들어오자 마자  혹은 를 거치는 …","fields":{"slug":"/osiv/"},"frontmatter":{"date":"October 24, 2022","title":"OSIV와 사용하며 직면한 문제","tags":["우아한테크코스","OSIV","JPA"]},"rawMarkdownBody":"\n## OSIV\n\nOSIV는 Open Session In View의 준말로, 영속성 컨텍스트를 뷰까지 열어둔다는 것을 의미이다. 영속성 컨텍스트가 유지된다는 의미는 뷰에서도 `Lazy Loading`과 같이 영속성 컨텍스트의 이점을 누릴 수 있다는 것이다.\n\n## 요청 당 트랜잭션\n\nOSIV의 핵심은 뷰에서도 `Lazy Loading`이 가능하도록 하는 것이다. 가장 단순한 방법은 요청이 들어오자 마자 `Filter` 혹은 `Interceptor`를 거치는 시점에 `트랜잭션을 시작`하고 요청이 끝날 때 `트랜잭션을 종료`하는 것이다. 이것을 `요청 당 트랜잭션 방식`의 `OSIV`라 하며 초창기에 사용되던 방식이다. 이것을 그림으로 표현하면 아래와 같다.\n\n![](./1.png)\n\n그림을 살펴보면 요청부터 응답까지 영속성 컨텍스트의 생존 범위가 늘어나게 된다. 이제 뷰에서도 `Lazy Loading`을 진행할 수 있지만 몇 가지 단점을 가지고 있다. \n\n먼저 뷰에서도 엔티티의 수정이 가능해진다. 영속성 컨텍스트의 범위가 늘어나기 때문에 뷰에서 엔티티의 수정이 일어나면 `Dirty Checking` 과정을 통해 응답 시점에, 즉 트랜잭션이 끝나는 시점에 데이터베이스에 반영된다.\n\n뷰에서 데이터를 수정하는 것의 가장 큰 문제는 데이터의 변경 지점을 찾기 어렵게 만든다는 것이다. 비즈니스 로직이 담긴 서비스 계층에서 데이터를 수정한 뒤 영속하는 것은 당연한 것 처럼 받아들일 수 있다. 보통 서비스 계층에서 로직을 시작할 때 `@Transactional` 애노테이션을 통해 선언적 트랜잭션을 명시한 후 비즈니스 로직을 수행한다. 하지만 뷰에서의 엔티티 속성 변경으로 데이터베이스에 영속되는 것은 우리가 뷰에게 원하는 방향은 아니다.\n\n또한 데이터베이스 관련 로직이 필요하지 않은 부분에도 `불필요하게 데이터베이스 커넥션이 활용`될 수 있다. 요청 당 트랜잭션은 요청과 동시에 데이터베이스 커넥션을 커넥션 풀에서 획득한다. 결국 트랜잭션이 끝나는 응답 시점까지 데이터베이스 커넥션을 물고 있는 것이다. 해당 로직 내에서 데이터베이스와 관련된 로직이 처리되지 않는다면 `불필요한 커넥션 자원을 낭비`하고 있는 것과 다름 없다.\n\n## 비즈니스 계층 트랜잭션\n\n요청과 동시에 트랜잭션을 획득하는 요청 당 트랜잭션은 많은 단점을 가지고 있다. 스프링에서는 이러한 단점을 개선하기 위해 비즈니스 계층 트랜잭션을 제공하고 있다.\n\n### OpenSessionInViewFilter\n\n```java\npackage org.springframework.orm.hibernate5.support;\n...\npublic class OpenSessionInViewFilter extends OncePerRequestFilter {\n    ...\n}\n```\n\n하이버네이트 OSIV 서블릿 필터이다. OpenSessionViewFilter는 필터 내에 Session을 오픈 하지만 트랜잭션은 시작하지 않는다. 트랜잭션을 시작하지 않기 때문에 실제 데이터베이스의 커넥션을 획득하지 않는다. Session은 생성되기 때문에 `영속성 컨텍스트만 생성`된다.\n\n### OpenSessionInViewInterceptor\n\n```java\npackage org.springframework.orm.hibernate5.support;\n...\npublic class OpenSessionInViewInterceptor implements AsyncWebRequestInterceptor {\n    ...\n}\n```\n\n하이버네이트 OSIV 스프링 인터셉터이다. Filter와 동일하게 Interceptor에서 Session은 오픈 하지만 트랜잭션은 시작하지 않는다.\n\n### OpenEntityManagerInViewFilter\n\n```java\npackage org.springframework.orm.jpa.support;\n...\npublic class OpenEntityManagerInViewFilter extends OncePerRequestFilter {\n    ...\n}\n```\n\nJPA에서 제공하는 OSIV 서블릿 필터이다.\n\n### OpenEntityManagerInViewInterceptor\n\n```java\npackage org.springframework.orm.jpa.support;\n...\npublic class OpenEntityManagerInViewInterceptor extends EntityManagerFactoryAccessor implements AsyncWebRequestInterceptor {\n    ...\n}\n```\n\nJPA에서 제공하는 OSIV 스프링 인터셉터이다. \n\n이제 위 객체들을 필요에 따라 필터 혹은 인터셉터에 등록하여 사용하면 된다. \n\n스프링 부트는 `application properties` 설정 중 `spring.jpa.open-in-view`을 통해 지정이 가능하다. \n\n```yaml\nspring:\n    jpa:\n        open-in-view: true\n```\n\n아래는 스프링 부트에서 OSIV 관련 설정을 자동으로 해주는 `JpaWebConfiguration`이다. \n\n```java\n@Configuration(proxyBeanMethods = false)\n@EnableConfigurationProperties(JpaProperties.class)\npublic abstract class JpaBaseConfiguration implements BeanFactoryAware {\n  ...\n  @Configuration(proxyBeanMethods = false)\n\t@ConditionalOnWebApplication(type = Type.SERVLET)\n\t@ConditionalOnClass(WebMvcConfigurer.class)\n\t@ConditionalOnMissingBean({ OpenEntityManagerInViewInterceptor.class, OpenEntityManagerInViewFilter.class })\n\t@ConditionalOnMissingFilterBean(OpenEntityManagerInViewFilter.class)\n\t@ConditionalOnProperty(prefix = \"spring.jpa\", name = \"open-in-view\", havingValue = \"true\", matchIfMissing = true)\n\tprotected static class JpaWebConfiguration {\n\n\t\tprivate static final Log logger = LogFactory.getLog(JpaWebConfiguration.class);\n\n\t\tprivate final JpaProperties jpaProperties;\n\n\t\tprotected JpaWebConfiguration(JpaProperties jpaProperties) {\n\t\t\tthis.jpaProperties = jpaProperties;\n\t\t}\n\n\t\t@Bean\n\t\tpublic OpenEntityManagerInViewInterceptor openEntityManagerInViewInterceptor() {\n\t\t\tif (this.jpaProperties.getOpenInView() == null) {\n\t\t\t\tlogger.warn(\"spring.jpa.open-in-view is enabled by default. \"\n\t\t\t\t\t\t+ \"Therefore, database queries may be performed during view \"\n\t\t\t\t\t\t+ \"rendering. Explicitly configure spring.jpa.open-in-view to disable this warning\");\n\t\t\t}\n\t\t\treturn new OpenEntityManagerInViewInterceptor();\n\t\t}\n\n\t\t@Bean\n\t\tpublic WebMvcConfigurer openEntityManagerInViewInterceptorConfigurer(\n\t\t\t\tOpenEntityManagerInViewInterceptor interceptor) {\n\t\t\treturn new WebMvcConfigurer() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void addInterceptors(InterceptorRegistry registry) {\n\t\t\t\t\tregistry.addWebRequestInterceptor(interceptor);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n}\n```\n\n- `ConditionalOnProperty`: Property의 조건에 따라 작동하는 `Bean`이다. application.yml에 있는 값을 기준으로 Bean을 생성한다.\n\n간단히 코드를 살펴보면 `OpenEntityManagerInViewInterceptor`를 빈으로 등록하는 것을 확인할 수 있다. 자세한 동작 과정은 추후 살펴보려한다.\n\n무튼 스프링에서 제공하는 OSIV를 사용하면 트랜잭션의 범위를 비즈니스 계층으로 좁힐 수 있다. 그림으로 표현하면 아래와 같다.\n\n![](./2.png)\n\n요청이 들어오면 OSIV 설정 정보에 따라 필터 혹은 인터셉터에서 `영속성 컨텍스트`를 생성한다. 여기서 중요한 것은 트랜잭션을 시작하지 않는다는 것이다. \n\n그렇다면 트랜잭션은 언제 시작할까? 바로 서비스 계층에서 `@Transactional`을 마주할 때 미리 생성한 영속성 컨텍스트를 기반으로 시작한다.\n\n그 다음 서비스 계층에서 모든 트랜잭션이 마무리되면 트랜잭션을 커밋한다. 단 `영속성 컨텍스트`는 지속된다. 영속성 컨텍스트는 OSIV로 지정한 범위까지 유지된다. 이때 영속성 컨텍스트를 종료하지만 `flush()`는 호출되지 않는다.\n\n정리하면 아래와 같다.\n\n- 영속성 컨텍스트가 트랜잭션 범위 내에 있으면 엔티티를 `조회`하고 `수정`할 수 있다.\n- 영속성 컨텍스트가 트랜잭션 범위 밖에 위치하면 엔티티 `조회`만 가능하다. 즉 `Lazy Loading`이 가능하다는 것을 의미한다.\n\n## OSIV를 사용하며 직면한 문제\n\n`@Transational` 애노테이션을 사용할 때 `영속성 컨텍스트`를 가져와 트랜잭션 처리를 위해 `데이터베이스 커넥션을 획득`한다. \n\nOSIV는 트랜잭션이 끝나도 영속성 컨텍스트를 유지하고 있다. 즉 트랜잭션 범위 외에도 `엔티티 조회`가 가능하다. 이것이 의미하는 바는 데이터베이스 커넥션을 계속 붙들고 있다는 것을 의미한다. 그림으로 표현하면 아래와 같다.\n\n![](./3.png)\n\nOSIV는 뷰에서 영속성 컨텍스트를 유연하게 활용할 수 있어서 다양한 이점을 누릴 수 있다. 다만 `Interceptor`이후 동작하는 `ArgumentResolver`에서 트랜잭션을 활용할 경우 성능 상에 문제가 발생할 수 있다.\n\n아래는 Spring MVC를 간소화한 그림이다.\n\n![](./4.png)\n\n`ArgumentResolver`를 등록하면 핸들러로 들어온 데이터를 추가 가공하는 등의 `전처리 작업`을 진행할 수 있다. 보통 회원의 존재 여부와 같이 인증이 필요한 부분에 공통적으로 활용할 수 있는데, 이때 회원이 존재하는지 확인하기 위해 `데이터베이스`를 필요로 하는 경우 문제가 발생할 수 있다.\n\n가령 아래와 같은 `ArgumentResolver`가 있다고 가정한다.\n\n```java\n@Component\npublic class AuthenticationPrincipalArgumentResolver implements HandlerMethodArgumentResolver {\n\n    private final AuthService authService;\n\n    public AuthenticationPrincipalArgumentResolver(final AuthService authService) {\n        this.authService = authService;\n    }\n\n    @Override\n    public boolean supportsParameter(final MethodParameter parameter) {\n        return parameter.hasParameterAnnotation(AuthenticationPrincipal.class);\n    }\n\n    @Override\n    public Object resolveArgument(final MethodParameter parameter, final ModelAndViewContainer mavContainer,\n                                  final NativeWebRequest webRequest, final WebDataBinderFactory binderFactory) {\n        HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class);\n        String accessToken = AuthorizationExtractor.extract(request);\n        Long id = authService.extractMemberId(accessToken);\n        return new LoginMember(id);\n    }\n}\n```\n\n`@AuthenticationPrincipal` 애노테이션이 붙은 매개변수를 채우기 이전에 `authService.extractMemberId(accessToken)`을  통해 회원의 정보를 추출하고 있다. 해당 메서드 내부에서는 데이터베이스 트랜잭션을 통해 회원 정보를 조회하고 있다.\n\n```java\n@Transactional(readOnly = true)\n@Service\npublic class AuthService {\n    ...\n    public Long extractMemberId(final String accessToken) {\n        Long memberId = tokenCreator.extractPayload(accessToken);\n        memberRepository.validateExistsById(memberId);\n        return memberId;\n    }\n}\n```\n\n`extractMemberId()` 메서드는 `@Transactional(readOnly = true)`을 통해 읽기 전용으로 트랜잭션을 활용하고 있다.\n\n그렇다면 이러한 상황에서 어떠한 문제가 발생할까? OSIV는 `트랜잭션 시작 시점`에 `데이터베이스 커넥션을 획득`한다. 즉 `ArgumentResolver`에서 회원 검증을 위한 조회 로직을 수행하는 시점에 데이터베이스 커넥션을 획득한다는 것이다. 이것을 다시 한 번 그림으로 살펴보자.\n\n![](./5.png)\n\n한 번 획득한 `데이터베이스 커넥션`은 OSIV 설정으로 인해 지정 범위까지 유지된다. 즉 트랜잭션 범위 내에서만 데이터베이스 커넥션이 유지되는 것이 아니라 `요청 중 최초`에 지정된 커넥션을 재사용하기 때문에 오랜시간 동안 커넥션 자원을 사용하는 것이다.\n\n보통 데이터베이스와 연결을 위한 커넥션 자원을 비싼 비용을 가지고 있다. 이것을 절약하기 위해 커넥션 풀에 일정 개수의 커넥션을 생성한 뒤 재사용하는 방식을 활용하곤 한다. 결국 커넥션은 `한정된 자원`이다. 오랜시간 커넥션을 물고 있다는 것은 `병목`이 발생할 가능성이 커진다는 것을 의미한다. 다수의 요청이 발생할 경우 커넥션을 획득하지 못한 요청은 `대기`하게 될 것이다. 모든 케이스에 해당하는 것은 아니지만 실시간 트래픽이 중요한 애플리케이션의 경우 커넥션의 개수가 부족하여 장애로 이어질 수 있다.\n\n## 정리\n\nOSIV는 영속성 컨텍스트의 생존 범위를 늘려주어 엔티티 `Lazy Loading`과 같은 다양한 이점을 누릴 수 있다. 스프링을 사용할 경우 OSIV를 비즈니스 계층 트랜잭션으로 활용하여 보다 더 안정적으로 영속성 컨텍스트를 활용할 수 있다.\n\n하지만 이러한 이점을 누리기 위해서는 오랜시간 데이터베이스 커넥션을 활용해야 한다. 실시간 트래픽이 주가 되는 애플리케이션의 경우 한정된 커넥션 개수가 부족하여 장애로 이어질 수 있음을 염두해 두어야 한다.\n\n## References.\n\n[OpenEntityManagerInViewInterceptor](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/orm/jpa/support/OpenEntityManagerInViewInterceptor.html)<br/>\n김영한 지음, 『자바 ORM 표준 JPA 프로그래밍』, 에이콘(2015), p593-607.\n"},{"excerpt":"커버링 인덱스 MySQL 8.0 이상, InnoDB 스토리지 엔진을 기준으로 작성되었다. 인덱스를 사용하여 처리하는 쿼리 중 가장 큰 부하를 차지하는 부분은 어디일까? 바로 인덱스 검색에서 일치하는 키 값의 이다. 그림을 살펴보면 인덱스 검색에서 일치하는 키 값을 데이터 파일에서 읽을 때 비교적 느린 속도를 가진 디스크 I/O가 발생한다.  N개의 인덱스…","fields":{"slug":"/covering-index/"},"frontmatter":{"date":"October 10, 2022","title":"커버링 인덱스","tags":["우아한테크코스","커버링 인덱스"]},"rawMarkdownBody":"\n## 커버링 인덱스\n\n> MySQL 8.0 이상, InnoDB 스토리지 엔진을 기준으로 작성되었다.\n\n인덱스를 사용하여 처리하는 쿼리 중 가장 큰 부하를 차지하는 부분은 어디일까? 바로 인덱스 검색에서 일치하는 키 값의 `레코드를 읽는 것`이다.\n\n그림을 살펴보면 인덱스 검색에서 일치하는 키 값을 데이터 파일에서 읽을 때 비교적 느린 속도를 가진 디스크 I/O가 발생한다.\n\n![](./image-1.png)\n\nN개의 인덱스 검색 시 최악의 경우 N번의 디스크 I/O가 발생할 수 있다. \n\n이것을 커버링 인덱스를 활용하여 개선할 수 있다. 커버링 인덱스는 데이터 파일을 읽지 않고 인덱스만 읽어 불필요한 디스크 I/O를 줄일 수 있다.\n\n먼저 간단한 예제를 위한 crew 테이블이다. 데이터는 대략 `100만건`을 기준으로 한다.\n\n```sql\nCREATE TABLE crew (\n    id INT NOT NULL AUTO_INCREMENT,\n    nickname VARCHAR(20) NOT NULL,\n    track VARCHAR(20) NOT NULL,\n    year INT NOT NULL,\n    CONSTRAINT pk_crew_id PRIMARY KEY (id)  \n);\n```\n\n- `id`: 고유 식별자\n- `nickname`: 닉네임\n- `track`: 진행 중인 track (e.g. FRONTEND, BACKEND 등)\n- `year`: 기수 (e.g. 1기, 2기 등)\n\n## 인덱스 설정\n\ncrew 테이블에서 닉네임이 `a ~ d` 사이이며 `BACKEND` 트랙을 진행 중인 크루를 조회한다고 가정한다. 쿼리로 표현하면 아래와 같다.\n\n```sql\nSELECT * \nFROM crew \nWHERE nickname BETWEEN 'a' AND 'd' AND track = 'BACKEND';   \n```\n\n위 쿼리에 인덱스를 적용하기 위해 `nickname`과 `track`으로 복합 인덱스를 설정한다.\n\n```sql\nALTER TABLE crew ADD INDEX idx_crew_nickname_track (nickname, track);   \n```\n\n이제 실행 계획을 살펴보자.\n\n```sql\nmysql> EXPLAIN SELECT * FROM crew WHERE nickname BETWEEN 'a' AND 'd' AND track = 'BACKEND';\n+----+-------------+-------+------------+------+-------------------------+------+---------+------+--------+----------+-------------+    \n| id | select_type | table | partitions | type | possible_keys           | key  | key_len | ref  | rows   | filtered | Extra       |    \n+----+-------------+-------+------------+------+-------------------------+------+---------+------+--------+----------+-------------+    \n|  1 | SIMPLE      | crew  | NULL       | ALL  | idx_crew_nickname_track | NULL | NULL    | NULL | 997049 |     3.70 | Using where |    \n+----+-------------+-------+------------+------+-------------------------+------+---------+------+--------+----------+-------------+    \n```\n\n`*`를 활용하여 모든 칼럼을 조회할 경우 옵티마이저는 인덱스를 활용하여 레코드를 읽는 것 보다 데이터 파일을 바로 읽는 것이 더욱 빠르다고 판단하여 `풀 테이블 스캔(ALL)`을 진행한 것을 확인할 수 있다.\n\n> 인덱스를 통해 레코드를 읽는 것 > 데이터 파일을 바로 읽는 것 (비용 측면)\n> \n\n## 커버링 인덱스 활용\n\n이제 `커버링 인덱스` 활용을 위해 모든 칼럼을 조회(`*`)하는 쿼리에서 `nickname`과 `track` 칼럼을 활용하여 조회하는 방식으로 개선한다.\n\n```sql\nSELECT nickname, track \nFROM crew \nWHERE nickname BETWEEN 'a' AND 'd' AND track = 'BACKEND';   \n```\n\n다시 실행 계획을 살펴보자.\n\n```sql\nmysql> EXPLAIN SELECT nickname, track FROM crew WHERE nickname BETWEEN 'a' AND 'd' AND track = 'BACKEND';\n+----+-------------+-------+------------+-------+-------------------------+-------------------------+---------+------+--------+----------+--------------------------+   \n| id | select_type | table | partitions | type  | possible_keys           | key                     | key_len | ref  | rows   | filtered | Extra                    |   \n+----+-------------+-------+------------+-------+-------------------------+-------------------------+---------+------+--------+----------+--------------------------+   \n|  1 | SIMPLE      | crew  | NULL       | range | idx_crew_nickname_track | idx_crew_nickname_track | 164     | NULL | 368652 |    10.00 | Using where; Using index |   \n+----+-------------+-------+------------+-------+-------------------------+-------------------------+---------+------+--------+----------+--------------------------+   \n```\n\n`type`을 살펴보면 `Index Range Scan`이 발생한 것을 볼 수 있다. 또한 추가적으로 확인해야 할 부분이 있는데, `Extra` 칼럼의 `Using index`이다. 커버링 인덱스를 타게 되면 `Extra` 칼럼에 `Using index`가 표시되는 것을 확인할 수 있다.\n\n## 조회  속도 비교\n\n이제 `모든 칼럼을 조회하는 쿼리`와 `커버링 인덱스가 가능한 쿼리`의 조회 속도를 비교해보자. 테이블에는 100만건의 데이터가 있다.\n\n먼저 모든 칼럼의 조회 속도이다.\n\n```sql\nSELECT *\nFROM crew \nWHERE nickname BETWEEN 'a' AND 'd' AND track = 'BACKEND';   \n\n+----------+---------+\n| nickname | track   |\n+----------+---------+\n| a0002ccc | BACKEND |\n| a000319e | BACKEND |\n| a00058f1 | BACKEND |\n| ...      | ...     |\n| cfffd6f4 | BACKEND |\n| cfffdb4a | BACKEND |\n| cffffbb2 | BACKEND |\n+----------+---------+\n93617 rows in set (3.04 sec)\n```\n\n다음은 커버링 인덱스로 개선한 조회 쿼리이다.\n\n```sql\nSELECT nickname, track \nFROM crew \nWHERE nickname BETWEEN 'a' AND 'd' AND track = 'BACKEND';   \n\n+----------+---------+\n| nickname | track   |\n+----------+---------+\n| a0002ccc | BACKEND |\n| a000319e | BACKEND |\n| a00058f1 | BACKEND |\n| ...      | ...     |\n| cfffd6f4 | BACKEND |\n| cfffdb4a | BACKEND |\n| cffffbb2 | BACKEND |\n+----------+---------+  \n93617 rows in set (0.54 sec)\n```\n\n`3.04 sec → 0.54 sec` 로 조회 성능이 개선된 것을 확인할 수 있다. 100만건 보다 많은 데이터가 있다면 보다 더 유의미한 차이가 날 것이라 기대한다.\n\n## 커버링 인덱스의 숨겨진 비밀\n\n커버링 인덱스에는 한 가지 비밀이 더 숨겨져 있다. 만약 `프라이머리 키`인 `id`를 함께 조회하는 이 쿼리는 어떤 인덱스를 탈까?\n\n```sql\nSELECT id, nickname, track \nFROM crew \nWHERE nickname BETWEEN 'a' AND 'd' AND track = 'BACKEND';   \n```\n\n실행 계획을 살펴보자.\n\n```sql\nmysql> EXPLAIN SELECT id, nickname, track FROM crew WHERE nickname BETWEEN 'a' AND 'd' AND track = 'BACKEND';\n+----+-------------+-------+------------+-------+-------------------------+-------------------------+---------+------+--------+----------+--------------------------+   \n| id | select_type | table | partitions | type  | possible_keys           | key                     | key_len | ref  | rows   | filtered | Extra                    |   \n+----+-------------+-------+------------+-------+-------------------------+-------------------------+---------+------+--------+----------+--------------------------+   \n|  1 | SIMPLE      | crew  | NULL       | range | idx_crew_nickname_track | idx_crew_nickname_track | 164     | NULL | 368652 |    10.00 | Using where; Using index |   \n+----+-------------+-------+------------+-------+-------------------------+-------------------------+---------+------+--------+----------+--------------------------+   \n```\n\n앞선 예시와 동일하게 커버링 인덱스를 타는 것을 확인할 수 있다. `프라이머리 키`는 `복합 인덱스`로 설정하지 않았는데 왜 같은 결과가 나올까?\n\n그에 대한 해답은 `InnoDB`의 `세컨더리 인덱스`의 특수한 구조 덕분이다. 세컨더리 인덱스의 리프 노드는 실제 레코드의 주소를 가지고 있는 것이 아닌, 클러스터드 인덱스가 걸린 프라이머리 키를 주소로 가지고 있다.\n\n![](./image-2.png)\n\n그렇기 때문에 이 프라이머리 키를 포함한 조회 쿼리도 충분히 커버링 인덱스로 활용이 가능하다.\n\n## References.\n\n백은빈, 이성욱, 『Real MySQL 8.0』, 위키북스(2021), p476 ~ 479\n"},{"excerpt":"우아한테크코스 미션 중 Spring의 을 직접 구현해보며 순수한 JDBC만 사용했을 때 들을 분리하며 리팩토링하는 과정을 경험하였다. 미션을 진행하며 실제 Spring의 JdbcTemplate 내부 코드를 살펴보았는데, 특정한 패턴을 가진 코드가 반복되는 것을 확인할 수 있었다. 간단한 예제를 통해 Spring은 반복된 코드를 어떻게 개선 하였는지 알아보…","fields":{"slug":"/template-callback/"},"frontmatter":{"date":"October 09, 2022","title":"jdbcTemplate을 만들며 마주한 Template Callback 패턴","tags":["우아한테크코스","Spring","jdbcTempate","Template Callback 패턴"]},"rawMarkdownBody":"\n우아한테크코스 미션 중 Spring의 `JdbcTemplate`을 직접 구현해보며 순수한 JDBC만 사용했을 때 `중복되는 로직`들을 분리하며 리팩토링하는 과정을 경험하였다.\n\n미션을 진행하며 실제 Spring의 JdbcTemplate 내부 코드를 살펴보았는데, 특정한 패턴을 가진 코드가 반복되는 것을 확인할 수 있었다. 간단한 예제를 통해 Spring은 반복된 코드를 어떻게 개선 하였는지 알아보려 한다.\n\n구현 코드는 [jwp-dashboard-jdbc](https://github.com/hyeonic/jwp-dashboard-jdbc/tree/step1)에서 확인할 수 있다.\n\n## 데이터베이스와 통신하기\n\nJava에서 데이터베이스와 통신하기 위해서는 아래와 같은 과정이 필요하다.\n\n * 커넥션을 연결한다.\n * SQL을 전달한다.\n * 응답을 확인한다.\n\n이러한 과정은 JDBC API를 통해 적절히 추상화 되어 있다. 자세한 내용은 [JDBC](https://hyeonic.github.io/jdbc)에 정리해두었다. 적절한 `추상화` 덕분에 우리는 어떤 데이터베이스를 사용하는지 신경 쓰지 않고 비즈니스 로직에 집중할 수 있게 되었다.\n\n자 이제 JDBC API를 사용하여 User를 추가하는 간단한 로직을 작성해보자.\n\n```java\npublic class UserDao {\n\n    private final DataSource dataSource;\n    \n    public UserDao(final DataSource dataSource) {\n        this.dataSource = dataSource;\n    }\n\n    public void insert(final User user) {\n        var sql = \"INSERT INTO users (account, password, email) VALUES (?, ?, ?)\";\n        try (var connection = dataSource.getConnection();\n             var preparedStatement = connection.prepareStatement(sql)) {\n\n            preparedStatement.setString(1, user.getAccount());\n            preparedStatement.setString(2, user.getPassword());\n            preparedStatement.setString(3, user.getEmail());\n\n            preparedStatement.executeUpdate();\n        } catch (final SQLException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n```\n\njava 7에 등장한 `try-with-resources`도 활용해보고, connection 생성을 위해 DataSource를 생성하는 방식도 외부에서 주입 받도록 설정하였다. 여기서 User 삭제하기 위한 `delete` 메서드가 추가된다고 가정하자.\n\n```java\npublic class UserDao {\n\n    private final DataSource dataSource;\n    \n    public UserDao(final DataSource dataSource) {\n        this.dataSource = dataSource;\n    }\n\n    public void insert(final User user) {\n        var sql = \"INSERT INTO users (account, password, email) VALUES (?, ?, ?)\";\n        try (var connection = dataSource.getConnection();\n             var preparedStatement = connection.prepareStatement(sql)) {\n\n            preparedStatement.setString(1, user.getAccount());\n            preparedStatement.setString(2, user.getPassword());\n            preparedStatement.setString(3, user.getEmail());\n\n            preparedStatement.executeUpdate();\n        } catch (final SQLException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public void delete(final Long id) {\n        var sql = \"DELETE FROM user WHERE id = ?\";\n        try (var connection = dataSource.getConnection();\n             var prepareStatement = connection.prepareStatement(sql)) {\n\n            prepareStatement.setLong(1, id);\n\n            prepareStatement.executeUpdate();\n        } catch (SQLException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n```\n\n슬슬 중복되는 코드가 눈에 보이기 시작한다. 또한 커넥션을 획득하기 위한 `getConnection()`나 `prepareStatement()` 등은 `Checked Exception`인 `SQLException`을 catch 하도록 강제하고 있다.\n\n중복되는 로직은 메서드 분리를 통해 개선하면 그만이다. 하지만 가장 큰 문제는 따로 있다. 우리가 `UserDao`에게 가지길 원하는 책임은 User를 저장하고, 삭제하고, 조회하는 등의 데이터 관리 측면에 가깝다. 하지만 위 코드는 데이터베이스에게 커넥션을 획득하고, 쿼리를 전송하는 등 `관심사 밖의 로직`까지 포함하고 있다.\n\n만약 이러한 Dao가 늘어나면 어떻게 될까? 각각의 Dao는 자신의 `비즈니스 로직`과 `데이터베이스 통신을 위한 로직`들을 반복해서 작성해야 할 것이다. \n\n## JdbcTemplate\n\n`JdbcTemplate`은 `org.springframework.jdbc.core` 패키지의 중심 클래스이다. 리소스 생성 및 해제를 처리하므로 커넥션을 닫는 것을 잊어버리는 등의 일반적인 오류를 방지할 수 있다. \n\nJdbcTemplate은 아래와 같은 일을 담당한다.\n\n * SQL 쿼리를 실행한다.\n * statement 및 stored procedure를 호출을 업데이트한다.\n * ResultSet 인스턴스에 대한 반복 및 반환된 매개 변수 값을 추출을 수행한다.\n * JDBC 예외를 catch하고 `org.springframework.dao`에 정의된 일반적이고 보다 유익한 예외 계층을 반환한다.\n\n단순히 JDBC를 사용하는 것 보다 중복되는 데이터베이스와 관련된 로직을 대신 처리해주며 비즈니스 로직에 집중할 수 있게 만들어준다. 자세한 내용은 [3.3.1. Using JdbcTemplate](https://docs.spring.io/spring-framework/docs/current/reference/html/data-access.html#jdbc-JdbcTemplate)을 살펴보자.\n\n자 이제 이러한 장점을 잘 기억해두고 간단한 버전의 JdbcTemplate을 만들어보자. 먼저 데이터베이스와의 통신 과정을 UserDao에서 분리한다.\n\n> 직접 만든 JdbcTemplate의 메서드 시그니처는 실제 Spring JdbcTemplate을 참고하였다. \n\n```java\npublic class CustomJdbcTemplate {\n    private final DataSource dataSource;\n\n    public CustomJdbcTemplate(final DataSource dataSource) {\n        this.dataSource = dataSource;\n    }\n\n    public <T> List<T> query(final String sql, final RowMapper<T> rowMapper) {\n        try (var connection = dataSource.getConnection();\n             var preparedStatement = connection.prepareStatement(sql)) {\n            var resultSet = preparedStatement.executeQuery();\n            return toRows(rowMapper, resultSet);\n        } catch (final SQLException e) {\n            throw new DataAccessException(e);\n        }\n    }\n\n    public <T> T queryForObject(final String sql, final RowMapper<T> rowMapper, Object... args) {\n        try (var connection = dataSource.getConnection();\n             var preparedStatement = connection.prepareStatement(sql)) {\n            setParams(preparedStatement, args);\n            var resultSet = preparedStatement.executeQuery();\n            return DataAccessUtils.singleResult(toRows(rowMapper, resultSet));\n        } catch (final SQLException e) {\n            throw new DataAccessException(e);\n        }\n    }\n\n    private <T> List<T> toRows(final RowMapper<T> rowMapper, final ResultSet resultSet) throws SQLException {\n        var rows = new ArrayList<T>();\n        while (resultSet.next()) {\n            rows.add(rowMapper.mapRow(resultSet));\n        }\n        return rows;\n    }\n\n    public void update(final String sql, final Object... args) {\n        try (var connection = dataSource.getConnection();\n             var preparedStatement = connection.prepareStatement(sql)) {\n            setParams(preparedStatement, args);\n            preparedStatement.executeUpdate();\n        } catch (final SQLException e) {\n            throw new DataAccessException(e);\n        }\n    }\n\n    private void setParams(final PreparedStatement preparedStatement, final Object... args) throws SQLException {\n        for (int i = 0; i < args.length; i++) {\n            preparedStatement.setObject(i + 1, args[i]);\n        }\n    }\n}\n```\n\nJdbcTemplate에 데이터베이스 통신과 관련된 로직을 모두 이동시켰다. 덕분에 `UserDao`는 SQL 쿼리 작성한 진행하면 데이터베이스에서 조회한 값을 적절히 반환할 수 있게 되었다.\n\n```java\npackage com.techcourse.dao;\n\n// 전부 제거된 JDBC 관련 의존성\nimport com.techcourse.domain.User;\nimport nextstep.jdbc.core.JdbcTemplate;\nimport nextstep.jdbc.core.RowMapper;\n\npublic class UserDao {\n    ...\n    private final JdbcTemplate jdbcTemplate;\n\n    public UserDao(final JdbcTemplate jdbcTemplate) {\n        this.jdbcTemplate = jdbcTemplate;\n    }\n\n    public void insert(final User user) {\n        var sql = \"INSERT INTO users (account, password, email) VALUES (?, ?, ?)\";\n        jdbcTemplate.update(sql, user.getAccount(), user.getPassword(), user.getEmail());\n    }\n\n    public void update(final User user) {\n        var sql = \"UPDATE users SET account = ?, password = ?, email = ? WHERE id = ?\";\n        jdbcTemplate.update(sql, user.getAccount(), user.getPassword(), user.getEmail(), user.getId());\n    }\n    ...\n}\n```\n\n많이 개선되었지만 아직 문제가 남아있다. `CustomJdbcTemplate`을 살펴보면 각 메서드가 데이터베이스 커넥션과 통신하기 위해 매번 열고 닫고를 반복하고 있다. \n\n## 템플릿 콜백 패턴\n\n`템플릿 콜백 패턴`은 메서드를 통해 전략을 주입 받은 형태이다. `전략 패턴`의 한 종류라고 볼 수 있다. `전략 패턴`에서 핵심은 `변하는 부분`과 `변하지 않는 부분`을 잘 구분하고, 변하는 부분을 전략으로 추출해야 한다.\n\n위 로직에서 `변하는 부분(중복되는 부분)`과 `변하지 않는 부분(중복되지 않는 부분)`은 어디일까? 바로 아래와 같다.\n\n```java\npublic class CustomJdbcTemplate {\n    ...\n    public <T> List<T> query(final String sql, final RowMapper<T> rowMapper) {\n        try (var connection = dataSource.getConnection();                   // 변하지 않는 부분     \n             var preparedStatement = connection.prepareStatement(sql)) {    // 변하지 않는 부분     \n            var resultSet = preparedStatement.executeQuery();               // 변하는 부분          \n            return toRows(rowMapper, resultSet);                            // 변하는 부분          \n        } catch (final SQLException e) {                                    // 변하지 않는 부분     \n            throw new DataAccessException(e);                               // 변하지 않는 부분     \n        }                                                               \n    }\n    ...\n}\n```\n\n> `템플릿`: 변하지 않는 부분에 해당한다. <br>\n> `콜백`: 다른 코드의 매개변수로 넘겨주는 실행 가능한 코드를 말한다. 콜백을 넘겨받는 메서드는 필요에 따라 적절히 활용한다. Java에는 객체 없이 메서드를 독립적으로 관리할 수 없다. Java 8 이후에는 람다를 활용하여 콜백 함수를 정의하곤 한다.\n\n> 템플릿 콜백 패턴은 GOF의 디자인 패턴은 아니다. 스프링 내부에서 자주 사용하여 이렇게 부른다. 간단히 생각하면 전략 패턴을 메서드 실행 시점에 주입한 형태라고 생각하면 된다. 스프링 내부에서 XxxTemplate의 형태가 있다면 템플릿 콜백 패턴을 활용했다고 보면 된다.\n\n`템플릿 콜백 패턴`도 동일하다. 변화되는 부분을 독립된 클래스, 익명 내부 클래스, 람다를 활용하여 `메서드 실행 시점에 주입`하는 형태이다. 말로하면 너무 장황하니 바로 코드로 살펴보자.\n\n먼저 반복되는, 변하지 않는 부분을 메서드로 추출한다.\n\n```java\npublic class CustomJdbcTemplate {\n    ...\n    private <T> T execute(final String sql, final PreparedStatementCallback<T> action) {\n        try (var connection = dataSource.getConnection();\n             var preparedStatement = connection.prepareStatement(sql)) {\n            return action.doInPreparedStatement(preparedStatement);\n        } catch (final SQLException e) {\n            throw new DataAccessException(e);\n        }\n    }\n}\n```\n\n핵심은 `PreparedStatementCallback<T> action`이다. Java는 객체 없이 독립적인 메서드를 생성할 수 없기 때문에 함수형 인터페이스를 활용한다.\n\n```java\n@FunctionalInterface\npublic interface PreparedStatementCallback<T> {\n\n    T doInPreparedStatement(final PreparedStatement preparedStatement) throws SQLException, DataAccessException;\n}\n```\n\n이제 `execute()` 메서드 실행 시점에 필요한 행위을 구현하여 매개변수로 넘겨준다. \n\n```java\npublic class CustomJdbcTemplate {\n    ...\n   public <T> List<T> query(final String sql, final RowMapper<T> rowMapper) {\n        return execute(sql, preparedStatement -> {\n            var resultSet = preparedStatement.executeQuery();\n            return toRows(rowMapper, resultSet);\n        });\n    }\n\n    public <T> T queryForObject(final String sql, final RowMapper<T> rowMapper, Object... args) {\n        return execute(sql, preparedStatement -> {\n            setParams(preparedStatement, args);\n            var resultSet = preparedStatement.executeQuery();\n            return DataAccessUtils.singleResult(toRows(rowMapper, resultSet));\n        });\n    }\n    ...\n}\n```\n\n이제 각각의 메서드는 `변하는 부분`만을 가지고 있다. 이렇게 변하는 부분은 `람다`를 통해 적절히 구현한 뒤 전달하는 형태로 개선할 수 있다.\n\n## 정리\n\n간단한 예제를 통해 Spring은 어떠한 방식으로 `JdbcTemplate`을 구성 했는지에 대해 알아보았다. 이전에는 단순히 사용하는데 급급했지만 직접 만들어보며 라이브러리의 의도를 보다 더 명확하게 파악할 수 있었다.\n\n코드가 중복된다는 것은 중복되는 코드에 변화가 생길 때 영향의 범위가 커진다는 것을 의미한다. 즉 이러한 중복의 범위를 줄여야 한다. \n\n템플릿 콜백 패턴은 `변하는 부분`을 함수형 인터페이스로 분리하여 매개 변수로 전달 받는다. 덕분에 `변하지 않는 부분`은 중복되지 않고 재사용하여 개선할 수 있다.\n\n### References.\n[jwp-dashboard-jdbc](https://github.com/hyeonic/jwp-dashboard-jdbc/tree/step1)<br>\n[JdbcTemplate](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/jdbc/core/JdbcTemplate.html)<br>\n[3.3.1. Using JdbcTemplate](https://docs.spring.io/spring-framework/docs/current/reference/html/data-access.html#jdbc-JdbcTemplate)<br>\n[스프링 핵심 원리 - 고급편](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B3%A0%EA%B8%89%ED%8E%B8)\n"},{"excerpt":"는 Java 프로그래밍 언어에서 을 제공한다. 를 사용하면 관계형 데이터베이스에서 스프레드 시트 및 플랫 파일에 이르기까지 거의 모든 데이터 소스에 접근할 수 있다. JDBC 기술은 tools와 alternate interfaces를 구축할 수 있는 common base를 제공한다. 특정 DBMS에서 JDBC API를 사용하려면 JDBC 기술과 데이터베이…","fields":{"slug":"/jdbc/"},"frontmatter":{"date":"October 08, 2022","title":"JDBC","tags":["우아한테크코스","JDBC"]},"rawMarkdownBody":"\n`JDBC (Java Database Connectivity) API`는 Java 프로그래밍 언어에서 `범용 데이터 접근`을 제공한다. `JDBC API`를 사용하면 관계형 데이터베이스에서 스프레드 시트 및 플랫 파일에 이르기까지 거의 모든 데이터 소스에 접근할 수 있다. JDBC 기술은 tools와 alternate interfaces를 구축할 수 있는 common base를 제공한다.\n\n특정 DBMS에서 JDBC API를 사용하려면 JDBC 기술과 데이터베이스 사이를 중재하는 JDBC 기술 기반의 드라이버가 필요하다. 다양한 요인에 따라 드라이버는 순전히 Java 프로그래밍 언어 또는 Java 프로그래밍 언어와 JNI (Java Native Interface) 네이티브 메서드가 혼합된 형태로 작성될 수 있다. \n\n## 왜 등장하게 되었을까?\n\n애플리케이션 개발을 위해서는 데이터를 활용해야 한다. 이러한 데이터는 적절한 저장소에서 안전하게 관리되어야 한다. 이것을 보통 데이터베이스에 보관한다.\n\n클라이언트는 애플리케이션의 서버를 통해 데이터를 조작한다. 애플리케이션 서버는 이러한 데이터를 적절히 관리하기 위해 아래 과정을 거치며 데이터베이스와 통신한다.\n\n- 커넥션을 연결한다.\n- SQL을 전달한다.\n- 결과 응답을 확인한다.\n\n데이터베이스의 종류는 수십가지이다. 각각의 데이터베이스는 커넥션을 연결하고, SQL을 전달하고 응답을 확인하는 방법이 각기 다르다. 이러한 문제를 해결하기 위해 JDBC라는 `표준`이 등장 하게 되었다. 우리는 구현체에 신경 쓰지 않고 JDBC에 명세된 표준 API에 의존하여 애플리케이션 서버를 구축하면 된다.\n\n물론 인터페이스만으로 애플리케이션이 동작하지 않는다. 해당 인터페이스를 적절히 구현한 구현체가 필요하다. 보통 이러한 구현체는 각 데이터베이스 회사에서 구현한 라이브러리로 제공된다. 이것을 JDBC 드라이버라 한다. 우리가 MySQL에 접근하기 위해서 gradle에 `runtimeOnly 'mysql:mysql-connector-java'`을 추가한 경험이 있을 것이다. 이 라이브러리 내부에는 JDBC의 표준 인터페이스가 적절히 `구현`되어 제공된다.\n\n## 표준의 이점은 무엇일까?\n\nJava는 이렇게 인터페이스를 통한 표준을 적절히 제공해주고 있다. 이것의 장점은 표준을 통해 구현된 구현체를 직접적으로 의존하지 않고 개발을 진행할 수 있다. \n\n표준을 통해 인터페이스만 의존하면 구현체는 손 쉽게 `변경`할 수 있을 것이다. 이것은 결국 객체지향 관점에서 인터페이스를 통한 `느슨한 결합`을 통해 유연하게 의존 객체를 변경할 수 있다는 것을 의미한다.\n\n## Driver와 Datasource\n\n### Driver\n\n```java\npublic interface Driver {\n\n    Connection connect(String url, java.util.Properties info)\n        throws SQLException;\n\n    boolean acceptsURL(String url) throws SQLException;\n\n    DriverPropertyInfo[] getPropertyInfo(String url, java.util.Properties info)\n                         throws SQLException;\n\n    int getMajorVersion();\n\n    int getMinorVersion();\n\n    boolean jdbcCompliant();\n\n    public Logger getParentLogger() throws SQLFeatureNotSupportedException;\n}\n```\n\n모든 Driver 클래스에서 구현해야 하는 인터페이스이다. Java SQL 프레임워크는 여러 데이터베이스 드라이버를 허용한다. 각 드라이버는 드라이버 인터페이스를 구현한 클래스를 제공해야 한다. DirverManager는 찾을 수 있는 드라이버를 로드 하기 위해 시도하고, 주어진 connection 요청에 대해 각 드라이버에게 대상 URL에 연결을 시도하도록 차례로 요청한다.\n\n```java\nclass DriverManagerTest {\n\n    private static final String H2_URL = \"jdbc:h2:./test\";\n    private static final String USER = \"sa\";\n    private static final String PASSWORD = \"\";\n\n    @Test\n    void driverManager() throws SQLException {\n        try (final Connection connection = DriverManager.getConnection(H2_URL, USER, PASSWORD)) {\n            assertThat(connection.isValid(1)).isTrue();\n        }\n    }\n```\n\nJDBC는 `java.sql.Connection` 표준 인터페이스를 정의한다. 각 데이터베이스 벤더사들은 그에 맞는 구현체를 구현한다. \n\n`DriverManager`는 라이브러리로 등록된 드라이버 목록을 `자동`으로 인식한다. `getConnection()` 메서드를 실행하는 시점에 등록된 `Connection` 구현체를 반환하게 된다.\n\n### DataSource\n\n데이터베이스 커넥션을 획득하기 위해서는 DriverManager를 통해 복잡한 과정을 거쳐야만 가능하다. 커넥션을 획득하는 것은 단순해보이지만 굉장히 `비싼 비용`을 가지고 있다.\n\n- 데이터베이스와 TCP/IP 통신을 진행한 뒤 커넥션을 연결한다.\n- 연결된 커넥션으로 ID, PASSWORD 등을 데이터베이스에 전달한다.\n- 인증이 완료되면 데이터베이스 세션을 생성한다.\n- 커넥션 생성이 완료되면 응답한다.\n- 응답 받은 드라이버는 커넥션 객체를 생성하여 반환한다.\n\n보통 비싼 생성 비용을 가진 커넥션 객체는 미리 `생성`한 뒤 `재사용` 하는 방식으로 개선한다. 이것을 `데이터베이스 커넥션 풀`이라 한다.\n\n`커넥션 풀`에 속한 커넥션은 데이터베이스와 `항상 연결된 상태`를 유지한다. 사용자는 SQL 요청을 위해 매번 커넥션을 연결하는 것이 아니라 커넥션 풀에서 `유휴 상태의 커넥션`을 꺼내 사용한 뒤 적절히 `반납`한다. 여기서 반납한다는 것은 커넥션을 종료하는 것이 아니라 다시 `커넥션 풀로 반환`한다는 의미이다.\n\n`DriverManager`를 활용한 커넥션 생성은 매 `요청 마다 새롭게 생성하는 구조`를 가진다. `DataSource`는 이러한 단점을 극복하기 위해 `커넥션 획득 방법`을 적절히 `추상화`하였다.\n\n```java\npublic interface DataSource  extends CommonDataSource, Wrapper {\n\n  Connection getConnection() throws SQLException;\n\n  Connection getConnection(String username, String password)\n    throws SQLException;\n\n  @Override\n  java.io.PrintWriter getLogWriter() throws SQLException;\n\n  @Override\n  void setLogWriter(java.io.PrintWriter out) throws SQLException;\n\n  @Override\n  void setLoginTimeout(int seconds) throws SQLException;\n\n  @Override\n  int getLoginTimeout() throws SQLException;\n\n  default ConnectionBuilder createConnectionBuilder() throws SQLException {\n        throw new SQLFeatureNotSupportedException(\"createConnectionBuilder not implemented\");\n  };\n\n}\n```\n\nDataSource 인터페이스는 각 데이터베이스 벤더사에 의해 구현된다. 구현에는 세 가지 유형을 가지고 있다.\n\n- `Basic implementation`: 표준 Connection 객체를 생성한다.\n- `Connection Pooling implementation`: connection pooling에 자동으로 참여하는 Connection 객체를 생성한다. 이 구현은 중간 계층 connection pooling manager와 함께 동작한다.\n- `Distributed transaction implementation`: 분산 트랜잭션에 사용할 수 있는 Connection 객체를 생성하고 거의 항상 connection pooling에 참여한다. 이 구현은 중간 계층의 트랜잭션 manger와 함께 작동하며 거의 항상 connection pooling manager와 함께 작동한다.\n\nDataSource 객체를 통해 접근하는 드라이버는 DriverManger에 등록되지 않는다. 대신 조회 작업을 통해 DataSource 객체를 검색한 다음 Connection 객체를 만드는 데 사용된다. 기본 구현의 경우 DataSource 객체를 통해 얻은 연결은 DriverManger를 통해 얻은 연결과 동일하다.\n\n```java\nclass DataSourceTest {\n\n    private static final String H2_URL = \"jdbc:h2:./test\";\n    private static final String USER = \"sa\";\n    private static final String PASSWORD = \"\";\n\n    @Test\n    void dataSource() throws SQLException {\n        final JdbcDataSource dataSource = new JdbcDataSource();\n        dataSource.setURL(H2_URL);\n        dataSource.setUser(USER);\n        dataSource.setPassword(PASSWORD);\n\n        try (final var connection = dataSource.getConnection()) {\n            assertThat(connection.isValid(1)).isTrue();\n        }\n    }\n}\n```\n\nDataSource는 데이터베이스 연결을 위한 정보를 생성과 동시에 설정할 수 있다. DriverManager 처럼 connection을 연결할 때 마다 정보를 전달할 필요가 없다. 덕분에 한 번 세팅 해두면 dataSource를 의존한 객체는 편리하게 connection을 가져다 쓸 수 있다.\n\n또한 커넥션 풀을 구현한 `DataSource` 구현체를 활용할 수 있다. 아래는 h2 드라이버에 구현된 `JdbcConnectionPool`이다.\n\n```java\npackage org.h2.jdbcx;\n\npublic final class JdbcConnectionPool\n        implements DataSource, ConnectionEventListener, JdbcConnectionPoolBackwardsCompat {\n    ...\n    @Override\n    public Connection getConnection() throws SQLException {\n        ... \n    }\n}\n```\n\n정리하면 `DataSource`는 다양한 구현체를 사용하여 `커넥션 풀을 구성`하고, 인터페이스를 통한 객체간의 `느슨한 결합`을 유지할 수 있다.\n\n- 느슨한 결합은 데이터베이스를 쉽게 전환할 수 있도록 도와준다.\n- Connection을 만드는 것은 많은 비용을 소모한다. 대부분의 데이터베이스는 이것을 개선하기 위해 커넥션 풀을 제공한다.\n\n## Connection\n\n특정 데이터베이스와 connection(session)이다. SQL문이 실행되고 연결 컨텍스트 내에서 결과가 반환된다.\n\nConnection 객체의 데이터베이스는 테이블, 지원되는 SQL 문법, stored procedures, 연결 기능 등을 설명하는 정보를 제공할 수 있다. 이 정보는 `getMetaData()` 메서드를 사용하여 가져온다.\n\n## Statement와 PreparedStatement\n\n두 인터페이스는 모두 `SQL 쿼리 전달`을 위한 역할이다. 내부적으로 `CheckedException`인 `SQLException`을 던지기 때문에 예외에 대한 추가적인 처리를 진행해야 한다.\n\n```java\npublic class SQLException extends java.lang.Exception\n                          implements Iterable<Throwable> {\n\n    ...\n    public SQLException(String reason, String SQLState, int vendorCode) {\n        super(reason);\n        this.SQLState = SQLState;\n        this.vendorCode = vendorCode;\n        if (!(this instanceof SQLWarning)) {\n            if (DriverManager.getLogWriter() != null) {\n                DriverManager.println(\"SQLState(\" + SQLState +\n                                                \") vendor code(\" + vendorCode + \")\");\n                printStackTrace(DriverManager.getLogWriter());\n            }\n        }\n    }\n    ...\n}\n```\n\n### Statement\n\n`Statement` 객체가 생성되면 `executeQuery()` 메서드를 호출하여 SQL문을 실행시킬 수 있다. 메서드의 인수로 SQL문을 담은 `String 객체`를 전달한다. 정적인 쿼리문을 처리할 수 있다. 쿼리문에 값이 미리 입력되어 있어야 한다.\n\n### PreparedStatement\n\nSQL 문장이 미리 컴파일되고 실행 시간동안 인수값을 위한 공간을 확보할 수 있다. `Statement` 객체의 SQL은 실행될 때 마다 서버에서 분석해야 하는 반면, `PreparedStatement` 객체는 한 번 분석되면 `재사용` 하여 효율적으로 사용할 수 있다. \n\n각각의 인수에 대해 `place holder`를 사용하여 SQL 문장을 정의할 수 있다. 동일한 SQL문을 특정 값만 바꿔 여러 번 실행해야 할 때 혹은 인수가 많아서 SQL 문을 정리해야 할 때 유용하다.\n\n## ResultSet\n\n일반적으로 데이터베이스 쿼리문을 실행하여 생성되는 데이터베이스 결과 집합을 나타내기 위한 데이터 테이블이다. \n\nResultSet 객체는 현재 데이터 행을 가리키는 커서를 유지한다. 처음에 커서는 첫 번째 행 앞에 배치된다. `next()` 메서드는 커서를 다음 행으로 옮기고 ResultSet 객체에 행이 더 이상 없을 때 false를 반환하므로 결과 집합을 반복하는 while loop에서 사용할 수 있다.\n\n기본 `ResultSet` 객체는 업데이트할 수 없으며 앞으로만 이동하는 커서만 존재한다. 따라서 첫 번째 행부터 마지막 행까지 한 번만 반복할 수 있다. \n\n## SQLException은 왜 Checked Exception일까?\n\n`DataSource`를 활용하여 `Connection`, `Statement`, `ResultSet`과 같은 객체를 사용하다 보면 대부분 `SQLException`을 던지는 것을 확인할 수 있다. \n\n생길 수 있는 예외를 명시하는 것은 개발자가 해당 객체를 사용할 때 인지할 수 있는 좋은 수단이 된다. 다만 `SQLException`의 경우 `Exception` 클래스를 상속한 `Checked Exception`이기 때문에 컴파일 시점에 예외 핸들링을 강제한다.\n\n때문에 객체를 사용할 때 마다 반복적인 `try-catch-finally`로 자원을 해제 시켜야 한다. 그나마 Java 7 이후에는 `try-with-resources`가 등장 했기 때문에 전보다는 깔끔한 코드를 작성할 수 있게 되었다\n\n```java\npackage nextstep.jdbc.core;\n\n...\n\npublic class JdbcTemplate {\n    ...\n    private <T> T execute(final String sql, final PreparedStatementCallback<T> action) {\n        try (var connection = dataSource.getConnection();\n             var preparedStatement = connection.prepareStatement(sql)) {\n            return action.doInPreparedStatement(preparedStatement);\n        } catch (final SQLException e) {\n            throw new DataAccessException(e);\n        }\n    }\n}\n```\n\n`Effective Java 아이템 70 - 복구할 수 있는 상황에는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 사용하라`에 따르면 `Checked Exception`이 적절한 상황은 `호출한 쪽에서 복구하리라 여겨지는 상황이라면 Checked Exception을 사용하라`고 명시되어 있다.\n\n만약 `Connection` 객체 연결 실패로 `SQLException`이 발생 했다고 가정해보자. 과연 개발자는 `catch`에서 어떠한 복구 전략을 떠올릴 수 있을까? 이미 실패한 연결을 다시 요청해야 할까? 그렇다고 예외를 무시하는 것은 바람직하지 못하다. 결국 보다 더 유의미한 예외로 포장하여 다시 전파할 뿐이다.\n\n이러나 저러나 `Checked Exception`은 개발자에게 처리를 강제하는 것은 여전하다. 아무래도 외부 서버와의 통신을 진행하면 예측할 수 없기 때문에 이러한 `처리를 강제`하는 취지에서 등장 하지 않았을까 판단한다. \n\n## References.\n\n[https://all-record.tistory.com/79](https://all-record.tistory.com/79)<br>\n[https://docs.oracle.com/javase/8/docs/api/java/sql/DriverManager.html](https://docs.oracle.com/javase/8/docs/api/java/sql/DriverManager.html)<br>\n[https://docs.oracle.com/javase/8/docs/api/javax/sql/DataSource.html](https://docs.oracle.com/javase/8/docs/api/javax/sql/DataSource.html)<br>\n[스프링 DB 1편 - 데이터 접근 핵심 원리](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-db-1#)<br>\n조슈아 블로크 지음, 개앞맴시(이복연) 옮김, 『이펙티브 자바』, 프로그래밍 인사이트(2020), p390-392.\n"},{"excerpt":"현재 우아한테크코스에서는  미션을 진행하고 있다. 지금까지 를 활용하여 기본적으로 적용되던 이었지만 어떠한 목적으로 등장 했으며, 무엇을 제공해주는지 알지 못한채 웹 애플리케이션 개발을 위해서만 사용하곤 했다. 직접 Tomcat을 만들어가는 미션을 시작한 만큼 이번 기회를 통해 에 대해 간단히 정리해보려 한다. 해당 게시글은 Tomcat 9.x.x 버전을…","fields":{"slug":"/basic-tomcat/"},"frontmatter":{"date":"September 03, 2022","title":"Tomcat","tags":["우아한테크코스","Tomcat","Java EE","Jakarta EE","Web Container"]},"rawMarkdownBody":"\n현재 우아한테크코스에서는 `Tomcat 구현하기` 미션을 진행하고 있다. 지금까지 `Spring Boot`를 활용하여 기본적으로 적용되던 `Tomcat`이었지만 어떠한 목적으로 등장 했으며, 무엇을 제공해주는지 알지 못한채 웹 애플리케이션 개발을 위해서만 사용하곤 했다. 직접 Tomcat을 만들어가는 미션을 시작한 만큼 이번 기회를 통해 `Tomcat`에 대해 간단히 정리해보려 한다.\n\n> 해당 게시글은 Tomcat 9.x.x 버전을 기준으로 작성 되었습니다.\n\n## Tomcat 이란?\n\n`Tomcat`은 `Server`이다. `Server`란 사전적 의미로 네트워크에서 다른 컴퓨터 및 소프트웨어와 같은 클라이언트에게 `서비스`를 `제공`하는 주체이다. 그렇다면 `Tomcat`은 클라이언트에게 어떤 것을 `제공`해주기 위한 `Server`일까?\n\n## Java Enterprise Edition (Java EE)\n\n`Java`로 분산 애플리케이션 개발을 목적으로 만들었다. Enterprise 애플리케이션을 개발 및 실행 하기 위한 기술과 환경을 제공하며 Servlet, JSP, EJB, JDBC 등 `Server`를 개발하기 위해 필요한 기술들의 `스펙`을 모아둔 것이다. \n\n이러한 명세가 모여 하나의 Java EE가 정의되면 해당 명세를 기반으로 구현한 것을 `WAS (Web Application Server)`라 부른다. 대표적으로 GlassFish, JBoss와 같은 제품들이 존재한다.\n\n이 밖에도 모바일 환경에 필요한 컴포넌트를 모아둔 `Java Micro Edition`, 표준 환경(Desktop Application)에서 제공하기 위한 `Standard Edition`이 있다.\n\n> 이클립스 재단으로 이관된 Java EE의 공식 명칭은 Jakarta EE로 변경 되었다. 자세한 내용은 [Java EE에서 Jakarta EE로의 전환](https://www.samsungsds.com/kr/insights/java_jakarta.html)에서 확인해볼 수 있다.\n\nTomcat 9.x.x 까지는 `Java EE`의 명세를 따라간다. Tomcat 10.x.x 버전 이후 부터 `Jakarta EE`를 기반으로 진행되고 있다. 실제 [Tomcat github](https://github.com/apache/tomcat)에 들어가보면 아래와 같이 구성되어 있는 것을 확인할 수 있다.\n\n**Tomcat 9.0.x**\n\n![](./tomcat9.png)\n \n**Tomcat 10.0.x**\n\n![](./tomcat10.png)\n\n## Java EE 서버의 Container\n\n![](./java-ee-containers.png)\n\n위 그림은 클라이언트와 Java EE 서버가 통신하는 구조를 보여 준다. `Web Contatiner`는 웹 브라우저에서 HTTP를 통해 들어온 요청에 대한 처리를 담당한다. `EJB Contatiner`는 `Web Contatiner` 혹은 직접적인 통신으로 들어온 요청에 대한 `비즈니스 로직`을 수행한다. \n\n단순한 `Application 클라이언트`의 경우 HTTP가 아닌 다른 방식을 활용하여 Java EE 서버의 `EJB Container`를 통해 비즈니스 로직을 수행할 수 있다. 하지만 `웹 브라우저 클라이언트`의 경우엔 다르다. 오직 HTTP 통신을 위한 `Web Container`를 거쳐야만 `EJB Container`의 비즈니스 로직을 수행할 수 있다.\n\n이러한 `Container`에는 `Servlet`, `JSP`와 같은 다양한 컴포넌트로 구성되어 있다. 이러한 Java EE의 서버 내부는 컴포넌트를 묶은 `Container`로 구분할 수 있다.\n\n아래는 Java EE 7의 Architecture Diagram이다.\n\n![](./java-ee-7-architecture.png)\n\n> 각 Container의 컴포넌트가 궁금하다면 Java EE Architecture diagram, Jakarta Architecture diagram와 같은 키워드로 검색 시 확인할 수 있다. [Architecture](https://jakarta.ee/specifications/platform/8/platform-spec-8.html#architecture)\n\n## Web Container\n\n그렇다면 도대체 `Java EE`와 `Tomcat`은 어떤 관련이 있는 걸까? 앞서 언급한 것처럼 Java EE 스펙을 구현한 것을 `WAS`라고 부른다. 대부분 Tomcat을 검색 해보면 대표적인 `WAS`로 소개되곤 한다.\n\n사실 `Tomcat`은 온전한 `WAS`라고 볼 수 없다. `Tomcat`은 오로지 `Java EE Container` 중 `Web Container`만을 구현하였기 때문이다.\n\n![](./web-container.png)\n\n그렇기 때문에 `Web Container`을 구현한 `Tomcat`은 `HTTP` 통신에 대한 요청만 처리할 수 있다.\n\n# Tomcat Version\n\n아래는 `Tomcat`의 버전 별 `Web Container`에 속한 `컴포넌트의 명세 버전`을 가져온 것이다.\n\n![](./tomcat-version.png)\n\n`Tomcat 9.0.x`의 경우 `Servlet 4.0`, `JSP 2.3`, `WebSocket 1.1` 등을 지원하고 있는 것을 확인할 수 있다. 또한 `Java 8` 이후를 사용해야 동작 가능 하다.\n\n# 정리\n\n지금까지 `Tomcat`과 `Java EE`에 대해 간단히 알아보았다. 우리가 지금까지 알고 있던 `WAS`와는 다르게 `Tomcat`은 오직 `Java EE`의 `Web Container`만을 구현하고 있다. \n\n다시 한번 질문에 대한 답변을 정리해보려 한다. `Tomcat`은 클라이언트에게 어떤 것을 `제공`해주기 위한 `Server`일까? `Tomcat`은 `Web Container` 스펙의 `구현`이며, `HTTP`에 대한 요청을 처리할 수 있는 `Server`이다.\n\n## References.\n\n[Java EE에서 Jakarta EE로의 전환](https://www.samsungsds.com/kr/insights/java_jakarta.html)<br>\n[Java EE Clients](https://docs.oracle.com/cd/E19575-01/819-3669/bnabc/index.html)<br>\n[Architecture](https://jakarta.ee/specifications/platform/8/platform-spec-8.html#architecture)<br>\n[Apache Tomcat Versions](https://tomcat.apache.org/whichversion.html)\n"},{"excerpt":"@MappedSuperclass 부모 클래스를 상속 받는 자식 클래스에게 매핑 정보만 제공할 때 사용한다. 즉, 단순히 으로만 사용하기 때문에 추상 클래스 처럼 사용할 수 있다. 특징으로는 아래와 같다. 테이블과 직접적인 매핑 없이 자식 클래스가 매핑 정보를 상속하기 위해 사용한다. 해당 클래스는 직접 생성하여 사용할 일이 없기 때문에 추상 클래스를 권장…","fields":{"slug":"/mappedsuperclass-vs-embedded/"},"frontmatter":{"date":"August 22, 2022","title":"@MappedSuperclass vs @Embedded","tags":["우아한테크코스","상속","조합","MappedSuperclass","Embedded"]},"rawMarkdownBody":"\n## @MappedSuperclass\n\n부모 클래스를 상속 받는 자식 클래스에게 매핑 정보만 제공할 때 사용한다. 즉, 단순히 `매핑 정보를 상속할 목적`으로만 사용하기 때문에 추상 클래스 처럼 사용할 수 있다. 특징으로는 아래와 같다.\n\n * 테이블과 직접적인 매핑 없이 자식 클래스가 매핑 정보를 상속하기 위해 사용한다.\n * 해당 클래스는 직접 생성하여 사용할 일이 없기 때문에 추상 클래스를 권장한다.\n\n정리하면 테이블과 관계 없이 단순히 엔티티가 공통으로 사용하는 `매핑 정보를 모아주는 역할`을 담당한다. \n\n## @Embedded\n\n새로운 값 타입을 직접 정의해서 사용할 수 있다. JPA에서는 이것을 임베디드 타입이라고 한다. 보다 더 객체지향적인 코드 작성을 위해 사용할 수 있다. 해당 애노테이션을 활용하면 객체의 책임에 대한 `응집도`를 높일 수 있으며, 코드가 더욱 명확해질 것이다. 특징으로는 아래와 같다.\n\n * `@Embeddable`: 값 타입을 정의하는 곳에 표시\n * `@Embedded`: 값 타입을 사용하는 곳에 표시\n    * 둘 중 하나는 생략 가능\n * 기본 생성자 필수\n * 임베디드 타입을 포함한 모든 값 타입은 엔티티의 생명주기에 의존한다. 즉 `Composition 관계`와 가깝게 그려진다.\n\n이러한 임베디드 타입은 단순히 엔티티의 값으로 표현되기 대문에 해당 값이 속한 엔티티 테이블에 매핑된다. 이러한 임베디드 타입 덕분에 객체와 테이블을 아주 세밀하게 조작하고 매핑할 수 있게 되었다. 잘 설계한 ORM 애플리케이션은 매핑한 테이블 수 보다 클래스 수가 더 많아질 것이다.\n\n## @MappedSuperclass vs @Embedded\n\n결국 두 애노테이션 모두 엔티티의 비슷한 속성을 분리하여 효과적으로 관리할 수 있는 공통점이 있다. 이 둘이 가장 큰 차이점은 바로 `상속`을 사용하는 것과 `위임`을 사용하는 것에 대한 차이이다.\n\n아래는 객체가 생성되는 시점에 시간을 기록하기 위한 필드를 각각의 방식으로 작성한 것이다.\n\n### @MappedSuperclass를 활용한 방식\n\n먼저 `@MappedSuperclass`를 활용한 방식이다.\n\n> _간단한 예시를 위해 필드 주입을 활용 하였다._\n\n```java\n@MappedSuperclass\npublic abstract class BaseEntity {\n\n    @Column(name = \"created_at\", nullable = false)\n    private LocalDateTime createdAt = LocalDateTime.now();\n\n    // getter\n}\n```\n\n```java\n@Entity\npublic class MappedSuperclassCrew extends BaseEntity {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    @Column\n    private String name;\n\n    @Column\n    private Integer age;\n\n    @Enumerated(EnumType.STRING)\n    private Track track;\n\n    protected MappedSuperclassCrew() {\n    }\n\n    public MappedSuperclassCrew(final String name, final Integer age, final Track track) {\n        this.name = name;\n        this.age = age;\n        this.track = track;\n    }\n\n    // getter\n}\n```\n\n앞서 언급한 것처럼 `@MappedSuperclass`을 활용하면 추상 클래스를 통해 중복된 필드를 상속 받아 편리하게 활용할 수 있다.\n\n### @Embedded를 활용한 방식\n\n다음은 `@Embedded` 활용한 방식이다.\n\n> _간단한 예시를 위해 필드 주입을 활용 하였다._\n\n```java\n@Embeddable\npublic class TraceDateTime {\n\n    @Column(name = \"created_at\", nullable = false, updatable = false)\n    private LocalDateTime createAt = LocalDateTime.now();\n\n    protected TraceDateTime() {\n    }\n\n    // getter\n}\n```\n\n```java\n@Entity\npublic class EmbeddedCrew {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    @Column\n    private String name;\n\n    @Column\n    private Integer age;\n\n    @Enumerated(EnumType.STRING)\n    private Track track;\n\n    @Embedded\n    private TraceDateTime traceDateTime;\n\n    protected EmbeddedCrew() {\n    }\n\n    public EmbeddedCrew(final String name, final Integer age, final Track track) {\n        this.name = name;\n        this.age = age;\n        this.track = track;\n    }\n\n    // getter\n}\n```\n\n## 정리\n\n결국 단순히 이야기 하면 두 애노테이션의 가장 큰 차이는 `상속`과 `위임`이다. 보다 더 유연한 객체를 다루기 위해 부모 클래스와 의존성이 강하게 엮인 `상속 보단 조합`을 고려하곤 한다. 하지만 위 같은 예시의 경우 단순히 `엔티티의 중복된 필드를 재사용하기 위한 목적`이 크기 때문에 상속을 고려하는 것이 더욱 편리하다. 또한 `@MappedSuperclass`과 `Auditing` 기능을 함께 활용하면 더 편리하게 필드 값을 다룰 수 있을 것이다.\n\n`JPQL`을 활용할 때도 차이가 발생한다.\n\n```java\npublic interface MappedSuperclassCrewRepository extends JpaRepository<MappedSuperclassCrew, Long> {\n\n    @Query(\"SELECT c \" \n            + \"FROM MappedSuperclassCrew c \" \n            + \"WHERE c.createdAt > :dateTime\")\n    List<MappedSuperclassCrew> findByCreatedAtGreaterThan(final LocalDateTime dateTime);\n}\n```\n\n```java\npublic interface EmbeddedCrewRepository extends JpaRepository<EmbeddedCrew, Long> {\n\n    @Query(\"SELECT c \"\n            + \"FROM EmbeddedCrew c \"\n            + \"WHERE c.traceDateTime.createAt > :dateTime\")\n    List<EmbeddedCrewRepository> findByCreatedAtGreaterThan(final LocalDateTime dateTime);\n}\n```\n\n임베디드 타입을 사용할 경우 `c.traceDateTime.createAt`과 같이 필드명을 명시해주어야 한다.\n\n## References.\n\n김영한, 『자바 ORM 표준 JPA 프로그래밍』, 에이콘(2015), p251-254, p321-325. <br>\n[임베디드 타입과 @MappedSuperclass 차이](https://www.inflearn.com/questions/18578)\n"},{"excerpt":"Google은 Refresh Token을 쉽게 내주지 않는다. 우리 달록은 캘린더를 손쉽게 공유할 수 이다. 현재에는 우리 서비스 내에서만 일정이 등록 가능한 상태이다. 추후 확장성을 고려하여 와 연동하기 위해 Google에서 제공하는 token 정보를 관리해야 하는 요구사항이 추가 되었다. code를 활용한 AccessToken 및 IdToken 발급 …","fields":{"slug":"/google-refresh-token/"},"frontmatter":{"date":"August 16, 2022","title":"Google은 Refresh Token을 쉽게 내주지 않는다.","tags":["우아한테크코스","달록","OAuth","OpenId","refresh token"]},"rawMarkdownBody":"\n## Google은 Refresh Token을 쉽게 내주지 않는다.\n\n우리 [달록](https://github.com/woowacourse-teams/2022-dallog)은 캘린더를 손쉽게 공유할 수 `구독형 캘린더 공유 서비스`이다. 현재에는 우리 서비스 내에서만 일정이 등록 가능한 상태이다. 추후 확장성을 고려하여 `Google Calendar API`와 연동하기 위해 Google에서 제공하는 token 정보를 관리해야 하는 요구사항이 추가 되었다.\n\n## code를 활용한 AccessToken 및 IdToken 발급\n\nGoogle은 OAuth 2.0 요청 때 적절한 `scope(e.g. openid)`를 추가하면 `OpenID Connect`를 통해 Google 리소스에 접근 가능한 `Access Token`, AccessToken을 재발급 받기 위한 `Refresh Token`, 회원의 정보가 담긴 `IdToken`을 발급해준다. \n\n`Access Token`의 경우 짧은 만료 시간을 가지고 있기 때문에 google `Access Token` 재발급을 위한 `Refresh Token`을 저장하고 관리해야 한다. `Refresh Token`은 `Access Token`보다 긴 만료 시간을 가지고 있기 때문에 보안에 유의해야 한다. 그렇기 때문에 프론트 측에서 관리하는 것 보다 달록 DB에 저장한 뒤 관리하기로 결정 하였다. 참고로 Google은 보통 아래와 같은 이유가 발생할 때 `Refresh Token`을 만료시킨다고 한다.\n\n[Refresh Token 만료](https://developers.google.com/identity/protocols/oauth2#expiration)\n\n * 사용자가 앱의 액세스 권한을 취소한 경우\n * Refresh Token이 6개월 동안 사용되지 않은 경우\n * 사용자가 비밀번호를 변경했으며 Gmail scope가 포함된 경우\n * 사용자가 계정에 부여된 Refresh Token 한도를 초과한 경우\n * 세션 제어 정책이 적용되는 Google Cloud Platform 조직에 사용자가 속해있는 경우\n\n정리하면 `Refresh Token`은 만료 기간이 비교적 길기 때문에 서버 측에서 안전하게 보관하며 필요할 때 리소스 접근을 위한 `Access Token`을 발급 받는 형태를 구상하게 되었다.\n\n우리 [달록](https://github.com/woowacourse-teams/2022-dallog)은 아래와 같은 형태로 인증이 이루어진다. \n\n![](./oauth-flow.png)\n\n> _달록팀 후디 고마워요!_\n\n프론트 측에서 `OAuth 인증`을 위해서는 달록 서버에서 제공하는 `OAuth 인증을 위한 페이지 uri`을 활용해야 한다. 달록 서버는 해당 uri를 생성하여 전달한다. 로직은 아래 코드로 구현되어 있다.\n\n```java\n@Component\npublic class GoogleOAuthUri implements OAuthUri {\n\n    private final GoogleProperties properties;\n\n    public GoogleOAuthUri(final GoogleProperties properties) {\n        this.properties = properties;\n    }\n\n    @Override\n    public String generate() {\n        return properties.getOAuthEndPoint() + \"?\"\n                + \"client_id=\" + properties.getClientId() + \"&\"\n                + \"redirect_uri=\" + properties.getRedirectUri() + \"&\"\n                + \"response_type=code&\"\n                + \"scope=\" + String.join(\" \", properties.getScopes());\n    }\n}\n```\n\n이제 브라우저에서 해당 uri에 접속하면 아래와 같은 페이지를 확인할 수 있다.\n\n![](./google-oauth-uri.png)\n\n계정을 선택하면 `redirect uri`와 함께 `code` 값이 전달되고, google의 token을 발급 받기 위해 백엔드 서버로 `code` 정보를 전달하게 된다. 아래는 실제 code 정보를 기반으로 google token을 생성한 뒤 `id token`에 명시된 정보를 기반으로 회원을 생성 or 조회한 뒤 `달록 리소스에 접근하기 위한 access token`을 발급해주는 API이다.\n\n```java\n@RequestMapping(\"/api/auth\")\n@RestController\npublic class AuthController {\n\n    private final AuthService authService;\n\n    public AuthController(final AuthService authService) {\n        this.authService = authService;\n    }\n    ...\n    @PostMapping(\"/{oauthProvider}/token\")\n    public ResponseEntity<TokenResponse> generateToken(@PathVariable final String oauthProvider,\n                                                       @RequestBody final TokenRequest tokenRequest) {\n        TokenResponse tokenResponse = authService.generateToken(tokenRequest.getCode());\n        return ResponseEntity.ok(tokenResponse);\n    }\n    ...\n}\n```\n\n * `authService.generateToken(tokenRequest.getCode())`: code 정보를 기반으로 google 토큰 정보를 조회한다. 메서드 내부에서 [code을 액세스 토큰 및 ID 토큰으로 교환](https://developers.google.com/identity/protocols/oauth2/openid-connect#exchangecode)에서 제공된 형식에 맞춰 google에게 code 정보를 전달하고 토큰 정보를 교환한다. \n\n실제 Google에서 토큰 정보를 교환 받는 클라이언트를 담당하는 `GoogleOAuthClient`이다. 핵심은 인가 코드를 기반으로 `GoogleTokenResponse`를 발급 받는 다는 것이다.\n```java\n@Component\npublic class GoogleOAuthClient implements OAuthClient {\n\n    private static final String JWT_DELIMITER = \"\\\\.\";\n\n    private final GoogleProperties properties;\n    private final RestTemplate restTemplate;\n    private final ObjectMapper objectMapper;\n\n    public GoogleOAuthClient(final GoogleProperties properties, final RestTemplateBuilder restTemplateBuilder,\n                             final ObjectMapper objectMapper) {\n        this.properties = properties;\n        this.restTemplate = restTemplateBuilder.build();\n        this.objectMapper = objectMapper;\n    }\n\n    @Override\n    public OAuthMember getOAuthMember(final String code) {\n        // code을 액세스 토큰 및 ID 토큰으로 교환\n        GoogleTokenResponse googleTokenResponse = requestGoogleToken(code);\n        String payload = getPayload(googleTokenResponse.getIdToken());\n        UserInfo userInfo = parseUserInfo(payload);\n\n        String refreshToken = googleTokenResponse.getRefreshToken();\n        return new OAuthMember(userInfo.getEmail(), userInfo.getName(), userInfo.getPicture(), refreshToken);\n    }\n\n    private GoogleTokenResponse requestGoogleToken(final String code) {\n        HttpHeaders headers = new HttpHeaders();\n        headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);\n        MultiValueMap<String, String> params = generateTokenParams(code);\n\n        HttpEntity<MultiValueMap<String, String>> request = new HttpEntity<>(params, headers);\n        return fetchGoogleToken(request).getBody();\n    }\n\n    private MultiValueMap<String, String> generateTokenParams(final String code) {\n        MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n        params.add(\"client_id\", properties.getClientId());\n        params.add(\"client_secret\", properties.getClientSecret());\n        params.add(\"code\", code);\n        params.add(\"grant_type\", \"authorization_code\");\n        params.add(\"redirect_uri\", properties.getRedirectUri());\n        return params;\n    }\n\n    private ResponseEntity<GoogleTokenResponse> fetchGoogleToken(\n            final HttpEntity<MultiValueMap<String, String>> request) {\n        try {\n            return restTemplate.postForEntity(properties.getTokenUri(), request, GoogleTokenResponse.class);\n        } catch (RestClientException e) {\n            throw new OAuthException(e);\n        }\n    }\n\n    private String getPayload(final String jwt) {\n        return jwt.split(JWT_DELIMITER)[1];\n    }\n\n    private UserInfo parseUserInfo(final String payload) {\n        String decodedPayload = decodeJwtPayload(payload);\n        try {\n            return objectMapper.readValue(decodedPayload, UserInfo.class);\n        } catch (JsonProcessingException e) {\n            throw new OAuthException(\"id 토큰을 읽을 수 없습니다.\");\n        }\n    }\n\n    private String decodeJwtPayload(final String payload) {\n        return new String(Base64.getUrlDecoder().decode(payload), StandardCharsets.UTF_8);\n    }\n    ...\n}\n```\n\n이제 Google에게 제공 받은 `Refresh Token`을 저장해보자.\n\n## Refresh Token에 채워진 null\n\n이게 무슨 일인가, 분명 요청 형식에 맞춰 헤더를 채워 디버깅을 해보면 계속해서 `null` 값으로 전달되고 있는 것이다. 즉, Google 측에서 Refresh Token을 보내주지 않고 있다는 것을 의미한다.\n\n![](./google-refresh-token-null.png)\n\n다시 한번 [액세스 토큰 새로고침 (오프라인 액세스)](https://developers.google.com/identity/protocols/oauth2/web-server#offline)를 살펴보았다.\n\n![](./google-refresh-token-docs.png)\n\n정리하면 [Google OAuth 2.0 서버로 리디렉션](https://developers.google.com/identity/protocols/oauth2/web-server#redirecting)할 때 query parameter에 `access_type`을 `offline`으로 설정해야 한다는 것이다. 다시 되돌아 가서 Google 인증 요청을 위한 uri를 생성하는 메서드를 아래와 같이 수정하였다.\n\n```java\n@Component\npublic class GoogleOAuthUri implements OAuthUri {\n\n    private final GoogleProperties properties;\n\n    public GoogleOAuthUri(final GoogleProperties properties) {\n        this.properties = properties;\n    }\n\n    @Override\n    public String generate() {\n        return properties.getOAuthEndPoint() + \"?\"\n                + \"client_id=\" + properties.getClientId() + \"&\"\n                + \"redirect_uri=\" + properties.getRedirectUri() + \"&\"\n                + \"response_type=code&\"\n                + \"scope=\" + String.join(\" \", properties.getScopes()) + \"&\"\n                + \"access_type=offline\"; // 추가된 부분\n    }\n}\n```\n\n이제 다시 요청을 진행해보자! 분명 `refresh token`이 정상적으로 교환될 것이다.\n\n## 또 다시 Refresh Token에 채워진 null\n\n분명 문서에 명시한 대로 설정을 진행했지만 아직도 동일하게 `null` 값이 채워져 있다.\n\n![](./google-refresh-token-null-2.png)\n\n> _해달라는 데로 다해줬는데..._\n\n## 엄격한 Google\n\nGoogle은 OAuth 2.0을 통해 인증을 받을 때 Refresh Token을 굉장히 엄격하게 다룬다. 사용자가 로그인을 진행할 때 마다 Refresh Token 정보를 주는 것이 아니라, Google에 등록된 App에 최초 로그인 할 때만 제공해준다. 즉, 재로그인을 진행해도 Refresh Token은 발급해주지 않는다. \n\nGoogle의 의도대로 동작하려면 내가 우리 서비스에 최초로 로그인을 진행하는 시점에만 Refresh Token을 발급받고 서버 내부에 저장한 뒤 필요할 때 꺼내 사용해야 한다.\n\n하지만 우리 서버는 모종의 이유로 최초에 받아온 Refresh Token을 저장하지 못할 수 있다. 이때 [Google OAuth 2.0 서버로 리디렉션](https://developers.google.com/identity/protocols/oauth2/web-server#redirecting)할 때 `prompt`를 `consent`로 설정하게 되면 매 로그인 마다 사용자에게 동의를 요청하기 때문에 강제로 `Refresh Token`을 받도록 지정할 수 있다.\n\n이제 진짜 마지막이다. 아래와 같이 수정한 뒤 다시 디버깅을 진행하였다.\n\n```java\n@Component\npublic class GoogleOAuthUri implements OAuthUri {\n\n    private final GoogleProperties properties;\n\n    public GoogleOAuthUri(final GoogleProperties properties) {\n        this.properties = properties;\n    }\n\n    @Override\n    public String generate() {\n        return properties.getOAuthEndPoint() + \"?\"\n                + \"client_id=\" + properties.getClientId() + \"&\"\n                + \"redirect_uri=\" + properties.getRedirectUri() + \"&\"\n                + \"response_type=code&\"\n                + \"scope=\" + String.join(\" \", properties.getScopes()) + \"&\"\n                + \"access_type=offline\"\n                + \"prompt=consent\"; // 추가된 부분\n    }\n}\n```\n\n![](./google-refresh-token-success.png)\n\n정상적으로 발급 되는 것을 확인할 수 있다!\n\n## 문제점\n\n하지만 여기서 문제가 하나 있다. 단순히 `prompt`를 `consent`로 설정할 경우 우리 서비스에 가입된 사용자는 Google OAuth 2.0 인증을 진행할 때 매번 재로그인을 진행해야 한다. 이것은 사용자에게 매우 `불쾌한 경험`으로 다가올 수 있다. 즉 우리는 매번 `재로그인`을 통해 Refresh Token을 발급 받는 것이 아닌, 최초 로그인 시 `Refresh Token`을 발급 받은 뒤 적절한 저장소에 저장하고 관리해야 한다.\n\n그렇다면 실제 운영 환경이 아닌 테스트 환경에서는 어떻게 해야 할까? 운영 환경과 동일한 `Google Cloud Project`를 사용할 경우 최초 로그인을 진행할 때 `내 권한 정보가 등록`된다. 즉 Refresh Token을 재발급 받을 수 없다는 것을 의미한다. \n\n우리 달록은 운영 환경과 테스트 환경에서 서로 다른 `Google Cloud Project`를 생성하여 관리하는 방향에 대해 고민하고 있다. 이미 Spring Profile 기능을 통해 각 실행 환경에 대한 설정을 분리해두었기 때문에 쉽게 적용이 가능할 것이라 기대한다. 정리하면 아래와 같다.\n\n * `운영 환경`: Refresh Token 발급을 위해 `accept_type`을 `offline`으로 설정한다. 단 최초 로그인에만 Refresh Token을 발급 받기 위해 `prompt`는 명시하지 않는다.\n * `개발 환경`: 개발 환경에서는 매번 DataBase가 초기화 되기 때문에 Refresh Token을 유지하여 관리할 수 없다. 테스트를 위한 추가적인 `Google Cloud Project`를 생성한 뒤, `accept_type`을 `offline`으로, `prompt`는 `consent`로 설정하여 매번 새롭게 Refresh Token을 받도록 세팅한다.\n\n## 정리\n\n영어를 번역기로 해석한 수준의 문장으로 인해 많은 시간을 삽질하게 되었다. 덕분에 Google에서 의도하는 Refresh Token에 대한 사용 방식과 어디에서 저장하고 관리해야 하는지에 대해 좀 더 깊은 고민을 할 수 있게 되었다. 만약 나와 같은 상황에 직면한 사람이 있다면 이 글이 도움이 되길 바란다!\n\n## References.\n\n[dallog repository](https://github.com/woowacourse-teams/2022-dallog)<br>\n[https://github.com/devHudi](https://github.com/devHudi)<br>\n[passport.js에서 구글 OAuth 진행 시 Refresh Token을 못 받아오는 문제 해결](https://m.blog.naver.com/dldbdgml99/222013891067)<br>\n"},{"excerpt":"properties 객체로 다루기 Spring에서 이나 에 존재하는 값을 불러오는 방법에는 대표적으로  애노테이션을 사용한 방법과 를 사용한 방법이 존재한다. 두 방식을 직접 적용해 본 뒤 차이와 이점에 대해 알아보려 한다. @Value 사용하기 는 기본적으로 설정 정보를 단일값으로 주입 받기 위해 사용된다. 아래는 실제 달록 프로젝트에서 적용한 예시이다…","fields":{"slug":"/properties-to-object/"},"frontmatter":{"date":"July 27, 2022","title":"properties 객체로 다루기","tags":["우아한테크코스","달록","properties"]},"rawMarkdownBody":"\n## properties 객체로 다루기\n\nSpring에서 `application.yml`이나 `application.properties`에 존재하는 값을 불러오는 방법에는 대표적으로 `@Value` 애노테이션을 사용한 방법과 `@ConfigurationProperties`를 사용한 방법이 존재한다. 두 방식을 직접 적용해 본 뒤 차이와 이점에 대해 알아보려 한다.\n\n## @Value 사용하기\n\n`@Value`는 기본적으로 설정 정보를 단일값으로 주입 받기 위해 사용된다. 아래는 실제 달록 프로젝트에서 적용한 예시이다.\n\n```java\n@Component\npublic class GoogleOAuthClient implements OAuthClient {\n\n    private static final String JWT_DELIMITER = \"\\\\.\";\n\n    private final String clientId;\n    private final String clientSecret;\n    private final String grantType;\n    private final String redirectUri;\n    private final String tokenUri;\n    private final RestTemplate restTemplate;\n    private final ObjectMapper objectMapper;\n\n    public GoogleOAuthClient(@Value(\"${oauth.google.client-id}\") final String clientId,\n                             @Value(\"${oauth.google.client-secret}\") final String clientSecret,\n                             @Value(\"${oauth.google.grant-type}\") final String grantType,\n                             @Value(\"${oauth.google.redirect-uri}\") final String redirectUri,\n                             @Value(\"${oauth.google.token-uri}\") final String tokenUri,\n                             final RestTemplateBuilder restTemplateBuilder, final ObjectMapper objectMapper) {\n        this.clientId = clientId;\n        this.clientSecret = clientSecret;\n        this.grantType = grantType;\n        this.redirectUri = redirectUri;\n        this.tokenUri = tokenUri;\n        this.restTemplate = restTemplateBuilder.build();\n        this.objectMapper = objectMapper;\n    }\n\t\t...\n}\n```\n\n간단하게 적용이 가능하지만 공통으로 묶인 프로퍼티가 많아질 경우 코드가 지저분해진다. 이러한 프로퍼티 값들을 객체로 매핑하여 사용하기 위한 애노테이션으로 `@ConfigurationProperties`가 존재한다.\n\n## @ConfigurationProperties\n\n우리는 때때로 DB 설정을 작성하기 위해 `application.yml`을 통해 관련 정보를 작성하곤 한다. 아래는 간단한 h2 DB를 연결하기 위한 설정을 적은 예시이다.\n\n```yaml\nspring:\n  datasource:\n    url: jdbc:h2:~/dallog;MODE=MYSQL;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE\n    username: sa\n```\n\n이러한 설정들은 어디서 어떻게 활용되고 있을까? 실제 바인딩 되고 있는 객체를 따라가보자.\n\n```java\n@ConfigurationProperties(prefix = \"spring.datasource\")\npublic class DataSourceProperties implements BeanClassLoaderAware, InitializingBean {\n\t\n    private ClassLoader classLoader;\n    private boolean generateUniqueName = true;\n\tprivate String name;\n\tprivate Class<? extends DataSource> type;\n\tprivate String driverClassName;\n\tprivate String url;\n    ...\n}\n```\n\n위 `DataSourceProperties`는 우리가 `application.yml`에 작성한 설정 정보를 기반으로 객체로 추출하고 있다. 이것은 Spring Boot의 자동설정으로 `DataSource`가 빈으로 주입되는 시점에 설정 정보를 활용하여 생성된다. \n\n간단히 디버깅을 진행해보면 Bean이 주입되는 시점에 아래와 같이 `application.yml`에 명시한 값들을 추출한 `DataSourceProperties`를 기반으로 생성하고 있다.\n\n![](./debug-1.png)\n\n![](./debug-2.png)\n\n정리하면 우리는 Spring Boot를 사용하며 자연스럽게 `@ConfigurationProperties`를 활용하여 만든 객체를 사용하고 있는 것이다.\n\n이제 우리가 작성한 설정 값을 기반으로 객체를 생성해서 활용해보자. 아래는 실제 프로젝트에서 사용하고 있는 `application.yml`의 일부를 가져온 것이다.\n\n```yaml\n...\noauth:\n  google:\n    client-id: ${GOOGLE_CLIENT_ID}\n    client-secret: ${GOOGLE_CLIENT_SECRET}\n    redirect-uri: ${GOOGLE_REDIRECT_URI}\n    oauth-end-point: https://accounts.google.com/o/oauth2/v2/auth\n    response-type: code\n    scopes:\n        - https://www.googleapis.com/auth/userinfo.profile\n        - https://www.googleapis.com/auth/userinfo.email\n    token-uri: ${GOOGLE_TOKEN_URI}\n    grant-type: authorization_code\n...\n```\n\n이것을 객체로 추출하기 위해서는 아래와 같이 작성해야 한다.\n\n```java\n@ConfigurationProperties(\"oauth.google\")\n@ConstructorBinding\npublic class GoogleProperties {\n\n    private final String clientId;\n    private final String clientSecret;\n    private final String redirectUri;\n    private final String oAuthEndPoint;\n    private final String responseType;\n    private final List<String> scopes;\n    private final String tokenUri;\n    private final String grantType;\n\n    public GoogleProperties(final String clientId, final String clientSecret, final String redirectUri,\n                            final String oAuthEndPoint, final String responseType, final List<String> scopes,\n                            final String tokenUri, final String grantType) {\n        this.clientId = clientId;\n        this.clientSecret = clientSecret;\n        this.redirectUri = redirectUri;\n        this.oAuthEndPoint = oAuthEndPoint;\n        this.responseType = responseType;\n        this.scopes = scopes;\n        this.tokenUri = tokenUri;\n        this.grantType = grantType;\n    }\n\n    public String getClientId() {\n        return clientId;\n    }\n\n    public String getClientSecret() {\n        return clientSecret;\n    }\n\n    public String getRedirectUri() {\n        return redirectUri;\n    }\n\n    public String getoAuthEndPoint() {\n        return oAuthEndPoint;\n    }\n\n    public String getResponseType() {\n        return responseType;\n    }\n\n    public List<String> getScopes() {\n        return scopes;\n    }\n\n    public String getTokenUri() {\n        return tokenUri;\n    }\n\n    public String getGrantType() {\n        return grantType;\n    }\n}\n```\n\n- `@ConfigurationProperties`: 프로퍼티에 있는 값을 클래스로 바인딩하기 위해 사용하는 애노테이션이다. `@ConfigurationProperties`는 값을 바인딩하기 위해 기본적으로 `Setter`가 필요하다. 하지만 `Setter`를 열어둘 경우 불변성을 보장할 수 없다. 이때 생성자를 통해 바인딩 하기 위해서는 `@ConstructorBinding`을 활용할 수 있다.\n- `@ConstructorBinding`: 앞서 언급한 것 처럼 생성자를 통해 바인딩하기 위한 목적의 애노테이션이다.\n\n```java\n@Configuration\n@EnableConfigurationProperties(GoogleProperties.class)\npublic class PropertiesConfig {\n}\n```\n\n- `@EnableConfigurationProperties`: 클래스를 지정하여 스캐닝 대상에 포함시킨다.\n\n### 개선하기\n\n```java\n@Component\npublic class GoogleOAuthClient implements OAuthClient {\n\n    private static final String JWT_DELIMITER = \"\\\\.\";\n\n    private final GoogleProperties googleProperties;\n    private final RestTemplate restTemplate;\n    private final ObjectMapper objectMapper;\n\n    public GoogleOAuthClient(final GoogleProperties googleProperties, final RestTemplateBuilder restTemplateBuilder,\n                             final ObjectMapper objectMapper) {\n        this.googleProperties = googleProperties;\n        this.restTemplate = restTemplateBuilder.build();\n        this.objectMapper = objectMapper;\n    }\n    ...\n}\n```\n\n이전 보다 적은 수의 필드를 활용하여 설정 정보를 다룰 수 있도록 개선되었다.\n\n### 정리\n\n 우리는 `application.yml` 혹은 `application.properties`에 작성하여 메타 정보를 관리할 수 있다. 클래스 내부에서 관리할 경우 수정하기 위해서는 해당 클래스에 직접 접근해야 한다. 하지만 설정 파일로 분리할 경우 우리는 환경에 따라 유연하게 값을 설정할 수 있다. 또한 `@ConfigurationProperties` 애노테이션을 사용할 경우 클래스로 값을 바인딩하기 때문에 연관된 값을 한 번에 바인딩할 수 있다.\n\n## References.\n\n[달록 repository](https://github.com/woowacourse-teams/2022-dallog)<br>\n[[Spring] @Value와 @ConfigurationProperties의 사용법 및 차이 - (2/2)](https://mangkyu.tistory.com/207)<br>\n[appendix.configuration-metadata.annotation-processor](https://docs.spring.io/spring-boot/docs/2.7.1/reference/html/configuration-metadata.html#appendix.configuration-metadata.annotation-processor)\n"},{"excerpt":"외부와 의존성 분리하기 도메인 로직은 우리가 지켜야할 매우 소중한 비즈니스 로직들이 담겨있다. 이러한 도메인 로직들은 변경이 최소화되어야 한다. 그렇기 때문에 외부와의 의존성을 최소화 해야 한다.  인터페이스 활용하기 우선 우리가 지금까지 학습한 것 중 객체 간의 의존성을 약하게 만들어 줄 수 있는 수단으로 인터페이스를 활용할 수 있다. 간단한 예시로 를…","fields":{"slug":"/separated-interface/"},"frontmatter":{"date":"July 24, 2022","title":"외부와 의존성 분리하기","tags":["우아한테크코스","달록","분리된 인터페이스","의존성 분리"]},"rawMarkdownBody":"\n## 외부와 의존성 분리하기\n\n도메인 로직은 우리가 지켜야할 매우 소중한 비즈니스 로직들이 담겨있다. 이러한 도메인 로직들은 변경이 최소화되어야 한다. 그렇기 때문에 외부와의 의존성을 최소화 해야 한다. \n\n### 인터페이스 활용하기\n\n우선 우리가 지금까지 학습한 것 중 객체 간의 의존성을 약하게 만들어 줄 수 있는 수단으로 인터페이스를 활용할 수 있다. 간단한 예시로 `JpaRepository`를 살펴보자.\n\n```java\npublic interface MemberRepository extends JpaRepository<Member, Long> {\n\n    Optional<Member> findByEmail(final String email);\n\n    boolean existsByEmail(final String email);\n}\n```\n\n이러한 인터페이스 덕분에 우리는 실제 DB에 접근하는 내부 구현에 의존하지 않고 데이터를 조작할 수 있다. 핵심은 `실제 DB에 접근하는 행위`이다.\n\n아래는 `Spring Data`가 만든 `JpaRepository의 구현체` `SimpleJpaRepository`의 일부를 가져온 것이다.\n\n```java\n@Repository\n@Transactional(readOnly = true)\npublic class SimpleJpaRepository<T, ID> implements JpaRepositoryImplementation<T, ID> {\n\n\tprivate static final String ID_MUST_NOT_BE_NULL = \"The given id must not be null!\";\n\n\tprivate final JpaEntityInformation<T, ?> entityInformation;\n\tprivate final EntityManager em;\n\tprivate final PersistenceProvider provider;\n\n\tprivate @Nullable CrudMethodMetadata metadata;\n\tprivate EscapeCharacter escapeCharacter = EscapeCharacter.DEFAULT;\n\n\tpublic SimpleJpaRepository(JpaEntityInformation<T, ?> entityInformation, EntityManager entityManager) {\n\n\t\tAssert.notNull(entityInformation, \"JpaEntityInformation must not be null!\");\n\t\tAssert.notNull(entityManager, \"EntityManager must not be null!\");\n\n\t\tthis.entityInformation = entityInformation;\n\t\tthis.em = entityManager;\n\t\tthis.provider = PersistenceProvider.fromEntityManager(entityManager);\n\t}\n  ...\n}\n```\n\n해당 구현체는 `entityManger`를 통해 객체를 영속 시키는 행위를 진행하고 있기 때문에 `영속 계층`에 가깝다고 판단했다. 즉 도메인의 입장에서 `MemberRepository`를 바라볼 때 단순히 `JpaRepository`를 상속한 인터페이스를 가지고 있기 때문에 `영속 계층`에 대한 직접적인 의존성은 없다고 봐도 무방하다. 정리하면 우리는 인터페이스를 통해 실제 구현체에 의존하지 않고 로직을 수행할 수 있게 된다. \n\n### 관점 변경하기\n\n이러한 사례를 외부 서버와 통신을 담당하는 우리가 직접 만든 인터페이스인 `OAuthClient`에 대입해본다. `OAuthClient`의 가장 큰 역할은 n의 소셜에서 `OAuth 2.0`을 활용한 인증의 행위를 정의한 인터페이스이다. google, github 등 각자에 맞는 요청을 처리하기 위해 `OAuthClient`를 구현한 뒤 로직을 처리할 수 있다. 아래는 실제 google의 인가 코드를 기반으로 토큰 정보에서 회원 정보를 조회하는 로직을 담고 있다.\n\n```java\npublic interface OAuthClient {\n\n    OAuthMember getOAuthMember(final String code);\n}\n```\n\n```java\n@Component\npublic class GoogleOAuthClient implements OAuthClient {\n\n    private static final String JWT_DELIMITER = \"\\\\.\";\n\n    private final String googleRedirectUri;\n    private final String googleClientId;\n    private final String googleClientSecret;\n    private final String googleTokenUri;\n    private final RestTemplate restTemplate;\n    private final ObjectMapper objectMapper;\n\n    public GoogleOAuthClient(@Value(\"${oauth.google.redirect_uri}\") final String googleRedirectUri,\n                             @Value(\"${oauth.google.client_id}\") final String googleClientId,\n                             @Value(\"${oauth.google.client_secret}\") final String googleClientSecret,\n                             @Value(\"${oauth.google.token_uri}\") final String googleTokenUri,\n                             final RestTemplate restTemplate, final ObjectMapper objectMapper) {\n        this.googleRedirectUri = googleRedirectUri;\n        this.googleClientId = googleClientId;\n        this.googleClientSecret = googleClientSecret;\n        this.googleTokenUri = googleTokenUri;\n        this.restTemplate = restTemplate;\n        this.objectMapper = objectMapper;\n    }\n\n    @Override\n    public OAuthMember getOAuthMember(final String code) {\n        GoogleTokenResponse googleTokenResponse = requestGoogleToken(code);\n        String payload = getPayloadFrom(googleTokenResponse.getIdToken());\n        String decodedPayload = decodeJwtPayload(payload);\n\n        try {\n            return generateOAuthMemberBy(decodedPayload);\n        } catch (JsonProcessingException e) {\n            throw new IllegalArgumentException();\n        }\n    }\n\n    private GoogleTokenResponse requestGoogleToken(final String code) {\n        HttpHeaders headers = new HttpHeaders();\n        headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);\n        MultiValueMap<String, String> params = generateRequestParams(code);\n\n        HttpEntity<MultiValueMap<String, String>> request = new HttpEntity<>(params, headers);\n        return restTemplate.postForEntity(googleTokenUri, request, GoogleTokenResponse.class).getBody();\n    }\n\n    private MultiValueMap<String, String> generateRequestParams(final String code) {\n        MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n        params.add(\"client_id\", googleClientId);\n        params.add(\"client_secret\", googleClientSecret);\n        params.add(\"code\", code);\n        params.add(\"grant_type\", \"authorization_code\");\n        params.add(\"redirect_uri\", googleRedirectUri);\n        return params;\n    }\n\n    private String getPayloadFrom(final String jwt) {\n        return jwt.split(JWT_DELIMITER)[1];\n    }\n\n    private String decodeJwtPayload(final String payload) {\n        return new String(Base64.getUrlDecoder().decode(payload), StandardCharsets.UTF_8);\n    }\n\n    private OAuthMember generateOAuthMemberBy(final String decodedIdToken) throws JsonProcessingException {\n        Map<String, String> userInfo = objectMapper.readValue(decodedIdToken, HashMap.class);\n        String email = userInfo.get(\"email\");\n        String displayName = userInfo.get(\"name\");\n        String profileImageUrl = userInfo.get(\"picture\");\n\n        return new OAuthMember(email, displayName, profileImageUrl);\n    }\n}\n```\n\n보통의 생각은 인터페이스인 `OAuthClient`와 구현체인 `GoogleOAuthClient`를 같은 패키지에 두려고 할 것이다. `GoogleOAuthClient`는 외부 의존성을 강하게 가지고 있기 때문에 `domain` 패키지와 별도로 관리하기 위한 `infrastructure` 패키지가 적합할 것이다. 결국 인터페이스인 `OAuthClient` 또한 `infrastructure`에 위치하게 될 것이다. 우리는 이러한 생각에서 벗어나 새로운 관점에서 살펴봐야 한다.\n\n앞서 언급한 의존성에 대해 생각해보자. 위 `OAuthClient`를 사용하는 주체는 누구일까? 우리는 이러한 주체를 `domain` 내에 인증을 담당하는 `auth` 패키지 내부의 `Authservice`로 결정 했다. 아래는 실제 `OAuthClient`를 사용하고 있는 주체인 `AuthService`이다.\n\n```java\n@Transactional(readOnly = true)\n@Service\npublic class AuthService {\n\n    private final OAuthEndpoint oAuthEndpoint;\n    private final OAuthClient oAuthClient;\n    private final MemberService memberService;\n    private final JwtTokenProvider jwtTokenProvider;\n\n    public AuthService(final OAuthEndpoint oAuthEndpoint, final OAuthClient oAuthClient,\n                       final MemberService memberService, final JwtTokenProvider jwtTokenProvider) {\n        this.oAuthEndpoint = oAuthEndpoint;\n        this.oAuthClient = oAuthClient;\n        this.memberService = memberService;\n        this.jwtTokenProvider = jwtTokenProvider;\n    }\n\n    public String generateGoogleLink() {\n        return oAuthEndpoint.generate();\n    }\n\n    @Transactional\n    public TokenResponse generateTokenWithCode(final String code) {\n        OAuthMember oAuthMember = oAuthClient.getOAuthMember(code);\n        String email = oAuthMember.getEmail();\n\n        if (!memberService.existsByEmail(email)) {\n            memberService.save(generateMemberBy(oAuthMember));\n        }\n\n        Member foundMember = memberService.findByEmail(email);\n        String accessToken = jwtTokenProvider.createToken(String.valueOf(foundMember.getId()));\n\n        return new TokenResponse(accessToken);\n    }\n\n    private Member generateMemberBy(final OAuthMember oAuthMember) {\n        return new Member(oAuthMember.getEmail(), oAuthMember.getProfileImageUrl(), oAuthMember.getDisplayName(), SocialType.GOOGLE);\n    }\n}\n```\n\n지금 까지 설명한 구조의 패키지 구조는 아래와 같다.\n\n```\n└── src\n    ├── main\n    │   ├── java\n    │   │   └── com\n    │   │       └── allog\n    │   │           └── dallog\n    │   │               ├── auth\n    │   │               │   └── application\n    │   │               │       └── AuthService.java\n    │   │               ...\n    │   │               ├── infrastructure\n    │   │               │   ├── oauth\n    │   │               │   │   └── client\n    │   │               │   │       ├── OAuthClient.java\n    │   │               │   │       └── GoogleOAuthClient.java\n    │   │               │   └── dto\n    │   │               │       └── OAuthMember.java     \n    │   │               └── AllogDallogApplication.java\n    |   |\n    │   └── resources\n    │       └── application.yml\n```\n\n결국 이러한 구조는 아래와 같이 `domain` 패키지에서 `infrastructure`에 의존하게 된다.\n  \n```java\n...\nimport com.allog.dallog.infrastructure.dto.OAuthMember; // 의존성 발생!\nimport com.allog.dallog.infrastructure.oauth.client.OAuthClient; // 의존성 발생!\n...\n\n@Transactional(readOnly = true)\n@Service\npublic class AuthService {\n\t...\n    private final OAuthClient oAuthClient;\n    ...\n\n    @Transactional\n    public TokenResponse generateTokenWithCode(final String code) {\n        OAuthMember oAuthMember = oAuthClient.getOAuthMember(code);\n        ...\n    }\n    ...\n}\n```\n\n### Separated Interface Pattern\n\n`분리된 인터페이스`를 활용하자. 즉 `인터페이스`와 `구현체`를 각각의 패키지로 분리한다. 분리된 인터페이스를 사용하여 `domain` 패키지에서 인터페이스를 정의하고 `infrastructure` 패키지에 구현체를 둔다. 이렇게 구성하면 인터페이스에 대한 종속성을 가진 주체가 구현체에 대해 인식하지 못하게 만들 수 있다.\n\n아래와 같은 구조로 인터페이스와 구현체를 분리했다고 가정한다.\n\n```\n└── src\n    ├── main\n    │   ├── java\n    │   │   └── com\n    │   │       └── allog\n    │   │           └── dallog\n    │   │               ├── auth\n    │   │               │   ├── application\n    │   │               │   │   ├── AuthService.java\n    │   │               │   │   └── OAuthClient.java\n    │   │               │   └── dto\n    │   │               │       └── OAuthMember.java         \n    │   │               ...\n    │   │               ├── infrastructure\n    │   │               │   ├── oauth\n    │   │               │       └── client\n    │   │               │           └── GoogleOAuthClient.java\n    │   │               └── AllogDallogApplication.java\n    |   |\n    │   └── resources\n    │       └── application.yml\n```\n\n자연스럽게 `domain` 내에 있던 `infrastructure` 패키지에 대한 의존성도 제거된다. 즉 외부 서버와의 통신을 위한 의존성이 완전히 분리된 것을 확인할 수 있다.\n\n```java\n...\nimport com.allog.dallog.auth.dto.OAuthMember; // auth 패키지 내부를 의존\n...\n@Transactional(readOnly = true)\n@Service\npublic class AuthService {\n\t...\n    private final OAuthClient oAuthClient;\n    ...\n\n    @Transactional\n    public TokenResponse generateTokenWithCode(final String code) {\n        OAuthMember oAuthMember = oAuthClient.getOAuthMember(code);\n        ...\n    }\n    ...\n}\n```\n\n## References.\n\n[Separated Interface](https://www.martinfowler.com/eaaCatalog/separatedInterface.htmlhttps://www.martinfowler.com/eaaCatalog/separatedInterface.html)\n"},{"excerpt":"개요 기본 키 할당 전략에 대한 학습을 진행하고 있었다. 기본 키 전략을 로 진행하면 데이터베이스에게 키 생성을 위임하기 때문에 JPA에서 기본 키 값을 얻어오기 위해서는 추가적인 데이터베이스 조회가 필요하다. 하지만 저장 관련 테스트를 진행했을 때 어디에도 조회와 관련된 쿼리는 찾을 수 없었다. 이게 어떻게 된 일인지 알아보려 한다. IDENTITY 앞…","fields":{"slug":"/identity-strategy/"},"frontmatter":{"date":"July 10, 2022","title":"IDENTITY 전략는 추가 조회를 하지 않을 수 있다.","tags":["우아한테크코스","jpa","IDENTITY"]},"rawMarkdownBody":"\n\n![](https://user-images.githubusercontent.com/59357153/152970395-a31c8134-fc89-449f-b4dc-441e03df929c.png)\n\n## 개요\n\n기본 키 할당 전략에 대한 학습을 진행하고 있었다. 기본 키 전략을 `IDENTITY`로 진행하면 데이터베이스에게 키 생성을 위임하기 때문에 JPA에서 기본 키 값을 얻어오기 위해서는 추가적인 데이터베이스 조회가 필요하다. 하지만 저장 관련 테스트를 진행했을 때 어디에도 조회와 관련된 쿼리는 찾을 수 없었다. 이게 어떻게 된 일인지 알아보려 한다.\n\n## IDENTITY\n\n앞서 언급한 것 처럼 `IDENTITY`는 기본 키 생성을 위한 전략을 데이터베이스에 위임 하는 것이다. `MySQL`은 보통 기본 키 자동 생성을 위해 `AUTO_INCREMENT`을 활용한다. 아래와 같이 `DDL`을 작성하면 INSERT할 때 자동으로 기본 키가 채워진다.\n\n```sql\ncreate table station (\n   id bigint auto_increment,\n    name varchar(255) not null,\n    primary key (id)\n)\n```\n\n하지만 기본 키 생성을 데이터베이스에서 진행할 경우 값이 저장되야 비로소 기본 키 값을 확인할 수 있다. 이제 JPA에 해당 전략을 적용하면 아래와 같이 작성할 수 있다.\n\n```java\n@Entity\npublic class Station {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    @Column(nullable = false)\n    private String name;\n\n    protected Station() {\n    }\n\n    public Station(String name) {\n        this.name = name;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public String getName() {\n        return name;\n    }\n}\n```\n\n간단한 예시를 위한 지하철 엔티티이다. 지하철은 이름을 가질 수 있고 기본 키 생성 전략은 `IDENTITY`이므로 데이터베이스에서 자동으로 생성된다. 만약 기본 키가 필요한 경우 조회를 위한 추가적인 쿼리가 필요할 것이다.\n\n이제 `Station`을 저장하고 id값을 조회하는 테스트를 작성한 뒤 실행했다.\n\n```java\n@DataJpaTest\nclass StationRepositoryTest {\n\n    @Autowired\n    protected StationRepository stationRepository;\n\n    @Test\n    void save() {\n        Station station = stationRepository.save(new Station(\"잠실역\"));\n\n        assertAll(() -> {\n            assertThat(station.getId()).isNotNull();\n            assertThat(station.getName()).isEqualTo(\"잠실역\");\n        });\n    }\n}\n```\n\n```bash\n2022-07-10 00:56:55.797  INFO 99986 --- [    Test worker] o.h.e.t.j.p.i.JtaPlatformInitiator       : HHH000490: Using JtaPlatform implementation: [org.hibernate.engine.transaction.jta.platform.internal.NoJtaPlatform]\n2022-07-10 00:56:55.806  INFO 99986 --- [    Test worker] j.LocalContainerEntityManagerFactoryBean : Initialized JPA EntityManagerFactory for persistence unit 'default'\n2022-07-10 00:56:56.498  INFO 99986 --- [    Test worker] subway.domain.StationRepositoryTest      : Started StationRepositoryTest in 2.891 seconds (JVM running for 3.606)\n2022-07-10 00:56:56.524  INFO 99986 --- [    Test worker] o.s.t.c.transaction.TransactionContext   : Began transaction (1) for test context [DefaultTestContext@6a362409 testClass = StationRepositoryTest, testInstance = subway.domain.StationRepositoryTest@2aa5eecd, testMethod = save@StationRepositoryTest, testException = [null], mergedContextConfiguration = [MergedContextConfiguration@36ea6a37 testClass = StationRepositoryTest, locations = '{}', classes = '{class subway.Application}', contextInitializerClasses = '[]', activeProfiles = '{}', propertySourceLocations = '{}', propertySourceProperties = '{org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTestContextBootstrapper=true}', contextCustomizers = set[org.springframework.boot.test.autoconfigure.OverrideAutoConfigurationContextCustomizerFactory$DisableAutoConfigurationContextCustomizer@3258d1dc, org.springframework.boot.test.autoconfigure.actuate.metrics.MetricsExportContextCustomizerFactory$DisableMetricExportContextCustomizer@4b4d3ed5, org.springframework.boot.test.autoconfigure.filter.TypeExcludeFiltersContextCustomizer@351584c0, org.springframework.boot.test.autoconfigure.properties.PropertyMappingContextCustomizer@e1aa1b8f, org.springframework.boot.test.autoconfigure.web.servlet.WebDriverContextCustomizerFactory$Customizer@22a24ec8, [ImportsContextCustomizer@84d34eb key = [org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration, org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration, org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration, org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration, org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration, org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration, org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration, org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration, org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration, org.springframework.boot.test.autoconfigure.jdbc.TestDatabaseAutoConfiguration, org.springframework.boot.test.autoconfigure.orm.jpa.TestEntityManagerAutoConfiguration]], org.springframework.boot.test.context.filter.ExcludeFilterContextCustomizer@3df27965, org.springframework.boot.test.json.DuplicateJsonObjectContextCustomizerFactory$DuplicateJsonObjectContextCustomizer@2794add4, org.springframework.boot.test.mock.mockito.MockitoContextCustomizer@0, org.springframework.boot.test.context.SpringBootTestArgs@1, org.springframework.boot.test.context.SpringBootTestWebEnvironment@0], contextLoader = 'org.springframework.boot.test.context.SpringBootContextLoader', parent = [null]], attributes = map['org.springframework.test.context.event.ApplicationEventsTestExecutionListener.recordApplicationEvents' -> false]]; transaction manager [org.springframework.orm.jpa.JpaTransactionManager@11ce4c44]; rollback [true]\nHibernate: \n    insert \n    into\n        station\n        (id, name) \n    values\n        (null, ?)\n2022-07-10 00:56:56.612 TRACE 99986 --- [    Test worker] o.h.type.descriptor.sql.BasicBinder      : binding parameter [1] as [VARCHAR] - [잠실역]\n2022-07-10 00:56:56.671  INFO 99986 --- [    Test worker] o.s.t.c.transaction.TransactionContext   : Rolled back transaction for test: [DefaultTestContext@6a362409 testClass = StationRepositoryTest, testInstance = subway.domain.StationRepositoryTest@2aa5eecd, testMethod = save@StationRepositoryTest, testException = [null], mergedContextConfiguration = [MergedContextConfiguration@36ea6a37 testClass = StationRepositoryTest, locations = '{}', classes = '{class subway.Application}', contextInitializerClasses = '[]', activeProfiles = '{}', propertySourceLocations = '{}', propertySourceProperties = '{org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTestContextBootstrapper=true}', contextCustomizers = set[org.springframework.boot.test.autoconfigure.OverrideAutoConfigurationContextCustomizerFactory$DisableAutoConfigurationContextCustomizer@3258d1dc, org.springframework.boot.test.autoconfigure.actuate.metrics.MetricsExportContextCustomizerFactory$DisableMetricExportContextCustomizer@4b4d3ed5, org.springframework.boot.test.autoconfigure.filter.TypeExcludeFiltersContextCustomizer@351584c0, org.springframework.boot.test.autoconfigure.properties.PropertyMappingContextCustomizer@e1aa1b8f, org.springframework.boot.test.autoconfigure.web.servlet.WebDriverContextCustomizerFactory$Customizer@22a24ec8, [ImportsContextCustomizer@84d34eb key = [org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration, org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration, org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration, org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration, org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration, org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration, org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration, org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration, org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration, org.springframework.boot.test.autoconfigure.jdbc.TestDatabaseAutoConfiguration, org.springframework.boot.test.autoconfigure.orm.jpa.TestEntityManagerAutoConfiguration]], org.springframework.boot.test.context.filter.ExcludeFilterContextCustomizer@3df27965, org.springframework.boot.test.json.DuplicateJsonObjectContextCustomizerFactory$DuplicateJsonObjectContextCustomizer@2794add4, org.springframework.boot.test.mock.mockito.MockitoContextCustomizer@0, org.springframework.boot.test.context.SpringBootTestArgs@1, org.springframework.boot.test.context.SpringBootTestWebEnvironment@0], contextLoader = 'org.springframework.boot.test.context.SpringBootContextLoader', parent = [null]], attributes = map['org.springframework.test.context.event.ApplicationEventsTestExecutionListener.recordApplicationEvents' -> false]]\n2022-07-10 00:56:56.683  INFO 99986 --- [extShutdownHook] j.LocalContainerEntityManagerFactoryBean : Closing JPA EntityManagerFactory for persistence unit 'default'\nBUILD SUCCESSFUL in 4s\n```\n\n쿼리 로그를 살펴보면 insert와 관련된 쿼리를 제외하곤 전혀 찾아볼 수 없다. 또한 위 테스트는 정상적으로 실행되므로 id 값은 적절히 잘 조회 되었을 것이다.\n\n## 기본 키 조회 쿼리는 어디에?\n\n`IDENTITY` 전략은 `JDBC`에 `Statement`의 `getGeneratedKeys()` 메서드를 통해 데이터를 저장과 동시에 기본키를 얻어 올 수 있다. JPA의 구현체인 hibernate는 이 메서드를 활용하여 데이터베이스와 한 번의 통신으로 처리한다. 즉 생성과 동시에 기본 키를 얻어오기 때문에 한 번의 `INSERT`로 해결할 수 있다.\n\n`getGeneratedKeys`의 공식 문서를 살펴보면 아래와 같은 내용을 확인할 수 있다.\n\n### 공식 문서 중 일부\nRetrieves any auto-generated keys created as a result of executing this Statement object. If this Statement object did not generate any keys, an empty ResultSet object is returned.\n\n**Statement로 실행한 결과로 생성된 자동 생성 키를 검색한다. 만약 Statement 객체가 키를 생성하지 않은 경우 빈 ResultSet을 반환한다.**\n\nNote: If the columns which represent the auto-generated keys were not specified, the JDBC driver implementation will determine the columns which best represent the auto-generated keys.\n\n**참고: 자동 생성된 키를 나타내는 열이 지정되지 않은 경우 JDBC 드라이버 구현에 따라 자동 생성된 키를 가장 잘 나타내는 열이 결정된다.**\n\nReturns: a ResultSet object containing the auto-generated key(s) generated by the execution of this Statement object\n\n**반환: Statement 객체의 실행으로 생성된 자동 생성 키가 들어 있는 ResultSet 객체이다.**\n\n`Statement` 인터페이스는 현재 h2 드라이버의 의존성을 추가한 프로젝트 에서 작성하였기 때문에 내부에 구현체 `JdbcStatement`를 사용하고 있다. 간단히 디버그 모드를 통해 save 시점에 해당 메서드가 사용되는지 확인한다.\n\n![](https://user-images.githubusercontent.com/59357153/178113850-3ae31510-548a-46d2-b98b-ff7e5474356a.png)\n\n## 정리\n\n`IDENTITY` 전략은 `INSERT` 이후 기본 키에 대한 조회를 진행할 수 있다. 즉 데이터베이스에 추가적인 조회가 필요하다. 하지만 JDBC Statement의 `getGeneratedKeys` 메서드 덕분에 데이터 저장과 동시에 기본 키를 얻을 수 있다.\n\n### 참고 사항\n\nJPA에서 엔티티는 영속 상태가 되기 위해 식별자를 반드시 필요로 한다. IDENTITY의 경우 데이터베이스에 저장되어야 식별자를 조회할 수 있는 특성으로 인해 트랜잭션이 지원하는 쓰기 지연을 활용할 수 없다. 즉 영속 시키는 즉시 데이터베이스에 쿼리를 전달한다.\n\n## References.\n\n[Returning the Generated Keys in JDBC](https://www.baeldung.com/jdbc-returning-generated-keys) <br>\n[Interface Statement](https://docs.oracle.com/en/java/javase/11/docs/api/java.sql/java/sql/Statement.html#getGeneratedKeys()) <br>\n김영한 지음, 『자바 ORM 표준 JPA 프로그래밍』, 에이콘(2015), p133-135.\n"},{"excerpt":"이번 팀 프로젝트를 진행하며 손쉽게 일정을 등록하고 관리할 수 있는 공유 캘린더를 주제로 진행하게 되었다. 캘린더를 기반한 도메인이 주를 이루기 때문에 날짜와 시간에 대한 조작이 필요했다. 이번 기회를 통해 이전에 잘 사용하지 않았던 Java의 날짜, 시간을 다루기 위한 객체에 대해 알아보려 한다. JDK 8 이전 JDK 8 이전에는 날짜와 시간을 다루기…","fields":{"slug":"/local-date-time/"},"frontmatter":{"date":"July 03, 2022","title":"java에서 날짜, 시간 제대로 사용하기","tags":["우아한테크코스","알록달록","LocalDateTime"]},"rawMarkdownBody":"\n![](https://user-images.githubusercontent.com/59357153/152970395-a31c8134-fc89-449f-b4dc-441e03df929c.png)\n\n이번 팀 프로젝트를 진행하며 손쉽게 일정을 등록하고 관리할 수 있는 공유 캘린더를 주제로 진행하게 되었다. 캘린더를 기반한 도메인이 주를 이루기 때문에 날짜와 시간에 대한 조작이 필요했다. 이번 기회를 통해 이전에 잘 사용하지 않았던 Java의 날짜, 시간을 다루기 위한 객체에 대해 알아보려 한다.\n\n## JDK 8 이전\n\nJDK 8 이전에는 날짜와 시간을 다루기 위해 주로 `java.util.Date`와 `java.util.Calender`를 사용했다. 하지만 해당 클래스는 아래와 같이 많은 문제를 가지고 있었다. \n\n * 불변 객체가 아니다. 즉 내부 필드를 바꿀 수 있는 메서드가 제공되며 만약 여러 객체에서 공유되어 사용될 경우 부작용이 생길 우려가 있다. \n * 헷갈리는 월 지정방식이다. `JDK 1.0`에서 Date 클래스는 `1월`을 `0`으로 표현하였기 때문에 직관적이지 않다. 가독성을 높이기 위해 일부는 `9월`을 `9 - 1`로 지정하는 방식을 사용하곤 한다.\n * 일관성이 없는 요일 상수를 가지고 있다. `Calendar.WEDNESDAY`의 경우 `public static final int WEDNESDAY = 4`로 수요일을 `4`로 표현하고 있다. 하지만 `Date` 객체의 `getDay()` 메서드를 통해 요일을 구하면 수요일은 `3`으로 표현된다.\n\n그 밖에도 다양한 문제들을 가지고 있다. 자세한 설명은 [Java의 날짜와 시간 API](https://d2.naver.com/helloworld/645609)에서 확인할 수 있다.\n\n## JDK 8 이후\n\n위에서 언급한 문제를 해결하기 위해 JDK 8 이후 `LocalDate`, `LocalTime`, `LocalDateTime`이 등장하였다. 이러한 객체는 기존 `Date`와 `Calender`를 개선하기 위해 등장한 라이브러리인 `joda time`의 영향을 받아 유사하게 설계되었다. 이제 각 객체의 공식 문서를 살펴보자.\n\n### LocalDate\n\n::: tip 공식 문서 중 일부\n\nA date without a time-zone in the ISO-8601 calendar system, such as 2007-12-03. LocalDate is an immutable date-time object that represents a date, often viewed as year-month-day. Other date fields, such as day-of-year, day-of-week and week-of-year, can also be accessed. For example, the value \"2nd October 2007\" can be stored in a LocalDate.\n\n**ISO-8601 달력 시스템에 \"2007-12-03\"와 같이 표준 시간대가 없는 날짜이다. LocalDate는 날짜를 나타내는 불변의 날짜-시간 객체로, 종종 year-month-day로 표시된다. 요일, 요일 및 요일과 같은 다른 날짜 필드도 접근할 수 있다. 예를들면 \"2007년 10월 2일\" 값은 LocalDate에 저장할 수 있다.**\n\nThis class does not store or represent a time or time-zone. Instead, it is a description of the date, as used for birthdays. It cannot represent an instant on the time-line without additional information such as an offset or time-zone.\n\n**이 클래스는 시간 또는 표준 시를 저장하거나 나타내지 않는다. 대신 생일에 사용되는 날짜에 대해 표현한다. ofset 또는 표준 시와 같은 추가정보 없이 타임라인의 순간을 나타낼 수 없다.**\n\nThe ISO-8601 calendar system is the modern civil calendar system used today in most of the world. It is equivalent to the proleptic Gregorian calendar system, in which today's rules for leap years are applied for all time. For most applications written today, the ISO-8601 rules are entirely suitable. However, any application that makes use of historical dates, and requires them to be accurate will find the ISO-8601 approach unsuitable.\n\n**ISO-8601 달력 체계는 오늘날 대부분의 세계에서 사용되는 현대 민간 달력 체계이다. 오늘날 윤년에 대한 규칙이 모든 시간에 적용되는 프로프래틱 그레고리력 체계와 같다. 오늘날 작성된 대부분의 응용 프로그램에는 ISO-8601 규칙이 전적으로 적합하다. 그러나 과거 날짜를 사용하고 정확한 날짜를 요구하는 모든 응용 프로그램은 ISO-8601 접근법이 적합하지 않다는 것을 알게 될 것이다.**\n\nThis is a value-based class; use of identity-sensitive operations (including reference equality (==), identity hash code, or synchronization) on instances of LocalDate may have unpredictable results and should be avoided. The equals method should be used for comparisons.\n\n**이것은 값 기반의 클래스이다. (==), 해시 코드 및 동기화와 같은 작업을 할 때 예측할 수 없는 결과가 발생할 수 있으므로 피해야 한다. 비교를 위해서는 동등 방법을 활용해야 한다.**\n\n:::\n\n아래는 간단히 `LocalDate`에 존재하는 기능들을 테스트 한 것이다.\n\n```java\npublic class LocalDateTest {\n\n    @DisplayName(\"LocalDate를 생성한다.\")\n    @Test\n    void creat() {\n        LocalDate localDate = LocalDate.of(2022, 07, 03);\n\n        assertThat(localDate).isEqualTo(\"2022-07-03\");\n    }\n\n    @DisplayName(\"현재 시간을 구한다.\")\n    @Test\n    void now() {\n        LocalDate now = LocalDate.now();\n\n        assertThat(now).isNotNull();\n    }\n\n    @DisplayName(\"일을 더한다.\")\n    @Test\n    void plusDays() {\n        LocalDate localDate = LocalDate.of(2022, 07, 03);\n        LocalDate plusLocalDate = localDate.plusDays(1);\n\n        assertThat(plusLocalDate).isEqualTo(\"2022-07-04\");\n    }\n\n    @DisplayName(\"주를 더한다.\")\n    @Test\n    void plusWeeks() {\n        LocalDate localDate = LocalDate.of(2022, 07, 03);\n        LocalDate plusLocalDate = localDate.plusWeeks(5);\n\n        assertThat(plusLocalDate).isEqualTo(\"2022-08-07\");\n    }\n\n    @DisplayName(\"월을 더한다.\")\n    @Test\n    void plusMonths() {\n        LocalDate localDate = LocalDate.of(2022, 07, 03);\n        LocalDate plusLocalDate = localDate.plusMonths(7);\n\n        assertThat(plusLocalDate).isEqualTo(\"2023-02-03\");\n    }\n    \n    @DisplayName(\"연을 더한다.\")\n    @Test\n    void plusYears() {\n        LocalDate localDate = LocalDate.of(2022, 07, 03);\n        LocalDate plusLocalDate = localDate.plusYears(5);\n\n        assertThat(plusLocalDate).isEqualTo(\"2027-07-03\");\n    }\n\n    @DisplayName(\"두 날짜를 비교하여 과거를 판단한다.\")\n    @Test\n    void isBefore() {\n        LocalDate first = LocalDate.of(2022, 07, 03);\n        LocalDate second = LocalDate.of(2023, 07, 03);\n\n        boolean result = first.isBefore(second);\n\n        assertThat(result).isTrue();\n    }\n\n    @DisplayName(\"두 날짜를 비교하여 미래를 판단한다.\")\n    @Test\n    void isAfter() {\n        LocalDate first = LocalDate.of(2022, 07, 03);\n        LocalDate second = LocalDate.of(2023, 07, 03);\n\n        boolean result = second.isAfter(first);\n\n        assertThat(result).isTrue();\n    }\n\n    @DisplayName(\"동일한 날짜의 동등성을 판단한다.\")\n    @Test\n    void equals() {\n        LocalDate first = LocalDate.of(2022, 07, 03);\n        LocalDate second = LocalDate.of(2022, 07, 03);\n\n        boolean result = first.equals(second);\n\n        assertThat(result).isTrue();\n    }\n}\n```\n\n주로 year, month, day에 대한 메서드가 존재한다. 값 객체이기 때문에 내부의 값들이 동일하면 모두 동일한 객체로 판단한다. 또한 두 날짜를 비교하여 과거와 미래에 대한 판단도 진행할 수 있다.\n\n### LocalTime\n\n::: tip 공식 문서 중 일부\n\nA time without a time-zone in the ISO-8601 calendar system, such as 10:15:30.\nLocalTime is an immutable date-time object that represents a time, often viewed as hour-minute-second. Time is represented to nanosecond precision. For example, the value \"13:45.30.123456789\" can be stored in a LocalTime.\n\n**ISO-8601 달력 시스템에서 \"10:15:30\"과 같이 표준 시간대가 없는 시간이다. LocalTime은 시간을 나타내는 불변의 날짜-시간 객체이다. 종종 hour-minute-second로 표시된다. 시간은 나노초 정밀도로 표현된다. 예를들면 \"13:45.30.123456789\"과 같이 지정할 수 있다.**\n\nThis class does not store or represent a date or time-zone. Instead, it is a description of the local time as seen on a wall clock. It cannot represent an instant on the time-line without additional information such as an offset or time-zone.\n\n**이 클래스는 날짜 또는 표준시를 저장하거나 나타내지 않는다. 대신, 벽시계에 보이는 현지 시간에 대한 설명이다. offset 또는 표준시와 같은 추가 정보 없이 타임라인의 순간을 나타낼 수 없다.**\n\nThe ISO-8601 calendar system is the modern civil calendar system used today in most of the world. This API assumes that all calendar systems use the same representation, this class, for time-of-day.\n\n**ISO-8601 달력 체계는 오늘날 대부분의 세계에서 사용되는 현대 민간 달력 체계이다. 이 API는 모든 캘린더 시스템이 동일한 표현을 사용한다고 가정한다.**\n\nThis is a value-based class; use of identity-sensitive operations (including reference equality (==), identity hash code, or synchronization) on instances of LocalTime may have unpredictable results and should be avoided. The equals method should be used for comparisons.\n\n**이것은 값 기반의 클래스이다. (==), 해시 코드 및 동기화와 같은 작업을 할 때 예측할 수 없는 결과가 발생할 수 있으므로 피해야 한다. 비교를 위해서는 동등 방법을 활용해야 한다.**\n\n:::\n\n아래는 간단히 `LocalTime`에 존재하는 기능들을 테스트 한 것이다.\n\n```java\npublic class LocalTimeTest {\n\n    @DisplayName(\"LocalTime을 생성한다.\")\n    @Test\n    void create() {\n        LocalTime localTime = LocalTime.of(18, 30, 15);\n        assertThat(localTime).isEqualTo(\"18:30:15\");\n\n        LocalTime secondWithoutLocalTime = LocalTime.of(18, 30);\n        assertThat(secondWithoutLocalTime).isEqualTo(\"18:30\");\n    }\n\n    @DisplayName(\"현재 시간을 구한다.\")\n    @Test\n    void now() {\n        LocalTime now = LocalTime.now();\n\n        assertThat(now).isNotNull();\n    }\n\n    @DisplayName(\"시간을 더한다.\")\n    @Test\n    void plusHours() {\n        LocalTime localTime = LocalTime.of(18, 30, 15);\n\n        LocalTime plusLocalTime = localTime.plusHours(3);\n\n        assertThat(plusLocalTime).isEqualTo(\"21:30:15\");\n    }\n\n    @DisplayName(\"분을 더한다.\")\n    @Test\n    void plusMinutes() {\n        LocalTime localTime = LocalTime.of(18, 30, 15);\n\n        LocalTime plusLocalTime = localTime.plusMinutes(40);\n\n        assertThat(plusLocalTime).isEqualTo(\"19:10:15\");\n    }\n\n    @DisplayName(\"초를 더한다.\")\n    @Test\n    void plusSeconds() {\n        LocalTime localTime = LocalTime.of(18, 30, 15);\n\n        LocalTime plusLocalTime = localTime.plusSeconds(15);\n\n        assertThat(plusLocalTime).isEqualTo(\"18:30:30\");\n    }\n\n    @DisplayName(\"두 시간을 비교하여 과거를 판단한다.\")\n    @Test\n    void isBefore() {\n        LocalTime first = LocalTime.of(18, 30, 15);\n        LocalTime second = LocalTime.of(20, 30, 15);\n\n        boolean result = first.isBefore(second);\n\n        assertThat(result).isTrue();\n    }\n\n    @DisplayName(\"두 시간을 비교하여 미래를 판단한다.\")\n    @Test\n    void isAfter() {\n        LocalTime first = LocalTime.of(18, 30, 15);\n        LocalTime second = LocalTime.of(20, 30, 15);\n\n        boolean result = second.isAfter(first);\n\n        assertThat(result).isTrue();\n    }\n\n    @DisplayName(\"동일한 시간의 동등성을 판단한다.\")\n    @Test\n    void equals() {\n        LocalTime first = LocalTime.of(18, 30, 15);\n        LocalTime second = LocalTime.of(18, 30, 15);\n\n        boolean result = first.equals(second);\n\n        assertThat(result).isTrue();\n    }\n}\n```\n\n대부분 `LocalDate`와 유사하지만 시분초 조작에 초점을 두고 있다. 주의해야 할 점은 `LocalTime`의 초와 나노초는 항상 생략이 가능하다. 초를 생략할 경우 `HH:mm`으로 표기된다.\n\n### LocalDateTime\n\n::: tip 공식 문서 중 일부\n\nA date-time without a time-zone in the ISO-8601 calendar system, such as 2007-12-03T10:15:30. LocalDateTime is an immutable date-time object that represents a date-time, often viewed as year-month-day-hour-minute-second. Other date and time fields, such as day-of-year, day-of-week and week-of-year, can also be accessed. Time is represented to nanosecond precision. For example, the value \"2nd October 2007 at 13:45.30.123456789\" can be stored in a LocalDateTime.\n\n**ISO-8601 캘린더 시스템에 \"2007-12-03T 10:15:30\"과 같이 표준 시간대가 없는 날짜이다. LocalDateTime은 날짜/시간을 나타내는 불변의 날짜-시간 객체로 종종 년-월-시-분-초로 표시된다. 시간은 나노초 정밀도로 표현된다. 예를 들면 \"2007년 10월 2일 13:45:30.123456789\" 값은 LocalDateTime에 저장할 수 있다.**\n\nThis class does not store or represent a time-zone. Instead, it is a description of the date, as used for birthdays, combined with the local time as seen on a wall clock. It cannot represent an instant on the time-line without additional information such as an offset or time-zone.\n\n**이 클래스는 표준시를 저장하거나 나타내지 않는다. 대신, 이것은 생일날 사용되는 날짜를 벽시계에 보이는 현지 시간과 결합한 것이다. offset 또는 표준시와 같은 추가 정보 없이 타임라인의 순간을 나타낼 수 없다.**\n\nThe ISO-8601 calendar system is the modern civil calendar system used today in most of the world. It is equivalent to the proleptic Gregorian calendar system, in which today's rules for leap years are applied for all time. For most applications written today, the ISO-8601 rules are entirely suitable. However, any application that makes use of historical dates, and requires them to be accurate will find the ISO-8601 approach unsuitable.\n\n**ISO-8601 달력 체계는 오늘날 대부분의 세계에서 사용되는 현대 민간 달력 체계이다. 이것은 오늘날 윤년에 대한 규칙이 모든 시간에 적용되는 프로프랙틱 그레고리력 체계와 같다. 오늘날 작성된 대부분의 응용 프로그램에는 ISO-8601 규칙이 전적으로 적합하다. 그러나 과거 날짜를 사용하고 정확한 날짜를 요구하는 모든 응용 프로그램은 ISO-8601 접근법이 적합하지 않다는 것을 알게 될 것이다.**\n\nThis is a value-based class; use of identity-sensitive operations (including reference equality (==), identity hash code, or synchronization) on instances of LocalDateTime may have unpredictable results and should be avoided. The equals method should be used for comparisons.\n\n**이것은 값 기반의 클래스이다. (==), 해시 코드 및 동기화와 같은 작업을 할 때 예측할 수 없는 결과가 발생할 수 있으므로 피해야 한다. 비교를 위해서는 동등 방법을 활용해야 한다.**\n\n:::\n\n아래는 간단히 `LocalDateTime`에 존재하는 기능들을 테스트 한 것이다.\n\n```java\npublic class LocalDateTimeTest {\n\n    @DisplayName(\"LocalDateTime을 생성한다.\")\n    @Test\n    void create() {\n        LocalDateTime localDateTime = LocalDateTime.of(2022, 07, 03, 18, 30);\n\n        assertThat(localDateTime).isEqualTo(\"2022-07-03T18:30\");\n    }\n\n    @DisplayName(\"LocalDate와 LocalTime을 활용하여 LocalDateTime을 생성한다.\")\n    @Test\n    void localDateWithLocalTime() {\n        LocalDate localDate = LocalDate.of(2022, 07, 03);\n        LocalTime localTime = LocalTime.of(18, 30);\n\n        LocalDateTime localDateTime = LocalDateTime.of(localDate, localTime);\n\n        assertThat(localDateTime).isEqualTo(\"2022-07-03T18:30\");\n    }\n\n    @DisplayName(\"LocalDateTime을 활용하여 LocalDate와 LocalTime을 구한다.\")\n    @Test\n    void getLocalDateAndGetLocalTime() {\n        LocalDate localDate = LocalDate.of(2022, 07, 03);\n        LocalTime localTime = LocalTime.of(18, 30);\n        LocalDateTime localDateTime = LocalDateTime.of(localDate, localTime);\n\n        assertThat(localDateTime.toLocalDate()).isEqualTo(localDate);\n        assertThat(localDateTime.toLocalTime()).isEqualTo(localTime);\n    }\n}\n```\n\n날짜 및 시간을 더하고 비교하는 것은 앞서 작성한 `LocalDate`, `LocalTime`과 유사하다. 추가로 존재하는 기능은 `LocalDate`와 `LocalTime`을 활용하여 `LocalDateTime`을 손쉽게 만들 수 있고, `LocalDateTime`으로 `LocalDate`와 `LocalTime`을 손쉽게 변환할 수 있다.\n\n## 정리\n\n프로젝트 도입에 앞서 간단히 LocalDate, LocalTime, LocalDateTime의 사용법에 대해 알아보았다. Java에서 날짜 조작에 대한 대부분의 편리한 기능들을 제공하고 있기 때문에 단순히 문자열로 처리하는 것 보다 매우 효율적으로 다룰 수 있다. 또한 JDK 8 이전에 제공된 클래스들은 많은 문제들을 가지고 있었다. JDK 8 이후 등장한 클래스들은 이러한 문제들을 적절히 해결하여 제공되기 때문에 다양한 이점들을 잘 활용하여 사용하면 좋을 것 이라 판단한다.\n\n## References.\n\n[Java의 날짜와 시간 API](https://d2.naver.com/helloworld/645609)<br>\n[Class LocalDate](https://docs.oracle.com/javase/8/docs/api/java/time/LocalDate.html)<br>\n[Class LocalTime](https://docs.oracle.com/javase/8/docs/api/java/time/LocalTime.html)<br>\n[Class LocalDateTime](https://docs.oracle.com/javase/8/docs/api/java/time/LocalDateTime.html)<br>\n[ISO 8601](https://ko.wikipedia.org/wiki/ISO_8601)\n"},{"excerpt":"개요 란 데이터를 실시간으로 처리하는 것이 아니라 일괄적으로 모아 하는 것을 의미한다. 의  메서드와 를 비교하여 배치로 진행한 것과 일반적으로 처리한 것에 어떠한 차이가 있는지 알아보려 한다. 프로젝트 세팅 github repository 바로가기 우선 Spirng 환경에서 jdbc와 h2 DB를 활용하기 위해 아래와 같이 에 의존성을 추가하였다. 단순…","fields":{"slug":"/spring-jdbc-batch/"},"frontmatter":{"date":"May 24, 2022","title":"Spring JDBC로 batch 활용하기","tags":["우아한테크코스","JDBC","spring-jdbc","batch"]},"rawMarkdownBody":"\n![](https://user-images.githubusercontent.com/59357153/152970395-a31c8134-fc89-449f-b4dc-441e03df929c.png)\n\n## 개요\n\n`batch`란 데이터를 실시간으로 처리하는 것이 아니라 일괄적으로 모아 `한번에 처리`하는 것을 의미한다. `JdbcTemplate`의 `update` 메서드와 `batchUpdate`를 비교하여 배치로 진행한 것과 일반적으로 처리한 것에 어떠한 차이가 있는지 알아보려 한다.\n\n## 프로젝트 세팅\n\n[github repository 바로가기](https://github.com/hyeonic/blog-code/tree/main/spring-jdbc-batch)\n\n우선 Spirng 환경에서 jdbc와 h2 DB를 활용하기 위해 아래와 같이 `build.gradle`에 의존성을 추가하였다.\n\n```groovy\nplugins {\n    id 'org.springframework.boot' version '2.7.0'\n    id 'io.spring.dependency-management' version '1.0.11.RELEASE'\n    id 'java'\n}\n\ngroup = 'me.hyeonic'\nversion = '0.0.1-SNAPSHOT'\nsourceCompatibility = '11'\n\nrepositories {\n    mavenCentral()\n}\n\ndependencies {\n    implementation 'org.springframework.boot:spring-boot-starter-jdbc'\n\n    runtimeOnly 'com.h2database:h2'\n\n    testImplementation 'org.springframework.boot:spring-boot-starter-test'\n}\n\ntasks.named('test') {\n    useJUnitPlatform()\n}\n```\n\n단순한 예제를 작성하기 위해 domain 패키지 하위에 지하철역을 나타내는 `Station` 객체를 추가한다.\n\n```java\npublic class Station {\n\n    private final Long id;\n    private final String name;\n\n    public Station(Long id, String name) {\n        this.id = id;\n        this.name = name;\n    }\n\n    public Station(String name) {\n        this(null, name);\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public String getName() {\n        return name;\n    }\n}\n```\n\n## JdbcTemplate의 update 메서드\n\n보통 `JdbcTemplate`의 `update`의 메서드를 활용하여 데이터를 `insert`하기 위해 아래와 같이 작성할 수 있다.\n\n```java\n@Repository\npublic class JdbcTemplateStationDao {\n\n    private final JdbcTemplate jdbcTemplate;\n\n    public JdbcTemplateStationDao(JdbcTemplate jdbcTemplate) {\n        this.jdbcTemplate = jdbcTemplate;\n    }\n\n    public void save(Station station) {\n        String sql = \"insert into STATION (name) values (?)\";\n        jdbcTemplate.update(sql, station.getName());\n    }\n}\n```\n\n여러번의 `insert`를 테스트하기 위해 아래와 같이 테스트 코드를 작성한 뒤 실행해보았다.\n\n```java\n@JdbcTest\nclass JdbcTemplateStationDaoTest {\n\n    private final JdbcTemplateStationDao jdbcTemplateStationDao;\n\n    @Autowired\n    public JdbcTemplateStationDaoTest(JdbcTemplate jdbcTemplate) {\n        this.jdbcTemplateStationDao = new JdbcTemplateStationDao(jdbcTemplate);\n    }\n\n    @DisplayName(\"batch 사용하지 않고 저장한다.\")\n    @Test\n    void batch_사용하지_않고_저장한다() {\n        long start = System.currentTimeMillis();\n\n        for (int i = 0; i < 10000; i++) {\n            String name = String.valueOf(i);\n            jdbcTemplateStationDao.save(new Station(name));\n        }\n\n        long end = System.currentTimeMillis();\n        System.out.println(\"수행시간: \" + (end - start) + \" ms\");\n    }\n}\n```\n\n```\n수행시간: 402 ms\n```\n\n여러번의 `insert`를 진행할 때 아래와 같은 형태로 쿼리가 요청될 것이다.\n\n```sql\ninsert into STATION (name) values (?)\ninsert into STATION (name) values (?)\ninsert into STATION (name) values (?)\ninsert into STATION (name) values (?)\ninsert into STATION (name) values (?)\ninsert into STATION (name) values (?)\ninsert into STATION (name) values (?)\n...\n```\n\n## JdbcTemplate의 batchUpdate 메서드\n\n`JdbcTemplate` `batchUpdate`를 활용하면 아래와 같이 일괄적으로 한 번에 처리가 가능하다.\n\n```sql\ninsert into STATION (name) \nvalues (?),\n       (?),\n       (?),\n       (?),\n       (?),\n       (?),\n       ...\n```\n\n이것을 달성하기 위해서는 아래와 같이 코드를 작성해야 한다.\n\n```java\n@Repository\npublic class JdbcTemplateStationDao {\n\n    private final JdbcTemplate jdbcTemplate;\n\n    public JdbcTemplateStationDao(JdbcTemplate jdbcTemplate) {\n        this.jdbcTemplate = jdbcTemplate;\n    }\n\n    public void saveAll(List<Station> stations) {\n        String sql = \"insert into STATION (name) values (?)\";\n\n        jdbcTemplate.batchUpdate(sql, new BatchPreparedStatementSetter() {\n            @Override\n            public void setValues(PreparedStatement ps, int i) throws SQLException {\n                Station station = stations.get(i);\n                ps.setString(1, station.getName());\n            }\n\n            @Override\n            public int getBatchSize() {\n                return stations.size();\n            }\n        });\n    }\n}\n```\n\n`batchUpdate`의 첫 번째 매개변수로 배치 처리하기 위한 쿼리문이 들어가고 두 번째 매개 변수에는 `BatchPreparedStatementSetter`의 구현체가 들어간다.\n\n * `setValues`: 준비된 쿼리의 매개 변수 값을 설정할 수 있다. `getBatchSize`에서 명시한 횟수 만큼 호출한다.\n * `getBatchSize` 현재 배치의 크기를 제공한다.\n\n이제 배치를 활용하여 앞서 진행한 테스트와 동일한 데이터를 기반으로 테스트를 진행한다.\n\n```java\n@JdbcTest\nclass JdbcTemplateStationDaoTest {\n\n    private final JdbcTemplateStationDao jdbcTemplateStationDao;\n\n    @Autowired\n    public JdbcTemplateStationDaoTest(JdbcTemplate jdbcTemplate) {\n        this.jdbcTemplateStationDao = new JdbcTemplateStationDao(jdbcTemplate);\n    }\n\n    @DisplayName(\"batch 사용하고 저장한다.\")\n    @Test\n    void batch_사용하여_저장한다() {\n        List<Station> stations = IntStream.range(0, 10000)\n                .mapToObj(String::valueOf)\n                .map(Station::new)\n                .collect(toList());\n\n        jdbcTemplateStationDao.saveAll(stations);\n    }\n}\n```\n\n위 테스트의 수행 시간은 아래와 같다.\n\n```\n수행시간: 221 ms\n```\n\n정리하면 배치를 이용한 insert가 일반적으로 빠른 것을 확인 할 수 있다.\n\n## NamedParameterJdbcTemplate을 활용한 batch\n\n`NamedParameterJdbcTemplate`을 활용한 배치 처리도 가능하다.\n\n```java\n@Repository\npublic class NamedParameterJdbcTemplateStationDao {\n\n    private final NamedParameterJdbcTemplate namedParameterJdbcTemplate;\n\n    public NamedParameterJdbcTemplateStationDao(JdbcTemplate jdbcTemplate) {\n        this.namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(jdbcTemplate);\n    }\n\n    public void save(Station station) {\n        String sql = \"insert into STATION (name) values (:name)\";\n        SqlParameterSource params = new MapSqlParameterSource(\"name\", station.getName());\n        namedParameterJdbcTemplate.update(sql, params);\n    }\n\n    public void saveAll(List<Station> stations) {\n        String sql = \"insert into STATION (name) values (:name)\";\n        SqlParameterSource[] batch = generateParameters(stations);\n        namedParameterJdbcTemplate.batchUpdate(sql, batch);\n    }\n\n    private SqlParameterSource[] generateParameters(List<Station> stations) {\n        return stations.stream()\n                .map(this::generateParameter)\n                .toArray(SqlParameterSource[]::new);\n    }\n\n    private SqlParameterSource generateParameter(Station station) {\n        return new MapSqlParameterSource(\"name\", station.getName());\n    }\n}\n```\n\n대부분 사용법은 유사하지만 `NamedParameterJdbcTemplate`의 `batchUpdate`의 두번째 매개 변수로 추가적인 인터페이스를 구현하지 않고 단순히 `SqlParameterSource[]`가 들어간다. \n\n또한 `SqlParameterSourceUtils`를 활용하면 리스트를 활용하여 간편하게 `SqlParameterSource[]`을 만들 수 있다.\n\n```java\n@Repository\npublic class NamedParameterJdbcTemplateStationDao {\n    ...\n    public void saveAll(List<Station> stations) {\n        String sql = \"insert into STATION (name) values (:name)\";\n        namedParameterJdbcTemplate.batchUpdate(sql, SqlParameterSourceUtils.createBatch(stations));\n    }\n}\n```\n\n이 또한 테스트를 진행해보면 아래와 같이 유의미한 차이를 확인할 수 있었다.\n\n```java\n@JdbcTest\nclass NamedParameterJdbcTemplateStationDaoTest {\n\n    private final NamedParameterJdbcTemplateStationDao namedParameterJdbcTemplateStationDao;\n\n    @Autowired\n    public NamedParameterJdbcTemplateStationDaoTest(JdbcTemplate jdbcTemplate) {\n        this.namedParameterJdbcTemplateStationDao = new NamedParameterJdbcTemplateStationDao(jdbcTemplate);\n    }\n\n    @DisplayName(\"batch 사용하지 않고 저장한다.\")\n    @Test\n    void batch_사용하지_않고_저장한다() {\n        long start = System.currentTimeMillis();\n\n        for (int i = 0; i < 10000; i++) {\n            String name = String.valueOf(i);\n            namedParameterJdbcTemplateStationDao.save(new Station(name));\n        }\n\n        long end = System.currentTimeMillis();\n        System.out.println(\"수행시간: \" + (end - start) + \" ms\");\n    }\n\n    @DisplayName(\"batch 사용하고 저장한다.\")\n    @Test\n    void batch_사용하여_저장한다() {\n        long start = System.currentTimeMillis();\n\n        List<Station> stations = IntStream.range(0, 10000)\n                .mapToObj(String::valueOf)\n                .map(Station::new)\n                .collect(toList());\n\n        namedParameterJdbcTemplateStationDao.saveAll(stations);\n\n        long end = System.currentTimeMillis();\n        System.out.println(\"수행시간: \" + (end - start) + \" ms\");\n    }\n}\n```\n\n```\n수행시간: 531 ms\n수행시간: 236 ms\n```\n\n## References.\n\n[3.5. JDBC Batch Operations](https://docs.spring.io/spring-framework/docs/current/reference/html/data-access.html#jdbc-advanced-jdbc)\n"},{"excerpt":"enum 사계절을 뜻하는 봄, 여름, 가을, 겨울과 같이 한정된 값만을 가진 데이터 타입을이라고 한다. 이처럼 프로그래밍에서 을 나타내기 위해 사용된다.   Java 1.5 부터 enum을 으로 표시되었다. 특히 Java에서는 C/C++과 다르게 변수, 메소드, 생성자를 추가할 수 있다. 기존에 인터페이스나 클래스 내에서 상수를 선언하여 사용하였는데 상수…","fields":{"slug":"/enum/"},"frontmatter":{"date":"May 15, 2022","title":"enum","tags":["enum"]},"rawMarkdownBody":"\n## enum\n\n사계절을 뜻하는 봄, 여름, 가을, 겨울과 같이 한정된 값만을 가진 데이터 타입을` 열거 타입 (Enumuration type)`이라고 한다. 이처럼 프로그래밍에서 `상수의 그룹`을 나타내기 위해 사용된다. \n\n Java 1.5 부터 enum을 `enum 데이터 타입`으로 표시되었다. 특히 Java에서는 C/C++과 다르게 변수, 메소드, 생성자를 추가할 수 있다. 기존에 인터페이스나 클래스 내에서 상수를 선언하여 사용하였는데 상수를 관리하는데 있어서 나오는 단점들과 타입의 안정성, IDE의 지원을 받을 수 있도록 보완하여 나온 것이 Enum이다.\n\n## enum의 등장 배경\n\nenum 이전에 상수를 사용하던 때에는 몇 가지 문제점을 가지고 있었다.\n * 상수에 부여된 리터럴은 상수와 관련이 없다.\n * 이름의 충돌이 발생할 수 있다.\n\n```java\npublic class Season {\n\n    public static final int SPRING = 1;\n    public static final int SUMMBER = 2;\n    public static final int FALL = 3;\n    public static final int WINTER = 4;\n\n    public static void main(String[] args) {\n        int season = SPRING;\n\n        switch (season) {\n            case SPRING:\n                System.out.println(\"봄\");\n                break;\n            case SUMMBER:\n                System.out.println(\"여름\");\n                break;\n            case FALL:\n                System.out.println(\"가을\");\n                break;\n            case WINTER:\n                System.out.println(\"겨울\");\n                break;\n        }\n    }\n}    \n```\n\n```bash\n봄\n```\n\n첫 번째 문제를 확인하기 위해 간단하게 봄, 여름, 가을, 겨울을 1, 2, 3, 4라는 리터럴로 구분하여 부여하였다. 해당 리터럴은 단순히 상수를 구분하는 용도이고 논리적으로는 아무 의미가 없다. 즉 season 변수에 1이라는 값을 넣어도 SPRING을 넣었을 때랑 값을 결과가 나올 수 있다. 결국 `상수`와 `상수에 부여된 리터럴`들은 연관성이 없다는 것을 알 수 있었다.\n\n```java\npublic class Season {\n\n    public static final int SPRING = 1;\n    public static final int SUMMBER = 2;\n    public static final int FALL = 3;\n    public static final int WINTER = 4;\n\n    public static void main(String[] args) {\n        int season = 1;\n\n        switch (season) {\n            case SPRING:\n                System.out.println(\"봄\");\n                break;\n            case SUMMBER:\n                System.out.println(\"여름\");\n                break;\n            case FALL:\n                System.out.println(\"가을\");\n                break;\n            case WINTER:\n                System.out.println(\"겨울\");\n                break;\n        }\n    }\n}\n```\n\n```bash\n봄\n```\n\n또한 다른 클래스의 이름이 같은 상수도 비교해보았다.\n\n```java\npublic class Season {\n\n    // season\n    public static final int SPRING = 1;\n    public static final int SUMMBER = 2;\n    public static final int FALL = 3;\n    public static final int WINTER = 4;\n}\n```\n\n```java\npublic class Framework {\n\n    // framework\n    public static final int SPRING = 1;\n    public static final int DJANGO = 2;\n    public static final int RUBY_ON_RAILS = 3;\n    public static final int VUE_JS = 4;\n}\n```\n\n```java\npublic class Exam02 {\n    public static void main(String[] args) {\n        System.out.println(Season.SPRING == Framework.SPRING); // true\n    }\n}\n```\n\n서로 다른 SPRING을 의미하고 있지만, 1이라는 리터럴을 비교하기 때문에 true을 출력한다. \n\n두번째 문제는 `이름의 충돌`이 발생하는 것이다. Season의 SPRING과 Framework의 SPRING을 비교해보았다. 같은 클래스에 상수를 선언하면 Seanson의 SPRING과 Framework의 SPRING이 서로 같은 변수명으로 충돌하게 된다. 그렇기 때문에 추가적으로 앞에 구분하는 문자를 붙여줘야 한다.\n\n * SEANSON_SPRING\n * FRAMEWOKR_SPRING\n\nEnum은 위처럼 상수를 클래스로 정의하여 관리할 때 얻을 수 있는 이점을 모두 모아 간단하게 선언하여 사용할 수 있도록 하기 위해서 만들어졌다.\n\n## enum 정의\n\n가장 기본적 enum 선언이다.\n\n```java\npublic enum  Phone {\n\n    GALAXY_S21,\n    GALAXY_S21_PLUS,\n    GALAXY_S21_ULTRA,\n    GALAXY_Z_FLIP,\n    GALAXY_Z_FOLD2\n}\n```\n\n또한 생성자 및 메서드를 추가할 수 있다.\n\n```java\npublic enum Phone {\n    GALAXY_S21(999_900, \"SM-G991NZIEKOO\"),\n    GALAXY_S21_PLUS(1_119_900, \"SM-G996NZVEKOO\"),\n    GALAXY_S21_ULTRA(1_452_000, \"SM-G998NZKEKOO\"),\n    GALAXY_Z_FLIP(1_650_000, \"SM-F707NZNAKOO\"),\n    GALAXY_Z_FOLD2(2_398_000, \"SM-F916NZKAKOO\");\n\n    private final int price;\n    private final String modelName;\n\n    Phone(int price, String modelName) {\n        this.price = price;\n        this.modelName = modelName;\n    }\n\n    public int getPrice() {\n        return this.price;\n    }\n\n    public String getModelName() {\n        return this.modelName;\n    }\n}\n```\n\n> 생성자가 존재하지만 Default 생성자는 private로 되어 있다. public으로 변경하면 컴파일 에러가 발생한다. \n\n즉 다른 클래스나 인터페이스에서 상수 선언(static final)이 클래스 로드 시점에서 생성되는 것처럼 Enum 또한 생성자가 존재하지만 클래스가 로드되는 시점에 생성되기 때문에 임의로 생성하여 사용할 수 없다. Enum 클래스에 선언된 상수들은 클래스 로드 시점에서 모두 생성되고, signleton 형태로 애플리케이션 전체에서 사용할 수 있다.\n\n signleton으로 사용 가능하기 때문에 값을 유지하는 필드가 들어 있는 것은 매우 위험하기 때문에 조심해야 한다. \n\n```java\npublic enum Phone {\n    GALAXY_S21(999_900, \"SM-G991NZIEKOO\"),\n    GALAXY_S21_PLUS(1_119_900, \"SM-G996NZVEKOO\"),\n    GALAXY_S21_ULTRA(1_452_000, \"SM-G998NZKEKOO\"),\n    GALAXY_Z_FLIP(1_650_000, \"SM-F707NZNAKOO\"),\n    GALAXY_Z_FOLD2(2_398_000, \"SM-F916NZKAKOO\");\n\n    private final int price;\n    private final String modelName;\n    private int count;\n\n    Phone(int price, String modelName) {\n        this.price = price;\n        this.modelName = modelName;\n    }\n\n    public void addCount(int count) {\n        this.count += count;\n    }\n}\n```\n\ncount 변수는 멀티쓰레드 환경에서 공유되고 있기 때문에 값을 유지하는 인스턴스 변수의 사용을 막거나 `thread safe`하게 유지해야 한다.\n\n또한 상속을 지원하지 않는다. 모든 enum은 내부적으로 `java.lang.Enum` 클래스에 의해 상속된다. Java에서는 다중 상속을 지원하지 않기 때문에 enum 클래스는 다른 클래스를 상속 받을 수 없다. 상속을 지원하지 않지만 다양한 `인터페이스들은 구현`할 수 있다.\n\n`바이트코드`를 살펴보면 `java.lang.Enum`을 `상속` 받을 것을 알 수 있다. 또한 각각 인스턴스들은 `public final static`으로 선언되어 있다. 각각 객체의 주소 값은 바뀌지 않기 때문에 \"==\" 비교가 가능해진다.\n\n```java\npublic final enum me/hyeonic/week11/Phone extends java/lang/Enum {\n\n  // compiled from: Phone.java\n\n  // access flags 0x4019\n  public final static enum Lme/hyeonic/week11/Phone; GALAXY_S21\n\n  // access flags 0x4019\n  public final static enum Lme/hyeonic/week11/Phone; GALAXY_S21_PLUS\n\n  // access flags 0x4019\n  public final static enum Lme/hyeonic/week11/Phone; GALAXY_S21_ULTRA\n\n  // access flags 0x4019\n  public final static enum Lme/hyeonic/week11/Phone; GALAXY_Z_FLIP\n\n  // access flags 0x4019\n  public final static enum Lme/hyeonic/week11/Phone; GALAXY_Z_FOLD2\n  \n  ...\n}\n```\n\n### enum 안에 인스턴스 생성 시점 \n\nenum 안에 선언한 인스턴스들의 생성 시점을 알아보기 위해 간단한 예시를 작성하였다. `enum Phone`이에 생성자와 간단한 생성 정보를 출력하는 출력문을 추가하였다.\n\n```java\npublic enum Phone {\n    GALAXY_S21(999_900, \"SM-G991NZIEKOO\"),\n    GALAXY_S21_PLUS(1_119_900, \"SM-G996NZVEKOO\"),\n    GALAXY_S21_ULTRA(1_452_000, \"SM-G998NZKEKOO\"),\n    GALAXY_Z_FLIP(1_650_000, \"SM-F707NZNAKOO\"),\n    GALAXY_Z_FOLD2(2_398_000, \"SM-F916NZKAKOO\");\n\n    private final int price;\n    private final String modelName;\n\n    Phone(int price, String modelName) {\n        System.out.println(this.name() + \" -> \" + price + \", \" + modelName);\n        this.name();\n        this.price = price;\n        this.modelName = modelName;\n    }\n\n    public int getPrice() {\n        return this.price;\n    }\n\n    public String getModelName() {\n        return this.modelName;\n    }\n\n    @Override\n    public String toString() {\n        return \"Phone{\" +\n                \"price=\" + price +\n                \", modelName='\" + modelName + '\\'' +\n                '}';\n    }\n}\n```\n\n다양한 상황을 출력한다.\n\n```java\npublic class Exam01 {       \n    public static void main(String[] args) {                                            \n        System.out.println(\"==================== main ====================\");           \n        System.out.println(\"================ enum 변수 선언 ================\");             \n        Phone phone;                                                                    \n        System.out.println(\"============== enum 변수에 값 할당 ==============\");              \n        phone = Phone.GALAXY_S21;                                                       \n        System.out.println(\"=============== enum 변수 값 사용 ===============\");             \n        System.out.println(phone.name() + \"의 가격은 \" + phone.getPrice() + \"이다.\");         \n        System.out.println(\"===================== end =====================\");          \n    }                                                                                   \n}        \n```\n\n```bash\n===================== main =====================\n================ enum 변수 선언 =================\n============== enum 변수에 값 할당 ==============\nGALAXY_S21 -> 999900, SM-G991NZIEKOO\nGALAXY_S21_PLUS -> 1119900, SM-G996NZVEKOO\nGALAXY_S21_ULTRA -> 1452000, SM-G998NZKEKOO\nGALAXY_Z_FLIP -> 1650000, SM-F707NZNAKOO\nGALAXY_Z_FOLD2 -> 2398000, SM-F916NZKAKOO\n=============== enum 변수 값 사용 ===============\nGALAXY_S21의 가격은 999900이다.\n====================== end =====================\n```\n\nenum 변수를 단순히 선언만 하면 내부의 상수들이 선언되지 않는다. `직접적으로 값을 할당`하거나 `사용할 때` 비로소 모든 값들이 생성되는 것을 알 수 있다.\n\n## enum이 제공하는 메서드 \n\n### values\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Phone[] phones = Phone.values();\n\n        for (Phone phone : phones) {\n            System.out.println(phone.ordinal() + \" \" + phone.name());\n            System.out.println(\"model name: \" + phone.getModelName() + \" price: \" + phone.getPrice());\n\n            System.out.println();\n        }\n    }\n}\n```\n\n```bash\n0 GALAXY_S21\nmodel name: SM-G991NZIEKOO price: 999900\n\n1 GALAXY_S21_PLUS\nmodel name: SM-G996NZVEKOO price: 1119900\n\n2 GALAXY_S21_ULTRA\nmodel name: SM-G998NZKEKOO price: 1452000\n\n3 GALAXY_Z_FLIP\nmodel name: SM-F707NZNAKOO price: 1650000\n\n4 GALAXY_Z_FOLD2\nmodel name: SM-F916NZKAKOO price: 2398000\n```\n\nEnum 클래스가 가지고 있는 상수 값을 `배열의 형태로 리턴`한다. String 형태의 name을 반환하는게 아니라 `enum phone이 가지고 있는 모든 상수의 인스턴스를 배열에 담아 반환`한다. 그렇기 때문에 상속 받은 Enum 클래스의 메소드 뿐만 아니라 Phone에 있는 get메소드 또한 사용이 가능하다.\n\n이러한 `values()`는 바이트코드를 살펴보면 컴파일 시점에 자동 생성한다.\n\n<p align=center>\n    <img src=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fq6XgM%2FbtqU93WOlFf%2FE57N7NIENtpciRrHNAe6KK%2Fimg.png\">\n</p>\n\n### valueOf\n\n`valueOf()` 메소드는 인자로 들어온 값과 일치하는 상수 인스턴스가 존재하면 해당 인스턴스를 반환한다. 단순히 문자열 반환이 아닌 인스턴스 자체를 반환한다.\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Phone galaxy21 = Phone.valueOf(\"GALAXY_S21\");\n\n        System.out.println(galaxy21.name());\n        System.out.println(galaxy21.ordinal());\n        System.out.println(galaxy21.getModelName());\n        System.out.println(galaxy21.getPrice());\n    }\n}\n```\n\n```bash\nGALAXY_S21\n0\nSM-G991NZIEKOO\n999900\n```\n\n존재하지 않는 상수인 경우 `IllegalArgumentException`을 던진다.\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Phone galaxy20 = Phone.valueOf(\"GALAXY_S20\");\n\n        System.out.println(galaxy20.name());\n        System.out.println(galaxy20.ordinal());\n        System.out.println(galaxy20.getModelName());\n        System.out.println(galaxy20.getPrice());\n    }\n}\n```\n\n```bash\nException in thread \"main\" java.lang.IllegalArgumentException: No enum constant me.hyeonic.week11.Phone.GALAXY_S20\n\tat java.base/java.lang.Enum.valueOf(Enum.java:240)\n\tat me.hyeonic.week11.Phone.valueOf(Phone.java:3)\n\tat me.hyeonic.week11.Main.main(Main.java:15)\n```\n\n## java.lang.Enum\n\n`java.lang.Enum` 클래스는 Java의  enum 타임의 기반이 되는 클래스이다. enum type은 내부적으로 모두 java.lang.Enum 클래스를 상속한다. 또한 Enum 클래스의 생성자는 유일한 생성자로, 개발자는 해당 생성자를 호출할 수 없다. \n\n`values()`와 `valueOf()`를 제외한 다른 메서드는 아래와 같다.\n\n### public final String name()\n열거형 선언에서 선언한 대로 `상수의 이름을 반환`한다. 대부분의 개발자는 `toString() 메소드` 사용을 추천한다. toString() 메소드를 오버라이딩 하여 사용하면 `사용자 친화적인 이름을 반환`할 수 있기 때문이다. name() 메소드는 릴리스마다 달라지지 않는 정확한 이름을 반환하기 때문에 `정확도가 중요한 특수한 상황`에서 사용한다.\n\n### public final int ordinal()\n\n열거형 상수의 `순서를 반환`한다. `선언된 위치를 기준으로 0부터 부여`된다. 개발자가 직접 사용하기 보다는, `EnumSet`과 `EnumMap`과 같은 정교한 `Enum 기반 데이터 구조`에서 사용할 수 있도록 설계되었다.\n\n> `ordinal()` 메소드를 기반으로 코드를 작성하는 것은 위험하다. 후에 enum에 상수 인스턴스가 추가되면, 해당 index가 유지되는 것을 보장하지 않는다.\n\n## References\n\n[Enum class](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Enum.html)<br>\n"},{"excerpt":"개요 웹 체스 미션을 진행하던 중 Spring Jdbc를 도입하기 위해 이전에 연결된 JDBC에 대한 의존성을 제거한 뒤 에서 제공하는 을 활용하여 SQL 쿼리를 사용하였다. 하지만 나는 에 대한  등록을 진행하지 않았다. 그렇다면 누가 자동으로 등록한 것일까?  JDBC (Java DataBase Connectivity) 우선 이전에 사용하던 JDBC에…","fields":{"slug":"/why-jdbc-template/"},"frontmatter":{"date":"April 28, 2022","title":"JdbcTemplate는 어디에?","tags":["우아한테크코스","JDBC","spring-jdbc"]},"rawMarkdownBody":"\n![](https://user-images.githubusercontent.com/59357153/152970395-a31c8134-fc89-449f-b4dc-441e03df929c.png)\n\n## 개요\n\n웹 체스 미션을 진행하던 중 Spring Jdbc를 도입하기 위해 이전에 연결된 JDBC에 대한 의존성을 제거한 뒤 `Spring-jdbc`에서 제공하는 `JdbcTemplate`을 활용하여 SQL 쿼리를 사용하였다. 하지만 나는 `JdbcTemplate`에 대한 `Bean` 등록을 진행하지 않았다. 그렇다면 누가 자동으로 등록한 것일까?\n\n![](https://user-images.githubusercontent.com/59357153/165691946-6761593a-9ea0-4a4e-aa45-72674eebc92f.png)\n\n## JDBC (Java DataBase Connectivity)\n\n우선 이전에 사용하던 JDBC에 대해 간단히 알아본다. JDBC는 Java와 데이터베이스를 연결하기 위한 Java 표준 인터페이스이다. 아래 그림과 같이 MySql, oracle 등 다양한 DB의 미들웨어의 드라이버를 제공하고 있다. 덕분에 어떤 DB에 연결되는지에 따라 드라이버를 선택하여 적용할 수 있다. 또한 어떤 DB의 드라이버인지 상관없이 일관적인 방식으로 사용할 수 있도록 도와준다.\n\n![](https://user-images.githubusercontent.com/59357153/165686797-ec8e6f35-dbd1-4f7e-a2d3-dedf2bb50482.png)\n\n일반적인 JDBC를 그대로 사용하게 되면 아래와 같은 흐름으로 사용하게 된다.\n\n* JDBC 드라이버를 로드\n* DB를 연결\n* DB의 데이터 조회 및 쓰기\n* DB 연결 종료\n\n덕분에 DB에 접근하여 SQL 쿼리를 실행하기 위해 복잡한 코드를 동반하게 된다.\n\n```java\npublic class JdbcPieceDao implements PieceDao {\n\n    private static final String URL = \"jdbc:mysql://localhost:3306/chess\";\n    private static final String USER = \"user\";\n    private static final String PASSWORD = \"password\";\n\n    @Override\n    public void save(PieceDto pieceDto) {\n        String sql = \"INSERT INTO piece (id, piece_type) VALUES (?, ?)\";\n\n        try (Connection connection = getConnection();\n             PreparedStatement statement = connection.prepareStatement(sql)) {\n\n            statement.setString(1, pieceDto.getId());\n            PieceType pieceType = pieceDto.getPieceType();\n            statement.setString(2, pieceType.getType());\n\n            statement.executeUpdate();\n        } catch (SQLException e) {\n            throw new IllegalArgumentException(\"기물의 위치는 중복될 수 없습니다.\");\n        }\n    }\n    ...\n        private Connection getConnection() {\n        Connection connection = null;\n        try {\n            connection = DriverManager.getConnection(URL, USER, PASSWORD);\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n        return connection;\n    }\n}\n```\n\n## Spring JDBC \n\n`Spring JDBC`는 Driver 및 DB 연결과 `Connection` 객체의 관리를 수행하는 `DataSource`를 설정을 통해 생성하며 위에서 사용한 것 처럼 JDBC API를 직접 사용했을 때 불편했던 것들을 쉽게 사용할 수 있도록 도와준다.\n\n정리하면 JDBC API의 모든 저수준 처리를 Spring Framework에 위임하기 때문에 위에서 작성한 반복되는 처리를 개발자가 직접 처리하지 않고 Database에 대한 작업을 수행할 수 있도록 도와준다.\n\n## Data Access with JDBC\n\nJBDC 데이터베이스 접근의 기초를 형성하기 위해 여러 접근 방식을 선택할 수 있다.\n\n* `JdbcTemplate`: 고전적이고 가장 인기 있는 Spring JDBC 방식이다. `lowest-level` 접근법과 다른 모든 것들은 `JdbcTemplate`를 사용한다.\n\n* `NamedParameterJdbcTemplate`: 기존 JDBC `?` 표시자 대신 `명명된 매개 변수를 제공`하기 위해 `JdbcTemplate을 랩핑`한다. 이러한 접근 방식은 SQL 문에 대한 매개 변수가 여러 개 일 때 더 나은 문서화와 사용 편의성을 제공한다.\n\n* `SimpleJdbcInsert`: 데이터베이스 메타데이터를 최적화하여 필요한 구성 양을 제한한다. 해당 방법을 사용하면 테이블 또는 프로시저의 이름만 제공하고 `column 이름과 일치하는 맵`을 제공해야 하므로 코딩이 매우 간소화된다. 하지만 이것은 데이터베이스가 적절한 메타데이터를 제공하는 경우에만 작동한다. 데이터베이스가 이 메타데이터를 제공하지 않는 경우 매개 변수의 명시적 구성을 제공해야 한다.\n\n## JdbcTemplate는 어디에?\n\n이제 JDBC와 Spring JDBC에 대한 간단한 개념 정리를 진행했다. 본론으로 넘어와 `JdbcTemplate`를 자동으로 등록한 곳을 찾아보려 한다.\n\nSpring Boot의 자동 구성은 애플리케이션에 적용할 수 있는 여러 구성 클래스로 작동한다. 이런 모든 구성은 Spring 4.0의 조건부 구성 지원 기능을 이용하여 `런타임 시점`에 구성을 사용할지 여부를 결정한다.\n\n아래는 `org.springframework.boot.autoconfigure.jdbc` 패키지에 위치한 `JdbcTemplateConfiguration` 클래스이다.\n\n```java\npackage org.springframework.boot.autoconfigure.jdbc;\n\n...\n\n@Configuration(proxyBeanMethods = false)\n@ConditionalOnMissingBean(JdbcOperations.class)\nclass JdbcTemplateConfiguration {\n\n\t@Bean\n\t@Primary\n\tJdbcTemplate jdbcTemplate(DataSource dataSource, JdbcProperties properties) {\n\t\tJdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);\n\t\tJdbcProperties.Template template = properties.getTemplate();\n\t\tjdbcTemplate.setFetchSize(template.getFetchSize());\n\t\tjdbcTemplate.setMaxRows(template.getMaxRows());\n\t\tif (template.getQueryTimeout() != null) {\n\t\t\tjdbcTemplate.setQueryTimeout((int) template.getQueryTimeout().getSeconds());\n\t\t}\n\t\treturn jdbcTemplate;\n\t}\n}\n```\n\n`jdbcTemplate(DataSource dataSource, JdbcProperties properties)` 메서드는 `@Bean` 애너테이션 덕분에 `JdbcTemplate Bean`을 구성해준다. 하지만 주목해야 할 것은 `@ConditionalOnMissingBean(JdbcOperations.class)` 부분이다.\n\n### @ConditionalOnMissingBean(JdbcOperations.class)\n\n`@ConditionalOnMissingBean`은 속성으로 전달된 `JdbcOperations` 타임의 `Bean`이 없을 때만 동작한다. `JdbcTemplate`은 바로 `JdbcOperations`의 구현체이다.\n\n```java\npublic class JdbcTemplate extends JdbcAccessor implements JdbcOperations {\n    ...\n}\n```\n\n만약 개발자가 명시적으로 `JdbcOperations` 타입의 Bean을 구성했다면 `@ConditionalOnMissingBean` 애너테이션의 조건에 만족하지 못하므로 해당 메서드는 사용되지 않는다. \n\n정리하면 나는 명시적으로 `JdbcTempalate`를 등록하지 않았다. 그렇기 때문에 `@ConditionalOnMissingBean` 애너테이션의 조건에 만족하여 `자동 구성에서 제공하는 JdbcTemplate를 Bean`으로 등록하여 사용하고 있는 것이다.\n\n관련 키워드를 검색하기 위해 구글링하던 중 `stackOverflow`에서 관련 된 글을 찾아볼 수 있었다.\n\n### Question\n\n[How does spring boot inject the instance of ApplicationContext and JdbcTemplate using @Autowired without @Component annotation and xml configuration?](https://stackoverflow.com/questions/61452371/how-does-spring-boot-inject-the-instance-of-applicationcontext-and-jdbctemplate)\n\n**Spring Boot에서 @Component 및 xml 구성 없이 @Autowired를 사용하여 JdbcTemplate 인스턴스를 주입하는 방법은 무엇인가?**\n\ni'm in a spring boot app building rest controller.i find that ApplicationContext and JdbcTemplate source code,these 2 classes do not have any annotation.But they can be correctly injected into constructor.i am not using any configuration file like 'applicationContext.xml'.When do these 2 classes get scanned by spring ioc container?\n\n**ApplicationContext 및 JdbcTemplate 소스 코드, 이 두 클래스에는 annotation이 없다. 그러나 constructor에 올바르게 삽입할 수 있다. 'applicationContext.xml'과 같은 구성 파일을 사용하지 않았다.이 두 클래스는 언제 spring ioc 컨테이너로 스캔되는가?**\n\n### Answer\n\nSpring Boot does a lot of auto configuration.\n\n**Sprign Boot는 많은 자동 구성을 수행한다.**\n\nI assume that you are using spring-data-jdbc or spring-data-jpa and there for the JdbcTemplate is auto configured.\n\n**spring-data-jdbc 또는 spring-data-jpa를 사용하고 있으며 JdbcTemplate에 대해 자동 구성되었다고 가정한다.**\n\nThe most interesting project is: spring-boot-autoconfigure where all the magic happens.\n\n**가장 흥미로운 프로젝트는 `spring-boot-autoconfigure`이다. 모든 마술이 일어나는 곳이다!**\n\nAnd there you will find `JdbcTemplateConfiguration.java`\n\n**또한 `JdbcTemplateConfiguration.java` 관련 설정을 찾아볼 수 있다.**\n\n## 정리\n\n정리하면 우린 `spring-boot-autoconfigure` 덕분에 명시적으로 JdbcTemplate을 Bean으로 등록하지 않아도 자동 설정되므로 사용가능하다.\n\n이러한 자동 구성 덕분에 우리는 편리하게 기능에만 집중할 수 있게 된다. 만약 추가적인 JdbcTempalate에 대한 설정이 필요하다면 명시적인 등록을 추가하여 Bean으로 작성하기만 하면 된다. \n\n## References.\n\n[Spring Data Access](https://docs.spring.io/spring-framework/docs/current/reference/html/data-access.html)<br>\n[Infra layer with Spring — Spring jdbc 개념과 예시 코드](https://tech.junhabaek.net/infra-layer-with-spring-spring-jdbc-%EA%B0%9C%EB%85%90%EA%B3%BC-%EC%98%88%EC%8B%9C-%EC%BD%94%EB%93%9C-1c3f4e3ccb63)<br>\n[Spring JDBC](https://velog.io/@koseungbin/Spring-JDBC)<br>\n[How does spring boot inject the instance of ApplicationContext and JdbcTemplate using @Autowired without @Component annotation and xml configuration?](https://stackoverflow.com/questions/61452371/how-does-spring-boot-inject-the-instance-of-applicationcontext-and-jdbctemplate)\n"},{"excerpt":"일급 컬렉션 이란 을 하며 그외 다른 인스턴스 변수가 없는 상태를 말한다. 이러한 Wrapping이 가져오는 은 아래와 같다. 로 사용이 가능하다. Collection의 할 수 있다. 해당 Collection에 대한 할 수 있다. 간단히 정리하면 이다. 간단한 예시를 들어보면 스터디 개설 및 운영을 위한 시스템 개발을 진행한다고 가정한다. 한 스터디에는 …","fields":{"slug":"/first-class-collection/"},"frontmatter":{"date":"April 15, 2022","title":"일급 컬렉션","tags":["java","일급 컬렉션"]},"rawMarkdownBody":"\n\n## 일급 컬렉션\n\n`일급 컬렉션(First Class Collection)`이란 `Collection`을 `Wrapping`하며 그외 다른 인스턴스 변수가 없는 상태를 말한다. 이러한 Wrapping이 가져오는 `이점`은 아래와 같다.\n\n 1. `비즈니스에 종속적인 자료구조`로 사용이 가능하다.\n 2. Collection의 `불변성을 보장하도록 구현`할 수 있다.\n 3. 해당 Collection에 대한 `행위 까지 한 곳에서 관리`할 수 있다.\n\n간단히 정리하면 `비즈니스에 맞는 이름을 가지는 Collection을 만드는 것`이다.\n\n간단한 예시를 들어보면 스터디 개설 및 운영을 위한 시스템 개발을 진행한다고 가정한다. 한 스터디에는 다수의 스터디원을 등록할 수 있다. \n\n스터디원을 나타내는 `Student`이다.\n\n```java\npublic class Student {\n    private String name;\n    private int age;\n    ...\n}\n```\n\n한 스터디에는 다수의 스터디원을 가질 수 있다. 간단히 표시하면 아래와 같이 단순히 `List`를 활용하여 표현할 수 있다.\n\n```java\npublic class Study {\n    private String name;\n    private List<Student> students;\n    ...\n}\n```\n\n일급 컬렉션은 이러한 `List<Student> students`를 Wrapping하여 구현한다. 앞서 언급한 것 처럼 인스턴스 변수는 students `오직 하나`이다.\n\n```java\npublic class Students {\n    private List<Student> students;\n\n    public Students(List<Student> students) {\n        this.students = students;\n    }\n}\n```\n\n일급 컬렉션으로 개선한 Study 이다.\n\n```java\npublic class Study {\n    private String name;\n    private Students students;\n    ...\n}\n```\n\n## 이점 살펴보기\n\n위에서 작성한 스터디 개설 및 운영 시스템 활용한다. 스터디 개설을 위해서는 아래와 같은 조건이 필요하다고 가정한다.\n\n * 스터디 개설을 위해서는 `적어도 5명`의 스터디원이 필요하다.\n\n```java\npublic class Students {\n    public static final int STUDENTS_MIN_SIZE = 5;\n    \n    private List<Student> students;\n\n    public Students(List<Student> students) {\n        validateSize(students);\n        this.students = students;\n    }\n\n    private void validateSize(List<Student> students) {\n        if (students.size() < STUDENS_MIN_SIZE) {\n            throw new IllegalArgumentException();\n        }\n    }\n}\n```\n\n스터디원의 수가 적절한지 `직접 검증`한다. 외부에 의존하여 검증을 진행하는 것이 아니라 상태와 행위를 일급 컬렉션 안에서 모두 진행할 수 있다.\n\n또한 `적어도 5명이 필요한 Student List`는 기존에 제공되는 자료구조가 아니다. 해당 비즈니스(스터디 개설 및 운영 시스템)에 `종속된 자료구조`로 `추가적인 요구사항`에 유연하게 대처할 수 있다.\n\n이제 Students에 대한 로직은 `자체적으로 처리`가 가능하다. Students는 오직 `스터디원에 대한 책임(검증 행위 등)`만 가질 수 있다.\n\n## References\n\n[일급 컬렉션 (First Class Collection)의 소개와 써야할 이유](https://jojoldu.tistory.com/412)<br>\n[일급 컬렉션을 사용하는 이유](https://tecoble.techcourse.co.kr/post/2020-05-08-First-Class-Collection/)"},{"excerpt":"불변 객체 란, 생성 후 그 상태를 바꿀 수 없는 객체이다. 불변을 만들기 위해서는 과 에서 다른 방식으로 적용해야 한다. 기본형 타입의 불변 기본형 타입의 경우 참조 값이 아닌 실제 값이 저장되기 때문에 쉽게 적용이 가능하다. 내부 상태를 변경할 방법을 제한하면 불변을 보장한다. 즉  생성을 제한하거나  키워드를 사용하면 된다. 참조형 타입의 불변 참조…","fields":{"slug":"/immutable-object/"},"frontmatter":{"date":"April 01, 2022","title":"불변 객체","tags":["java","불변 객체","immutable object"]},"rawMarkdownBody":"\n## 불변 객체\n\n`불변 객체(Immutable Object)`란, 생성 후 그 상태를 바꿀 수 없는 객체이다. 불변을 만들기 위해서는 `기본형 타입`과 `참조형 타입`에서 다른 방식으로 적용해야 한다.\n\n## 기본형 타입의 불변\n\n기본형 타입의 경우 참조 값이 아닌 실제 값이 저장되기 때문에 쉽게 적용이 가능하다. 내부 상태를 변경할 방법을 제한하면 불변을 보장한다. 즉 `setter` 생성을 제한하거나 `final` 키워드를 사용하면 된다.\n\n```java\npublic class Student {\n    private final int age;\n\n    public Student(int age) {\n        this.age = age;\n    }\n\n    public int getAge() {\n        return age;\n    }\n}\n```\n\n## 참조형 타입의 불변\n\n참조형 변수를 불변으로 만들기 위해서는 고려해야 할 것이 많다. 단순히 `final` 키워드를 사용할 경우 단순히 해당 참조 변수의 재할당만 막을 뿐이다.\n\n아래는 간단한 예시 작성을 위한 `일급 컬렉션`이다.\n\n```java\npublic class Student {\n    private String name;\n    private int age;\n\n    public Student(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n}\n```\n\n```java\npublic class Students {\n    private final List<Student> students;\n\n    public Students(List<Student> students) {\n        this.students = students;\n    }\n\n    public List<Student> getStudents() {\n        return students;\n    }\n}\n```\n\n인스턴스 변수를 Student List 하나만 갖는 `일급 컬렉션`이다. 살펴보면 `setter`가 존재하지 않기 때문에 자칫 잘못하면 `불변 객체`로 오해하기 쉽다.\n\n만약 원본 리스트가 3명의 학생을 가진다고 가정한다. 해당 리스트를 기반으로 Students를 생성한다. 불변성을 보장하기 위해서는 원본인 studentList에 값을 추가하더라도 Students 안에 students는 그대로 3명의 학생을 가져야 한다.\n\n```java\nclass StudentsTest {\n\n    @DisplayName(\"원본 리스트에서 값을 추가하면 해당 내부 리스트 또한 변경된다. 즉 불변이 아니다.\")\n    @Test\n    void 원본리스트에서_추가하면_변경된다() {\n        // given\n        Student student1 = new Student(\"학생1\", 20);\n        Student student2 = new Student(\"학생2\", 20);\n        Student student3 = new Student(\"학생3\", 20);\n\n        List<Student> studentList = new ArrayList<>(Arrays.asList(student1, student2, student3));\n\n        Students students = new Students(studentList);\n\n        // when\n        studentList.add(new Student(\"학생4\", 20));\n\n        // then\n        assertThat(students.getStudents().size()).isEqualTo(3);\n    }\n}\n```\n\n하지만 위 테스트는 `실패`한다. 이유는 원본 리스트와 Students의 students는 같은 주소를 가지고 있기 때문에 `heap` 메모리 안에 데이터를 공유하고 있다. 즉 원본 리스트가 수정되면 불변을 보장할 수 없다.\n\n이것을 막기 위해서는 생성 시점에 `방어적 복사`를 진행해야 한다.\n\n### 방어적 복사\n\n방어적 복사란, 생성자의 인자로 받은 객체의 `복사본`을 만들어` 내부 변수를 초기화`하거나 `getter` 메서드가 내부 변수를 반환할 때 객체의 복사본을 만들어 반환하는 것이다. 즉 `내부 객체를 보호`하기 위해 방어적인 복사를 사용하는 것이다.\n\n이것을 적용한 `Students`는 아래와 같다.\n\n```java\npublic class Students {\n    private final List<Student> students;\n\n    public Students(List<Student> students) {\n        this.students = new ArrayList<>(students);\n    }\n\n    public List<Student> getStudents() {\n        return students;\n    }\n}\n```\n\n이제 원본 리스트와 주소를 공유하지 않는다.\n\n```java\nclass StudentsTest {\n\n    @DisplayName(\"원본 리스트에서 값을 추가하면 해당 내부 리스트는 변경되지 않는다. 불변일까?\")\n    @Test\n    void 원본리스트에서_추가하면_변경되지_않는다() {\n        // given\n        Student student1 = new Student(\"학생1\", 20);\n        Student student2 = new Student(\"학생2\", 20);\n        Student student3 = new Student(\"학생3\", 20);\n\n        List<Student> studentList = new ArrayList<>(Arrays.asList(student1, student2, student3));\n\n        Students students = new Students(studentList);\n\n        // when\n        studentList.add(new Student(\"학생4\", 20));\n\n        // then\n        assertThat(students.getStudents().size()).isEqualTo(3);\n    }\n}\n```\n\n한 가지 주의해야 할 점은 방어적 복사는 `깊은 복사가 아니다`. 즉 내부 요소들은 `여전히 공유`되고 있다. 즉 내부 요소가 불변성을 보장하지 않고 수정이 가능하면 해당 요소를 가지는 리스트도 불변성을 보장하지 못한다. 또한 getter를 통해 내부 List를 `그대로 반환`하는 것도 불변에 있어서 큰 문제를 야기한다.\n\n```java\nclass StudentsTest {\n\n    @DisplayName(\"요소들은 공유된다. 즉 불변이 아니다.\")\n    @Test\n    void 요소들은_공유된다() {\n        // given\n        Student student1 = new Student(\"학생1\", 20);\n        Student student2 = new Student(\"학생2\", 20);\n        Student student3 = new Student(\"학생3\", 20);\n\n        List<Student> studentList = new ArrayList<>(Arrays.asList(student1, student2, student3));\n\n        Students students = new Students(studentList);\n\n        // when\n        for (Student student : studentList) {\n            student.setAge(10); // 값 수정\n        }\n\n        // then\n        assertThat(students.getStudents().get(0).getAge()).isEqualTo(20); // 테스트 실패\n    }\n\n    @DisplayName(\"get으로 반환된 리스트를 통해 내부 리스트 변경이 가능하다. 즉 불변이 아닌다.\")\n    @Test\n    void get으로_내부리스트_변경이_가능하다() {\n\n        // given\n        Student student1 = new Student(\"학생1\", 20);\n        Student student2 = new Student(\"학생2\", 20);\n        Student student3 = new Student(\"학생3\", 20);\n\n        List<Student> studentList = new ArrayList<>(Arrays.asList(student1, student2, student3));\n\n        Students students = new Students(studentList);\n\n        // when\n        List<Student> studentsInStudentList = students.getStudents();\n        studentsInStudentList.add(new Student(\"학생4\", 20)); // 요소 추가\n\n        // then\n        assertThat(students.getStudents().size()).isEqualTo(3); // 테스트 실패\n    }\n}\n```\n\n위 두 테스트는 모두 `실패`한다. 즉 내부 상태를 보호하지 못한다. 이때 필요한 것은 Unmodifiable Collection이다.\n\n### Unmodifiable Collection\n\nUnmodifiable Collection을 이용하면 변경이 일어날 때 즉시 `UnsupportedOperationException` 예외를 던진다. 즉 해당 리스트를 `읽기 전용`으로 사용할 수 있다.\n\n```java\nclass StudentsTest {\n\n    @DisplayName(\"값을 추가하면 예외를 던진다.\")\n    @Test\n    void 값을_추가하면_예외를_던진다() {\n        // given\n        Student student1 = new Student(\"학생1\", 20);\n        Student student2 = new Student(\"학생2\", 20);\n        Student student3 = new Student(\"학생3\", 20);\n\n        List<Student> studentList = new ArrayList<>(Arrays.asList(student1, student2, student3));\n\n        Students students = new Students(studentList);\n\n        // when & then\n        assertThatThrownBy(() -> {\n            students.getStudents().add(new Student(\"학생4\", 20));\n        }).isInstanceOf(UnsupportedOperationException.class);\n    }\n    ...\n}\n```\n\n하지만 이것이 완벽한 불변성을 보장해주지 않는다. 최초 예제처럼 원본 리스트가 변경될 경우 읽기 전용으로 선언한 리스트도 똑같이 변경되기 때문에 주의해서 사용해야 한다.\n\n## 정리\n\n정리하면 결국 내부 객체를 완벽히 보호하기 위해서는 `방어적 복사`와 `unmodifiable collection`을 적절히 활용해야 한다. 또한 내부의 모든 요소들이 불변성을 보장해야만 불변 객체를 만들 수 있다.\n\n```java\npublic class Student {\n    private final String name;\n    private final int age;\n\n    public Student(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n}\n```\n\n```java\npublic class Students {\n    private final List<Student> students;\n\n    public Students(List<Student> students) {\n        this.students = new ArrayList<>(students);\n    }\n\n    public List<Student> getStudents() {\n        return Collections.unmodifiableList(students);\n    }\n}\n```\n\n## References\n\n[불변객체를 만드는 방법](https://tecoble.techcourse.co.kr/post/2020-05-18-immutable-object/)<br>\n[방어적 복사와 Unmodifiable Collection](https://tecoble.techcourse.co.kr/post/2021-04-26-defensive-copy-vs-unmodifiable/)<br>\n"}]}},"pageContext":{}},"staticQueryHashes":[],"slicesMap":{}}