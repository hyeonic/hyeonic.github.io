---
title: Annotation 이란?
tags: ['Java', 'annotation']
---

# Annotation 이란?

애노테이션은 컴파일 과정에서 코드를 어떻게 컴파일할 것인지, 실행 과정에서 코드를 어떻게 처리할 것인지 알려주는 정보이다. 즉 `메타 데이터`로써의 역할을 한다. 

::: tip
메타 데이터는 데이터를 위한 설명을 의미한다.
:::

주로 컴파일러에게 코드 문법 에러를 검사하도록 `정보를 제공`하거나 코드를 `자동으로 생성`할 수 있도록 정보를 제공한다. `런타임`시에는 특정 기능을 실행하도록 정보를 제공한다.

애노테이션은 `주석`과 비슷한 류의 장치이다. 해당 장치를 한다는 `표시`를 남겨둔 것이다. 해당 애노테이션이 `어떠한 기능`을 가진 것은 아니다. 또한 `런타임` 중에 알아내야 하는 값, 즉 `동적인 값은 들어갈 수 없다`. `정적인 값`, `컴파일러 수준에서 해석이 가능한 값`들로만 엘리먼트로 들어갈 수 있다.

## Built-in Annotations

### 1. @Override
 * 선언한 메서드가 오버라이드 되었다는 것을 나타낸다. 상위 클래스에서 해당 메서드를 찾을 수 없으면 컴파일 에러를 발생 시킨다.

### 2. @Deprecated
 * 해당 메서드가 더 이상 사용되지 않음을 표시한다. 해당 애노테이션을 메서드 상단에 작성한 후 메서드를 사용하면 `컴파일 경고`를 발생 시킨다. 
 * 만약 기존에 작성한 메서드를 무작정 삭제하게 되면 기존에 메서드를 사용하던 개발자들은 직접 수정 작업을 거쳐야 한다. 하지만 단순히 @Deprecated 애노테이션을 사용하게 되면 앞으로 작성될 코드들에게도 경고를 할 수 있는 동시에 이전 소스 코드와 호환 또한 가능하다. 결국 `호환성`을 위하여 존재하는 애노테이션이다.

### 3. @SuppressWarnings
 * 선언한 곳의 컴파일 경고를 무시한다.

### 4. @SafeVarargs
 * Java 7 부터 지원하고, 제네릭 같은 가변인자의 매개변수를 사용할 때 경고를 무시한다.

### 5. @FunctionalInterface
 * Java 8부터 지원한다. 함수형 인터페이스를 지정하는 애노테이션이다. 메서드가 존재하지 않거나, 1개 이상의 메서드가 존재할 경우 컴파일 오류를 발생 시킨다.

## Meta Annotation

### 1. @Retention
 * 애노테이션 선언에 사용되는 메타 애노테이션이다. Java 컴파일러가 애노테이션을 다루는 방법을 기술한다. 어느 시점까지 영향을 미치는지 결정한다. 해당 정책들은 `java.lang.annotation.RetentionPolicy`에 enum으로 정의되어 있다.
 
```java
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.ANNOTATION_TYPE)
public @interface Retention {
    /**
     * Returns the retention policy.
     * @return the retention policy
     */
    RetentionPolicy value();
}
```

#### 종류
 * `@Retention(RetentionPolicy.SOURCE)`: 컴파일 전까지만 유효하다. 컴파일 이후에는 사라지기 때문에 바이트코드에서는 해당 애노테이션의 존재를 확인할 수 없다.
 * `@Retention(RetentionPolicy.CLASS)`: 컴파일러가 클래스를 참조할 때 까지 유효하다. 바이트코드에서 해당 애노테이션의 존재를 확인할 수 있다.
 * `@Retention(RetentionPolicy.RUNTIME)`: `클래스 로더`가 `클래스`를 `메모리에 적재`하는 시점에 애노테이션이 등록된다. 그렇기 때문에 `리플렉션`을 이용하여 런타임시에도 `애노테이션 정보`를 얻을 수 있다. 

::: tip
리플렉션은 Runtime 시에도 클래스의 메타 정보를 얻는 기능을 말한다.
:::

### 2. @Target
 * 애노테이션 선언에 사용되는 메타 애노테이션이다. 애노테이션을 적용할 수 있는 범위를 정의한다. `java.lang.annotation.ElementType`에 다양한 범위가 정의되어 있다.
 * `@Target`의 기본 엘리먼트는 `ElementType` 타입 배열의 값을 가질 수 있다. 또한 필드명이 `value`이기 때문에 필드명 `생략`이 가능하다.

```java
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.ANNOTATION_TYPE)
public @interface Target {
    /**
     * Returns an array of the kinds of elements an annotation type
     * can be applied to.
     * @return an array of the kinds of elements an annotation type
     * can be applied to
     */
    ElementType[] value();
}
```

```java
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.METHOD, ElementType.FIELD}) // value 생략하여 @Target 사용
public @interface CustomAnnotation {

    // Element
    String description();
}
```

#### 종류
 * `@Target(ElementType.TYPE)`: 클래스, 인터페이스, 열거 타입에 사용한다.
 * `@Target(ElementType.ANNOTATION_TYPE)`: 애노테이션에 사용한다.
 * `@Target(ElementType.FIELD)`: 필드에 사용한다.
 * `@Target(ElementType.CONSTRUCTOR)`: 생성자에 사용한다.
 * `@Target(ElementType.METHOD)`: 메서드에 사용한다.
 * `@TargetElementType.LOCAL_VARIABLE)`: 로컬 변수에 사용한다.
 * `@Target(ElementType.PACKAGE)`: 패키지에 사용한다.

### 5. @Documented
 * 애노테이션 선언에 사용되는 메타 애노테이션이다. 해당 애노테이션에 대한 정보가 JavaDoc 문서에 포함시킨다는 의미를 내포한다.

### 6. @Inherited
 * 애노테이션의 상속이 가능하도록 한다.

### 7. Repeatable   
 * Java 8 부터 지원하며, 연속적으로 애노테이션을 선언할 수 있도록 한다.

## References

[Java에서 어노테이션(Annotation) 이란?](https://elfinlas.github.io/2017/12/14/java-annotation/)

<TagLinks />