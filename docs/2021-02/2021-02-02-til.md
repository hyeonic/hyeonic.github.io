## 2021.02.02 알고리즘, 오브젝트, Spring Data JPA

## 알고리즘
[[Baekjoon Online Judge] 2156번: 포도주 시식](https://hyeonic.tistory.com/86)

[[Baekjoon Online Judge] 2193번: 이친수](https://hyeonic.tistory.com/87)

## 오브젝트
**12 다형성**

 상속의 목적은 코드 재사용이 아니다. 상속은 타입 계층을 구조화하기 위해 사용해야 한다.

 다형성이 런타임에 메시지를 처리하기에 적합한 메소드를 동적으로 탐색하는 과정을 통해 구현되며, 상속이 이런 메소드를 찾기 위한 일종의 탐색 경로를 클래스 계층의 형태로 구현하기 위한 방법이다.

**01 다형성**
 다형성 (Polymorphism) 이라는 단어는 그리스어에서 ‘많은’을 의미하는 ‘poly’와 ‘형태’를 의미하는 ‘morph’의 합성어로 ‘많은 형태를 가질 수 있는 능력’을 의미한다. 컴퓨터 과학에서는 다형성을 하나의 추상 인터페이스에 대해 코드를 작성하고 이 추상 인터페이스에 대해 서로 다른 구현을 연결할 수 있는 능력으로 정의한다. 간단하게 말해서 다형성은 여러 타입을 대상으로 동작할 수 잇는 코드를 작성할 수 있는 방법이다.

**02 상속의 양면성**
 객체지향 패러다임의 근간을 이루는 아이디어는 데이터와 행동을 객체라고 불리는 하나의 실행 단위 안으로 통합하는 것이다. 

 상속의 목적은 코드 재사용이 아니다. 상속은 프로그램을 구성하는 개념들을 기반으로 다형성을 가능하게 하는 타입 계층을 구축하기 위한 것이다. 타입 계층에 대한 고민 없이 코드를 재사용하기 위해 상속을 사용하면 이해하기 어렵고 유지보수하기 버거운 코드가 만들어질 확률이 높다.

**데이터 관점의 상속**
 데이터 관점에서 상속은 자식 클래스의 인스턴스 안에 부모 클래스의 인스턴스를 포함하는 것으로 볼 수 있다. 따라서 자식 클래스의 인스턴스는 자동으로 부모 클래스에서 정의한 모든 인스턴스 변수를 내부에 포함하게 되는 것이다.

**행동 관점의 상속**
 데이터 관점의 상속 – 자식 클래스의 인스턴스 안에 부모 클래스의 인스턴스를 포함하는 개념
 행동 관점의 상속 – 부모 클래스가 정의한 일부 메소드를 자식 클래스의 메서드로 포함시키는 것을 의미

 외부의 객체가 부모 클래스의 인스턴스에게 전송할 수 있는 모든 메시지는 자식 클래스의 인스턴스에게도 전송할 수 있다.

 행동 관점에서 상속과 다형성의 기본적인 개념을 이해하기 위해서는 상속 관계로 연결된 클래스 사이의 메소드 탐색 과정을 이해하는 것이 가장 중요하다.

**03 업캐스팅과 동적 바인딩**

같은 메시지, 다른 메소드
 코드 안에서 선언된 참조 타입과 무관하게 실제로 메시지를 수신하는 객체의 타입에 따라 실행되는 메소드가 달라질 수 있는 것은 업캐스팅과 동적 바인딩이라는 메커니즘이 작용하기 때문이다.

 - 부모 클래스 타입으로 선언된 변수에 자식 클래스의 인스턴스를 할당하는 것이 가능하다. 이를 업캐스팅이라고 부른다.
 - 선언된 변수의 타입이 아니라 메시지를 수신하는 객체의 타입에 따라 실행되는 메소드가 결정된다. 이것은 객체지향 시스템이 메시지를 처리할 적절한 메소드를 컴파일 시점이 아니라 실행 시점에 결정하기 때문에 가능하다. 이를 동적 바인딩이라고 부른다.

**04 동적 메소드 탐색과 다형성**

 - 메시지를 수신한 객체는 먼저 자신을 생성한 클래스에 적합한 메소드가 존재하는지 검사한다. 존재하면 메소드를 실행하고 탐색을 종료한다.
 - 메소드를 찾지 못했다면 부모 클래스에서 메소드 탐색을 계속한다. 이 과정은 적합한 메소드를 찾을 때까지 상속 계층을 따라 올라가며 계속된다.
 - 상속 계층의 가장 최상위 클래스에 이르렀지만 메소드를 발견하지 못한 경우 예외를 발생시키며 탐색을 중단한다.

 동적 메소드 탐색은 두 가지 원리로 구성된다.
  - 자동적인 메시지 위임, 자식 클래스는 자신이 이해할 수 없는 메시지를 전송 받는 경우 상속 계층을 따라 부모 클래스에게 처리를 위임이다.
- 메소드를 탐색하기 위한 동적인 문맥을 사용. 메시지를 수신했을 때 실제로 어떤 메소드를 실행할지를 결정하는 것은 컴파일 시점이 아닌 실행 시점에 이뤄지며, 메소드를 탐색하는 경로는 self 참조를 이용해서 결정한다.

**05 상속 대 위임**

위임과 self 참조
 자신이 수신한 메시지를 다른 객체에게 동일하게 전달해서 처리를 요청하는 것을 위임 (delegation) 이라고 부른다.

조영호 지음, 오브젝트

&nbsp;이번 chapter의 주제는 왜 인지 모르겠는데 굉장히 어렵게 다가왔다. 기존에 알던 개념들이 많아서 오히려 혼동을 야기한 것 같다. 

## Spring Data JPA
 - EntityGraph
  - fetch join을 간편하게 사용할 수 있다. JPQL을 사용하지 않고 EntityGraph 애노테이션만 붙이면 n + 1문제를 간단하게 해결 할 수 있다. 해당 애노테이션을 사용하는데 의의를 두지 말고, 작성한 쿼리를 이해하여 그 쿼리가 n + 1문제를 유발할 수 있는지 확인하고 검증하는 시야를 길러야 겠다는 생각이 들었다.

 - JPA Hint & Lock
  - JPA의 구현체에게 제공하는 힌트이다. 예를들면 특정 메소드를 readOnly로 설정하면, 쿼리로 나온 엔티티의 값을 읽기만 가능하게 보장한다. JPA가 제공하는 기술은 아니기 때문에 JPA의 구현체에게 힌트를 제공해야 한다. 특히 page을 위한 조회를 할 때 매우 도움이 될 것으로 예상된다. 하지만 알고 사용하는 것이 더욱 중요하다!

 - Auditiong
  - 엔티티를 생성, 변경할 때 사람과 시간을 추적하기 위해 사용한다. 이 예제를 따라하면서 너무 신기하였다. 자동으로 업데이트되는 수정일과 수정자들을 업데이트 할 수 있고, 필드도 추가해서 확인할 수 있는 부분이 프로젝트를 진행할 때 큰 도움이 될 것이다.

 - 페이징과 정렬
  - 간단한 페이징을 위한 방법에 대해 공부하였다. JPA가 기본으로 제공해주는 페이징과 정렬 관련한 구현체들이 많았고, 그것을 온전히 이해하고 사용만 하면 된다. 특히 엔티티 자체를 view에 반환하는 것은 서버 내부의 구조를 온전히 보여주는 것이기 때문에 dto를 활용해야 하는 것을 강조하였다. 추가로 엔티티와 dto를 구별하면 엔티티가 바뀌는 경우 통신을 위한 API docs를 수정하지 않아도 항상 의도된 대로 값을 전달할 수 있음을 보장한다.

## 내일 할일
 - Spring Data JPA 강의 듣기
 - 오브젝트 책 읽기
 - 알고리즘 문제 풀기