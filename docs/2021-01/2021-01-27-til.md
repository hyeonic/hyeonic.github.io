## 2021.01.27 오브젝트, java 멘토링, 알고리즘, java live study

## 오브젝트
**10 상속과 코드 재사용**

&nbsp;클래스를 재사용하기 위해 새로운 클래스를 추가하는 가장 대표적인 기법인 상속에 관해 살펴본다. 재사용 관점에서 상속이란 클래스 안에 정의된 인스턴스 변수와 메소드를 자동으로 새로운 클래스에 추가하는 구현 기법이다.

**DRY 원칙**
&nbsp;중복 코드는 변경을 방해한다. 일단 새로운 코드를 추가하고 나면 언젠가는 변경될 것이라고 생각하는 것이 현명하다. 중복 코드는 수정하는 데 필요한 노력을 몇 배로 증가시킨다.

**중복과 변경**
**중복 코드 살펴보기**
&nbsp;중복되는 코드를 복사하여 구현하면, 구현 시간을 절약한 대가로 지불해야 하는 비용은 예상보다 크다. 두 코드 사이에 중복 코드가 존재하기 때문에 언제 터질지 모르는 시한폭탄을 안고 있는 것과 같다. 

**상속을 이용해서 중복 코드 제거하기**
&nbsp;이미 존재하는 클래스와 유사한 클래스가 필요하다면 코드를 복사하지 말고 상속을 이용해 코드를 재사용하는 것이다. 

&nbsp;상속을 염두에 두고 설계되지 않은 클래스를 상속을 이용해 재사용하는 것은 생각처럼 쉽지 않다. 

**02 위약한 기반 클래스 문제**
&nbsp;상속은 자식 클래스와 부모 클래스의 결합도를 높인다. 이 강한 결합도로 인해 자식 클래스는 부모 클래스의 불필요한 세부사항에 엮이게 된다. 

&nbsp;이처럼 부모 클래스의 변경에 의해 자식 클래스가 영향을 받는 현상을 취약한 기반 클래스 문제 (Fragile Base Class Problem, Brittle Base Class Problem) 이라고 부른다. 이 문제는 상속을 사용한다면 피할 수 없는 객체지향 프로그래밍의 근본적인 취약성이다.

**불필요한 인터페이스 상속 문제**
&nbsp;Java 초기 버전에서 상속을 잘못 사용한 대표적인 사례 java.util.Properties, java.util.Stack

&nbsp;객체지향의 핵심은 객체들의 협력이다. 단순히 코드를 재사용하기 위해 불필요한 오퍼레이션이 인터페이스에 스며들도록 방치해서는 안 된다. 상속받은 부모 클래스의 메소드가 자식 클래스의 내부 구조에 대한 규칙을 깨트릴 수 있다.

**메소드 오버라이딩의 오작용 문제**
&nbsp;HashSet의 구현에 강하게 결합된 InstrumentedHashSet 클래스.

&nbsp;자식 클래스가 부모 클래스의 메소드를 오버라이딩할 경우 부모 클래스가 자신의 메소드를 사용하는 방법에 자식 클래스가 결합될 수 잇다.

**부모 클래스와 자식 클래스의 동시 수정 문제**
&nbsp;자식 클래스가 부모 클래스의 메소드를 오버라이딩하거나 불필요한 인터페이스를 상속받지 않았음에도 부모 클래스를 수정할 때 자식 클래스를 함께 수정해야 할 수도 있다는 사실을 잘 보여준다. 상속을 사용하면 자식 클래스가 부모 클래스의 구현에 강하게 결합되기 때문에 이 문제를 피하기는 어렵다.

**상속을 위한 경고**
 - 자식 클래스의 메소드 안에서 super 참조를 이용해 부모 클래스의 메소드를 직접 호출할 경우 두 클래스는 강하게 결합된다. super 호출을 제거할 수 있는 방법을 찾아 결합도를 제거하라.
 - 상속받은 부모 클래스의 메소드가 자식 클래스의 내부 구조에 대한 규칙을 깨트릴 수 있다.
 - 자식 클래스가 부모 클래스의 메소드를 오버라이딩할 경우 부모 클래스가 자신의 메소드를 사용하는 방법에 자식 클래스가 결합될 수 있다.
 - 클래스를 상속하면 결합도로 인해 자식 클래스와 부모 클래스의 구현을 영원히 변경하지 않거나, 자식 클래스와 부모 클래스를 동시에 변경하거나 둘 중 하나를 선택할 수밖에 없다.

**추상화에 의존하자**
&nbsp;자식 클래스가 부모 클래스의 구현이 아닌 추상화에 의존하도록 만드는 것이다. 부모 클래스와 자식 클래스 모두 추상화에 의존하도록 수정해야 한다.

**차이를 메소드로 추출하라**
&nbsp;중복 코드 안에서 차이점을 별도의 메소드로 추출하는 것이다. “변하는 것으로부터 변하지 않는 것을 분리하라”, “변하는 부분을 찾고 이를 캡슐화 하라”.

**중복코드를 부모 클래스로 올려라**
&nbsp;부모 클래스를 추가하자. 목표는 모든 클래스들이 추상화에 의존하도록 만드는 것이기 때문에 이 클래스는 추상 클래스로 구현하는 것이 적합할 것이다. 

**추상화가 핵심이다**
&nbsp;상속 계층이 코드를 진화 시키는 데 걸림돌이 된다면 추상화를 찾아내고 상속 계층 안의 클래스들이 그 추상화에 의존하도록 코드를 리팩터링하라. 차이점을 메서드로 추출하고 공통적인 부분은 부모 클래스로 이동하라.

**의도를 드러내는 이름 선택하기**
&nbsp;해당 내용을 구현한다는 사실을 명확하게 전달해야 한다.

**04 차이에 의한 프로그래밍**
&nbsp;기존 코드와 다른 부분만을 추가함으로써 애플리케이션의 기능을 확장하는 방법을 차이에 의한 프로그래밍 (programing by difference) 이라고 부른다. 상속을 이용하면 이미 존재하는 클래스의 코드를 쉽게 재사용할 수 있기 때문에 애플리케이션의 점진적인 정의가 가능해진다.

&nbsp;상속은 코드 재사용과 관련된 대부분의 경우에 우아한 해결 방법이 아니다. 객 체지향에 능숙한 개발자들은 상속의 단점을 피하면서도 코드를 재사용할 수 있는 더 좋은 방법이 있다는 사실을 알고 있다. 바로 합성이다.

## java 멘토링
&nbsp;java의 연산자에 대한 멘토링을 진행하였다. 다른 언어와 상당 부분 비슷하기 때문에 짚고 넘어가야 할 부분만 간단하게 설명하였다. 직접 라이브 코딩을 진행하며 질의응답을 나누었다. 

## 알고리즘
[[다이나믹 프로그래밍] Dynamic programming](https://hyeonic.tistory.com/76)

[[Baekjoon Online Judge] 1463번: 1로 만들기](https://hyeonic.tistory.com/78)

## java live study
[11주차 과제: Enum](https://hyeonic.tistory.com/75)

## 내일 할일
 - 알고리즘 문제 풀이
 - 오브젝트 일기
 - JPA 기본 강의 듣기