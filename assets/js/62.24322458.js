(window.webpackJsonp=window.webpackJsonp||[]).push([[62],{526:function(e,a,t){"use strict";t.r(a);var v=t(21),o=Object(v.a)({},(function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"garbage-collection-란"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#garbage-collection-란"}},[e._v("#")]),e._v(" Garbage Collection 란?")]),e._v(" "),t("p",[t("code",[e._v("Garbage Collection")]),e._v("은 "),t("code",[e._v("JVM")]),e._v(" 상에서 더 이상 사용되지 않는 데이터가 할당되어 있는 메모리를 해제시켜준다. 보통 "),t("code",[e._v("GC")]),e._v("가 JVM "),t("code",[e._v("Heap 영역")]),e._v("에 있는 객체 중 참조되지 않는 데이터를 "),t("code",[e._v("자동적")]),e._v("으로 해제시켜주기 때문에 개발자는 "),t("code",[e._v("메모리 관리")]),e._v("를 "),t("code",[e._v("직접적으로 해줄 필요가 없다.")])]),e._v(" "),t("p",[e._v("이러한 "),t("code",[e._v("GC")]),e._v("로 인하여 "),t("code",[e._v("한정된 메모리")]),e._v("를 "),t("code",[e._v("효율적")]),e._v("으로 사용할 수 있도록 도와주고 개발자들에게 "),t("code",[e._v("메모리 관리")]),e._v("를 위한 "),t("code",[e._v("부담을 줄여준다.")])]),e._v(" "),t("h2",{attrs:{id:"weak-generational-hypothesis"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#weak-generational-hypothesis"}},[e._v("#")]),e._v(" Weak Generational Hypothesis")]),e._v(" "),t("p",[t("code",[e._v("GC")]),e._v("를 성공적으로 수행하는 "),t("code",[e._v("Algorithm")]),e._v("으로 설계하기 위해서는 "),t("code",[e._v("Weak Generational Hypothesis")]),e._v(" "),t("code",[e._v("가설")]),e._v("이 필요하다.")]),e._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[e._v("Weak Generational Hypothesis")]),e._v(" "),t("ul",[t("li",[e._v("대부분의 객체는 금방 접근 불가능 상태(unreachable)가 된다.")]),e._v(" "),t("li",[e._v("오래된 객체에서 젋은 객체로의 참조는 아주 적게 존재한다.")])])]),e._v(" "),t("p",[e._v("이러한 가설을 바탕으로 GC가 수행될 수 있도록 하는 알고리즘은 기본적으로 "),t("code",[e._v("Mark And Sweep Algorithm")]),e._v("과 "),t("code",[e._v("Mark And Compact Algorithm")]),e._v("이 존재한다.")]),e._v(" "),t("h3",{attrs:{id:"mark-and-sweep-algorithm"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mark-and-sweep-algorithm"}},[e._v("#")]),e._v(" Mark And Sweep Algorithm")]),e._v(" "),t("p",[e._v("어떤 "),t("code",[e._v("heap")]),e._v(" 영역에 할당된 객체가 유효한 참조가 있으면 "),t("code",[e._v("reachability")]),e._v("이고 없다면 "),t("code",[e._v("unreachability")]),e._v("로 판단한다. 하나의 객체는 다른 객체를 참조하고, 다른 객체는 또 다른 객체를 참조할 수 있기 때문에 "),t("code",[e._v("참조 사슬")]),e._v("이 형성된다. 이러한 참조 사슬 중 최초에 참조한 것을 "),t("code",[e._v("Root Set")]),e._v("이라고 한다. "),t("code",[e._v("Heap")]),e._v(" 영역에 있는 객체들은 4가지 경우에 대한 참조를 가진다.")]),e._v(" "),t("p",{attrs:{align:"center"}},[t("img",{attrs:{src:"https://user-images.githubusercontent.com/59357153/137903377-d2671165-d22c-45aa-83a2-25b1d22c8503.png"}})]),e._v(" "),t("ol",[t("li",[e._v("heap 영역 내의 다른 객체에 의한 참조")]),e._v(" "),t("li",[e._v("stack 영역에 지역변수와 매개변수들에 의한 참조")]),e._v(" "),t("li",[e._v("native stack, JNI(Java Native Interface)에 의해 생성된 객체에 대한 참조")]),e._v(" "),t("li",[e._v("메서드 영역의 정적 변수에 의한 참조")])]),e._v(" "),t("p",[e._v("이중 "),t("code",[e._v("2")]),e._v(", "),t("code",[e._v("3")]),e._v(", "),t("code",[e._v("4")]),e._v("가 "),t("code",[e._v("Root Set")]),e._v("이 될 수 있다.")]),e._v(" "),t("p",[t("code",[e._v("Root Set")]),e._v(" 부터 출발하여 "),t("code",[e._v("참조되는 객체")]),e._v("들에 대해 "),t("code",[e._v("Mark")]),e._v("를 진행한다. 이 단계를 "),t("code",[e._v("Mark Phase")]),e._v("라고 한다. "),t("code",[e._v("Mark")]),e._v("되지 않은 객체들은 추적하여 삭제를 진행한다. 삭제를 진행하는 단계를 "),t("code",[e._v("Sweep Phase")]),e._v("라고 한다.")]),e._v(" "),t("p",[e._v("하지만 이러한 방식은 "),t("code",[e._v("메모리 단편화")]),e._v("를 야기한다. 이것을 해결하기 위해 "),t("code",[e._v("Mark And Compact Algorithm")]),e._v("이 등장하였다.")]),e._v(" "),t("h3",{attrs:{id:"mark-and-compact-algorithm"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mark-and-compact-algorithm"}},[e._v("#")]),e._v(" Mark And Compact Algorithm")]),e._v(" "),t("p",[t("code",[e._v("Mark And Compact Algorithm")]),e._v("은 "),t("code",[e._v("Mark And Sweep Algorithm")]),e._v("와 동일하게 "),t("code",[e._v("Mark")]),e._v("를 진행하고 참조되지 않는 객체를 "),t("code",[e._v("삭제")]),e._v("한다. 더 나아가 "),t("code",[e._v("메모리를 정리")]),e._v("하여 "),t("code",[e._v("메모리 단편화")]),e._v("를 "),t("code",[e._v("해결")]),e._v("한다.")]),e._v(" "),t("h2",{attrs:{id:"minor-gc와-major-gc"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#minor-gc와-major-gc"}},[e._v("#")]),e._v(" Minor GC와 Major GC")]),e._v(" "),t("p",{attrs:{align:"center"}},[t("img",{attrs:{src:"https://user-images.githubusercontent.com/59357153/137896624-df70dfad-8b21-482b-85f9-b478484df4b6.png"}})]),e._v(" "),t("h3",{attrs:{id:"minor-gc"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#minor-gc"}},[e._v("#")]),e._v(" Minor GC")]),e._v(" "),t("p",[e._v("새로 생성된 대부분의 객체(인스턴스)는 "),t("code",[e._v("Eden")]),e._v(" 영역에 위치한다. "),t("code",[e._v("Eden")]),e._v(" 영역에서 GC가 발생한 후 살아남은 객체는 두개의 "),t("code",[e._v("Suvivor")]),e._v(" 영역 중 하나로 이동한다. 이 과정은 반복되며 계속 살아남는 객체는 일정 시간 참조되고 있다는 의미로 "),t("code",[e._v("Old")]),e._v(" 영역으로 이동한다. 이때도 짧은 시간의 "),t("code",[e._v("stop-the-world")]),e._v("가 일어나지만 무시 가능한 짧은 시간이기 때문에 이루어지지 않는다고 간주한다.")]),e._v(" "),t("h3",{attrs:{id:"major-gc"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#major-gc"}},[e._v("#")]),e._v(" Major GC")]),e._v(" "),t("p",[e._v("Old 영역에 있는 모든 객체들을 검사하여 참조되지 않는 객체들을 "),t("code",[e._v("한꺼번에 삭제")]),e._v("한다. 그렇기 때문에 상당히 긴 시간 동안 "),t("code",[e._v("stop-the-world")]),e._v("이 이루어진다.")]),e._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[e._v("stop-the-world")]),e._v(" "),t("p",[t("code",[e._v("GC")]),e._v("가 일어나면 "),t("code",[e._v("GC")]),e._v("를 담당하고 있는 스레드를 제외한 모든 스레드는 일시적으로 작동이 "),t("code",[e._v("정지")]),e._v("된다. 이것을 "),t("code",[e._v("stop-the-world")]),e._v("라고 한다. 빈번한 GC 호출은 성능을 저하시킨다. GC 튜닝이란 결국 "),t("code",[e._v("stop-the-world")]),e._v("의 시간을 줄이는 것이 핵심이다. 이것은 "),t("code",[e._v("Mark And Compact Algorithm")]),e._v("을 기반한 여러 GC 방식들을 적용하면 해결 가능하다.")])]),e._v(" "),t("h2",{attrs:{id:"gc-방식-변경"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#gc-방식-변경"}},[e._v("#")]),e._v(" GC 방식 변경")]),e._v(" "),t("p",[e._v("Java 애플리케이션 실행 시 다양한 종류의 GC로 변경하여 상황에 맞게 튜닝이 가능하다.")]),e._v(" "),t("div",{staticClass:"language-bash extra-class"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[e._v("java -XX:+UseSerialGC javaApplication\njava -XX:+UseParallelGC javaApplication\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("..")]),e._v(".\n")])])]),t("p",[e._v("모든 Java 기반의 서비스에서 GC 튜닝이 필수적인 것은 아니다. 운영하고 있는 서비스의 GC를 적게 하도록 객체 생성을 줄이는 작업이 더 우선적이다.")]),e._v(" "),t("h2",{attrs:{id:"references"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#references"}},[e._v("#")]),e._v(" References")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://d2.naver.com/helloworld/329631",target:"_blank",rel:"noopener noreferrer"}},[e._v("Java Reference와 GC"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://d2.naver.com/helloworld/37111",target:"_blank",rel:"noopener noreferrer"}},[e._v("Garbage Collection 튜닝"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://tecoble.techcourse.co.kr/post/2021-08-30-jvm-gc/",target:"_blank",rel:"noopener noreferrer"}},[e._v("JVM에 관하여 - Part 4, Garbage Collection 기초"),t("OutboundLink")],1),t("br"),e._v(" "),t("a",{attrs:{href:"https://asfirstalways.tistory.com/159",target:"_blank",rel:"noopener noreferrer"}},[e._v("가비지컬렉션(Garbage Collection)/JVM 구동원리에 이어서"),t("OutboundLink")],1),t("br")]),e._v(" "),t("TagLinks")],1)}),[],!1,null,null,null);a.default=o.exports}}]);